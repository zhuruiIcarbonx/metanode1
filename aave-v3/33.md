理解 Web3 借贷协议中的利息机制
在像 Aave V3 这样的去中心化金融 (DeFi) 借贷协议中，准确计算借款人和贷款人的利息至关重要。虽然底层机制有所不同，但一个被称为“利率累加函数”的核心概念可以适用于这两种情况。本课程将探讨如何计算借款人和贷款人代币的利息，重点介绍这些差异以及统一其计算方式的优雅解决方案。

债务利率累积函数
债务计算的核心是利率累加函数，我们将其表示为R(n)。该函数量化了复利随时间推移的累积效应。

其定义是：

R(n) = ( 1  + r₀)( 1  + r₁)( 1  + r₂)...( 1  + rₙ)
其中rᵢ表示第 i 秒的利率。

债务利息的主要特征：

每秒复利：借入代币的利息每秒复利一次。这意味着，每秒累积的利息都会添加到本金中，下一秒的利息将根据新的、更大的本金计算。

可变利率：利率（rate）并非静态的，它会随时间变化。例如，利率可能在几秒钟内（或在模型中以秒为单位表示的更长时间内）保持不变，然后更新为新值。这可以可视化为一个分段常数图，其中利率在一段时间内保持平稳，然后在特定时间点跃升至新的水平。

如何用复利计算债务
为了理解如何R(n)使用，让我们考虑一个例子：

某用户借入100个代币。

借贷期限为从time = 1至time = 5（即4秒的有效利息累积）。

time = 0从到，利率为每秒 1% time = 3。因此，对于贷款：

r₁t=1（从到第二个月的利息t=2）= 1%。

r₂t=2（从到第二个月的利息t=3）= 1%。

利率更新为每秒 2% time = 3。因此，对于贷款：

r₃t=3（从到第二个月的利息t=4）= 2%。

r₄t=4（从到第二个月的利息t=5）= 2%。

总债务是通过将本金乘以(1 + interest_rate)贷款活跃的每一秒来计算的：

债务=  100  * ( 1  + r₁)( 1  + r₂)( 1  + r₃)( 1  + r₄)
债务=  100  * ( 1  +  0 .01 ) * ( 1  +  0 .01 ) * ( 1  +  0 .02 ) * ( 1  +  0 .02 )
这个计算可以用全局速率累加函数 优雅地表达出来R(n)。它R(n)表示从全局起始时间（比如t=0_system）到第 n 秒的累积速率因子：
R(n) = (1 + r_sys_0)(1 + r_sys_1)...(1 + r_sys_n)

如果我们贷款的相关利率r₁, r₂, r₃, r₄与系统的利率相对应r_sys_1, r_sys_2, r_sys_3, r_sys_4，那么债务可以通过以下方式找到：

债务=本金* R(贷款结束时的指数) / R(贷款开始前的指数)
在我们的例子中，这将是：

债务=  100  * R( 4 ) / R( 0 )
这里，R(4) = (1+r_sys_0)(1+r_sys_1)(1+r_sys_2)(1+r_sys_3)(1+r_sys_4)和R(0) = (1+r_sys_0)。
因此，R(4) / R(0)收益率(1+r_sys_1)(1+r_sys_2)(1+r_sys_3)(1+r_sys_4)恰好与(1+r₁)(1+r₂)(1+r₃)(1+r₄)我们100个代币贷款所需的因子相匹配。这里的指数0和4指的是利率累积的全局时间轴上的点。

计算所提供代币的利息：一种不同的方法
所供应代币（提供给协议的流动性）的利息计算遵循与债务不同的模式。

与债务利息的主要区别：

无每秒复利：所提供代币的利息不会每秒复利。

先线性增长，再复利：相反，它基于当前供应率每秒线性增长。这种线性累积持续到系统范围内的利率更新。

按利率更新复利：当系统利率更新时，上一期间线性累积的总利息实际上会与本金进行复利。然后，这笔新的、更大的本金将根据新利率开始累积线性利息。

我们来举个例子来说明一下：

某用户以的价格提供100 个代币time = 1。

time = 0从到的供应利率为每秒 1% time = 3。

r₁t=1（用户从到的兴趣t=2）= 1%。

r₂t=2（用户从到的兴趣t=3）= 1%。

供应利率每秒更新为 2% time = 3。

r₃t=3（用户从到的兴趣t=4）= 2%。

r₄t=4（用户从到的兴趣t=5）= 2%。

用户在 提取他们的代币time = 5。

供货量计算：

从time = 1到time = 3（利率更新前）：
利息呈线性增长。本期累计利息为(r₁ + r₂)。
本期系数为(1 + r₁ + r₂)。
本期后金额（在 时t=3）= 100 * (1 + r₁ + r₂) = 100 * (1 + 0.01 + 0.01) = 100 * (1.02)。

time = 3利率更新时
： 该金额100 * (1.02)将成为下一期的新本金。复利事件发生于此。

从time = 3到time = 5（利率更新后）：
利息再次随新利率（2%）线性增长。本期累计利息为(r₃ + r₄)。
本期系数为(1 + r₃ + r₄)。
本期新本金累计金额 = (New Principal) * (1 + r₃ + r₄)。

总金额time = 5：

供应量=  100  * ( 1  + r₁ + r₂ ) * ( 1  + r₃ + r₄ )
供应量=  100  * ( 1  +  0 .01  +  0 .01 ) * ( 1  +  0 .02  +  0 .02 )
供应量=  100  * ( 1.02 ) * ( 1.04 ) =  106.08
调整利率累加器以适应供给侧利率
利率累加器的概念最初是针对每秒复利债务的，那么它能否适用于这种先线性再复利的供给利率呢？答案是肯定的，但需要经过深思熟虑的修改。

让我们定义线性利息总和的块：

令s₁ = r₁ + r₂。这是用户第一个存款期（从t=1到t=3，系统利率更新之前）的线性利率之和。在我们的例子中，s₁ = 0.01 + 0.01 = 0.02。

令s₂ = r₃ + r₄。这是用户第二个存款期（系统利率更新后，从t=3到）的线性利率之和。在我们的示例中， 。t=5s₂ = 0.02 + 0.02 = 0.04

供给量可以写为：

供应量=  100  * ( 1  + s₁ ) * ( 1  + s₂ )
现在，我们引入一个修改后的供应率累加器，我们称之为S(n)：

S(n) = ( 1  + s_glob_0)( 1  + s_glob_1)( 1  + s_glob_2)...( 1  + s_glob_n)
这里，每个值s_glob_i代表官方利率更新间隔第 i 个系统范围内周期内累积的每秒线性利率之和。例如，s_glob_1将是第一个系统定义的利率周期内所有每秒利率之和，s_glob_2第二个周期也是如此，以此类推。

用户可以提取的总金额（其初始本金加上所有应计供应利息）可以使用此S(n)累加器计算，类似于债务计算：

提供金额=本金* S(index_at_withdrawal_period_end) / S(index_at_deposit_period_start)
在我们的示例中，如果用户的s₁对应于系统s_glob_1（或与其存款窗口相关的部分）并且他们的s₂对应于s_glob_2，并且我们适当地调整索引，则可以表示为：

供应量=  100  * S(k) / S(j)
对于示例值，100 * (1+s₁)(1+s₂)表示该术语S(k)/S(j)必须解析为(1+s₁)(1+s₂)。如果s₁是用户第一个相关系统周期的利息总和，而s₂是第二个相关系统周期的利息总和，则S(j)将是该周期之前的累加器值s₁，以及S(k)该周期之后的值s₂。例如，如果S(0)是基准值，S(1) = S(0)(1+s₁)且S(2) = S(1)(1+s₂) = S(0)(1+s₁)(1+s₂)，则S(2)/S(0)得出所需的(1+s₁)(1+s₂)。

统一利息计算：债务与供给
这种方法的强大之处在于，计算总余额的基本算法
Final Amount = Initial Principal * Accumulator(end_time_index) / Accumulator(start_time_index)
可以一致地应用于借款人和供应商。

关键的区别在于所用累加器的定义和构造：

对于债务：使用R(n)累加器，其中每(1 + rᵢ)一项代表每秒复利。它们rᵢ是单独的每秒利率。

对于供应：使用S(n)累加器，其中每一项(1 + sᵢ)代表一个线性累计利息块，该利息块在系统范围利率更新时进行复利。它们sᵢ是这些不同时期内每秒线性利率的总和。

这种调整使得 Aave V3 等协议能够采用一致且高效的架构模式来计算利息，尽管债务和供应资产的累积机制不同，但能够确保所有用户的公平性和准确性。
