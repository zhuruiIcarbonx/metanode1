DeFi 困境：追踪不断变化的利率下的余额
在去中心化金融 (DeFi) 中，借贷协议通常采用浮动利率，这种利率可能会随着每个区块甚至更细粒度的变化而变化，逐秒复利。直接实时更新每个用户的供款余额或未偿债务以反映这些持续累积的利息，在区块链上计算量巨大。这种方法会导致过高的 Gas 成本和网络拥堵，使协议难以实际使用。因此，DeFi 协议需要一种高效且可扩展的机制来准确跟踪用户余额，而无需为每个用户进行持续的链上更新。

缩放天平简介：Bank.sol入门
为了理解 DeFi 协议如何应对这一挑战，我们来考虑一个简化的智能合约。Bank.sol这个例子说明了“缩放”或“标准化”余额的基本概念。

其核心思想是避免存储用户债务（或提供的资产）的原始绝对值。相反，合约存储的是该债务的缩放表示。这通过一个关键变量实现：

cumulativeRates：此全局变量跟踪随时间推移的总利率。随着利息的累积，cumulativeRates利率也会随之增加，反映自协议成立以来或特定时期以来的总增长因子。

当用户与协议交互时：

借款：在更新用户的债务余额之前，该cumulativeRates变量会被更新以反映最新的利息。然后，用户希望借入的金额除以当前金额，再添cumulativeRates加到其存储的、按比例缩放的债务中。

// 来自 Bank.sol 的概念逻辑
函数 借入（uint256金额）外部 {
    updateCumulativeRates(); // 确保cumulativeRates反映所有应计利息
    // debts[msg.sender] 存储缩放后的债务金额
    // 假设使用 1e18 作为精度因子（例如，Aave 的 RAY）
    债务[ msg . sender ] + = (金额*  1e18 ) /累积利率;
}
偿还：同样，当用户偿还时，cumulativeRates也会更新。偿还金额也会除以当前金额，cumulativeRates然后从其存储的按比例计算的债务中扣除。

// 来自 Bank.sol 的概念逻辑
函数 偿还（uint256金额）外部 {
    更新累积率（）；
    债务[ msg . sender ] - = (金额*  1e18 ) /累积利率;
}
有了这种机制，debts[msg.sender]存储的缩放债务的价值无需随着利息的累积而每秒进行修改。实际的当前债务可以随时通过将用户存储的缩放债务乘以当前债务来计算cumulativeRates。此计算通常在链下进行以显示，或在另一笔交易需要了解真实余额时在链上进行。

Aave V3 如何实现缩放余额ScaledBalanceTokenBase.sol
领先的 DeFi 借贷协议 Aave V3 采用了这种扩展余额技术的更复杂、更精确的版本。其核心逻辑封装在名为 的基础合约中ScaledBalanceTokenBase.sol。

在 Aave V3 中：

当用户提供资产（例如 DAI）时，他们会收到相应的A 代币（例如 aDAI），它们是有利息的代币。

当用户借入资产时，他们的债务由可变债务代币（例如，variableDebtDAI）表示。

A 代币和可变债务代币都继承了 的关键功能ScaledBalanceTokenBase.sol。此合约使用了一个变量，其用途与我们简化示例中index的类似。cumulativeRatesBank.sol

对于 A-Tokens（供应资产），这是流动性指数，跟踪供应商赚取的累计利息。

对于可变债务代币（借入资产），这是可变债务指数，跟踪借入产生的累计利息。

铸造（供应/借入时发行新代币）和销毁（提取/偿还时赎回代币）操作主要由内部功能_mintScaled和_burnScaled内部处理ScaledBalanceTokenBase.sol。

功能_mintScaled：发行有息和债务代币
_mintScaled当需要铸造 A 代币（例如，用户存入抵押品）或发行可变债务代币（例如，用户借入资产）时，将调用内部函数。

缩放金额：实际amount供应或借入的标的资产金额会按比例减少。具体方法是用 除以amount当前值（流动性指数或可变债务指数，取决于具体操作）。Aave为此index使用了高精度除法函数。rayDiv

// ScaledBalanceTokenBase.sol 内部 - _mintScaled 函数（概念表示）
// uint256 amount：标的资产的实际数量
// uint256 index：当前累计利率指数（流动性或可变债务）
uint256 amountScaled = amount.rayDiv(index);
这amountScaled是记录的标准化值。

更新用户状态：合约还会记录index特定用户（标识为onBehalfOf）发生此交易的当前时间。此存储索引至关重要，因为它标记了用户的最后一次交互点，从而可以准确计算自上次事件以来的余额利息。

// 用户状态更新的简化表示（视频中 0:44 左右）
// _userState 是存储用户特定数据的映射。
// additionalData（用户状态结构的一部分）存储最后的交互索引。
_userState[onBehalfOf].additionalData = index.toUint128();
铸造缩放代币：_mint最后，调用标准 ERC20函数，但会使用其amountScaled价值。这意味着用户的 A 代币或可变债务代币余额直接反映缩放后的标准化金额，而不是原始基础资产金额。

// 铸造缩放代币的简化表示（视频中大约 1:04）
_mint(onBehalfOf, amountScaled.toUint128());
功能_burnScaled：赎回资产和偿还债务
内部函数_burnScaled与 相对应_mintScaled。当 A 代币被销毁（例如，用户提取其提供的抵押品）或可变债务代币被销毁（例如，用户偿还其贷款）时，会调用该函数。

缩放金额：与铸币过程类似，amount提取或偿还的标的资产的实际金额将通过除以当前金额来缩小index。

// ScaledBalanceTokenBase.sol 内部 - _burnScaled 函数（概念表示）
// uint256 amount：标的资产的实际数量
// uint256 index：当前累计利率指数
uint256 amountScaled = amount.rayDiv(index);
更新用户状态：用户index在其状态内的最后一次交互也会更新为当前状态index。

// 用户状态更新的简化表示（视频中大约 1:07）
_userState[用户].additionalData = index.toUint128();
销毁缩放代币：_burn然后使用此函数调用标准 ERC20函数amountScaled，减少用户的缩放代币余额。

// 燃烧缩放代币的简化表示（视频中大约 1:35）
_burn（用户，amountScaled.toUint128（））；
解读效率：比例平衡的机制
缩放余额的核心机制为 DeFi 协议带来了显著的效率提升：

缩放余额存储： A 代币（代表用户供给）和可变债务代币（代表用户借入）都以这种“缩放”或“标准化”的形式存储余额。基本关系如下stored_scaled_balance = actual_underlying_amount / index_at_time_of_operation：

通过指数累积利息：随着时间的推移，相关指数index（供应的流动性指数，借入的可变债务指数）会自动增加，以反映应计利息。该指数是该资产整个池子利息的全局累加器。

计算当前实际余额：为了确定用户当前最新的基础资产余额（包括所有应计利息），协议可以按需计算：current_actual_balance = stored_scaled_balance * current_index。此计算通常在前端显示的视图函数中完成，或者在用户发起依赖于其当前精确余额的新交易时完成。

计算效率：该系统巧妙地避免了在利率变化或利息复利时迭代所有用户账户并单独更新每个账户余额的需要。只需index更新全局账户以反映利息的累积，从而使系统具有高度的可扩展性和 Gas 效率。

从理论到实践：Aave V3 在 DeFi 借贷中的扩展余额
Aave V3 协议的实现ScaledBalanceTokenBase.sol是对简单示例所展示的核心概念的稳健且高度精确的应用Bank.sol。在这两种情况下，处理用户交互（存款、借款、取款、还款）的过程都遵循一致的模式：

amount进行（基础资产的）实际交易。

这amount除以当前全球cumulativeRates（在Bank.sol示例中）或相关index（Aave V3 中的流动性或可变债务指数）。

然后使用所得的“缩放金额”来更新用户的存储余额，该余额本身就是一个缩放值。

这种比例余额会计方法是现代 DeFi 借贷协议的基石。它使 DeFi 协议能够高效地管理海量用户和交易，即使在利率动态变化和频繁复利的情况下，也能确保链上金融运营所必需的完整性和可扩展性。
