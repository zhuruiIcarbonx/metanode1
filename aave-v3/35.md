理解 Aave V3 借贷：深入探讨onBehalfOf和信用委托
Aave V3 是一个领先的去中心化借贷协议，它提供了复杂的资产借贷功能。启用信用委托等高级功能的关键参数之一是onBehalfOf。本课程将解构 Aave V3borrow交易，重点关注其onBehalfOf工作原理，并结合 Tenderly 交易调试器和 Aave V3 源代码的分析。

与 Tenderly 深度探讨交易
我们首先来研究一个示例交易，其中 DAI 借用自 Aave V3。Tenderly交易调试器是一个非常有用的工具，它提供了全面的概览，包括交易摘要、交互的合约、触发的事件、状态变化以及 gas 分析器。

在 Tenderly 的borrow函数调用的“输入和输出”部分中，我们发现以下参数：

asset：借入资产的合约地址。在我们的示例中，这是 DAI ( 0x6b175474e89094c44da98b954eedeac495271d0f)。

amount：借入资产的数量。例如，100000000000000000000代表 100 DAI，假设小数点后 18 位。

interestRateMode2：在此交易中设置为。

referralCode：设置为0。

onBehalfOf：在此特定交易中，此地址为0xd24cba...，也是发送者的地址（msg.sender）。这表明发送者正在为自己借款。

表示可变债务interestRateMode = 2利率模型。虽然之前的 Aave 版本提供了稳定的债务模型，但 Aave V3 主要支持新借款的可变债务。

该onBehalfOf参数是 Aave 信用委托功能的核心。它允许用户（msg.sender或“调用者”）发起借贷交易，将债务归属于另一个用户（onBehalfOf地址）。

用例：信用委托
想象一下爱丽丝想允许鲍勃用她的抵押品借款。

Alice（委托人）首先批准Bob（受委托人）代表她承担债务。

然后 Bob 调用该borrow函数。调用内容如下：

msg.sender将是鲍勃的地址。

onBehalfOf将被设置为 Alice 的地址。
结果是，债务义务被分配给 Alice，而 Bobmsg.sender收到实际借入的代币。

追踪onBehalfOf：源代码之旅
让我们onBehalfOf通过 Aave V3 源代码追踪该参数，以了解其流程和影响。初始borrow函数通常在代理合约（通常是）上调用，InitializableImmutableAdminUpgradeabilityProxy然后将调用委托给底层 AavePool合约实现。

Pool.sol-borrow入口点
borrow合约中的函数是Pool.sol借贷操作的主要入口点。

// 函数借用（
// 地址资产，
// uint256 金额，
// uint256 利率模式，
// uint16 转诊代码，
// address onBehalfOf // 债务人的地址
// ) 公共虚拟覆盖 {
// // ...
// 借贷逻辑.执行借贷（
// _reserves，
// _reservesList，
// _eMode类别，
// _usersConfig[onBehalfOf], // 'onBehalfOf' 地址的用户配置
// 数据类型.ExecuteBorrowParams({
// 资产：资产，
// user: msg.sender, // 函数的实际调用者
// onBehalfOf: onBehalfOf, // 将承担债务的地址
// 金额：金额，
// 利率模式：DataTypes.InterestRateMode(interestRateMode)，
//推荐代码：推荐代码，
// releaseUnderlying: true, // 对于典型的借贷，假设为真
// // ...
// })
// );
// }
主要观察结果：

从初始交易调用接收的参数onBehalfOf直接传递到DataTypes.ExecuteBorrowParams结构中。

在这个结构中，user明确设置为msg.sender（发起交易的实体，例如，我们的信用委托示例中的 Bob）。

onBehalfOf结构中的字段保留参数的值（onBehalfOf将产生债务的地址，例如 Alice）。

地址的用户配置onBehalfOf（_usersConfig[onBehalfOf]）也被传递给BorrowLogic.executeBorrow。

BorrowLogic.sol- 核心借用机制
该Pool合约将核心借阅逻辑委托给BorrowLogic.sol图书馆。图书馆的executeBorrow功能负责协调必要的状态更新和交互。

// 函数 executeBorrow(
// // ...
// DataTypes.UserConfigurationMap 存储用户配置，
// DataTypes.ExecuteBorrowParams 内存参数
// ） 外部的 {
// // ...（更新状态，验证借用）
//
// (bool isFirstBorrowing, ReserveCache.nextScaledVariableDebt) = IVariableDebtToken(
// reserveCache.variableDebtTokenAddress
// ).mint（params.user，params.onBehalfOf，params.amount，reserveCache.nextVariableBorrowIndex）；
//
// // ...（更新利率和虚拟余额）
//
// 如果（params.releaseUnderlying）{
// IAToken(reserveCache.aTokenAddress).transferUnderlyingTo(params.user，params.amount);
// }
// // ...
// }
在executeBorrow：

该IVariableDebtToken.mint函数在相关的可变债务代币合约上调用。注意参数：

第一个参数是params.user（即msg.sender，例如，鲍勃）。

第二个参数是params.onBehalfOf（将产生债务的地址，例如 Alice）。

如果params.releaseUnderlying为真（标准借款的典型情况），则借入的底层代币将通过 转移到params.user（msg.sender）IAToken(...).transferUnderlyingTo(params.user, params.amount)。这意味着 Bob 收到了 DAI。

VariableDebtToken.sol- 铸造债务
mint其中的函数（VariableDebtToken.sol实现IVariableDebtToken接口）处理债务代币的创建。

// 函数 mint(
// 地址用户，// 消息发送者（例如 Bob）
// address onBehalfOf, // 承担债务的地址（例如 Alice）
// uint256 金额，
// uint256 索引
// ) 外部虚拟覆盖 onlyPool 返回 (bool, uint256) {
// 如果 (用户 != onBehalfOf) {
// // 这是信用委托案例
// _decreaseBorrowAllowance(onBehalfOf, 用户, 金额);
// }
// 返回 _mintScaled(user, onBehalfOf, amount, index, scaledTotalSupply());
// }
这里：

参数user和onBehalfOf对应于params.user和。params.onBehalfOfBorrowLogic.executeBorrow

关键检查：if (user != onBehalfOf)。如果为真，则表示存在信用委托场景（例如，Bob 代表 Alice 借款）。在这种情况下，_decreaseBorrowAllowance将调用该函数。

随后，_mintScaled被称为，传递user、、onBehalfOf和amount。

DebtTokenBase.sol- 管理信贷委托限额
该_decreaseBorrowAllowance功能通常出现在诸如 之类的基础合约中DebtTokenBase.sol，是信用委托机制不可或缺的一部分。

// 函数 _decreaseBorrowAllowance(地址委托人，地址委托人，uint256 金额) 内部 {
// // 委托人是“onBehalfOf”（例如，Alice）
// // 委托人是“用户”（例如，Bob，msg.sender）
// uint256 newAllowance = _borrowAllowances[delegator][delegatee] - 金额;
// _borrowAllowances[委托人][受委托人] = newAllowance;
// // ...
// }
delegator该函数减少了（Alice，onBehalfOf地址）授予delegatee（Bob，user/ ）的预先批准的借款限额msg.sender。

ScaledBalanceTokenBase.sol- 归因债务
该_mintScaled函数通常是ScaledBalanceTokenBase.sol（处理缩放余额的代币合约基础，如债务代币）的一部分，负责实际铸造债务代币。

// 函数 _mintScaled(
// 地址呼叫者， // '用户'（例如，Bob，msg.sender）
// 地址 onBehalfOf, // 'onBehalfOf' （例如，Alice）
// uint256 金额，
// uint256 索引
// ) 内部返回 (bool) {
// // ...（计算 amountScaled）
//
// _mint(onBehalfOf, amountScaled.toUint128()); // 债务代币被铸造为“onBehalfOf”(Alice)
//
// // ...（更新“onBehalfOf”的用户状态）
// // ...（使用“caller”、“onBehalfOf”等发出 Mint 事件）
// return (scaledBalance == 0); // 如果这是该用户第一次铸币，则返回
// }
这里最关键的一行是。执行代币创建的_mint(onBehalfOf, amountScaled.toUint128())内部函数以接收者的身份被调用。这意味着债务代币会被铸造到地址 (Alice)，让她对债务负责。参数(Bob, ) 用于事件发送和其他潜在的逻辑，但债务本身与 相关联。_mintonBehalfOfonBehalfOfcallermsg.senderonBehalfOf

将代码连接到 Tenderly Call Trace
Tenderly 调用跟踪直观地表示了这一流程：

InitializableImmutableAdminUpgradeabilityProxy.borrow(...)：交易的初始调用命中代理合约。

PoolInstance.borrow(...)：代理将调用委托给Pool实现合约。

BorrowLogic.executeBorrow(...)：Pool合约调用库executeBorrow中的函数BorrowLogic。

内部调用executeBorrow包括：

BorrowLogic.cache(reserve = ...)：缓存内存中的保留数据，以优化后续读取的 gas。

BorrowLogic.updateState(...)：更新储备的流动性和借入指数。

BorrowLogic.validateBorrow(...)：进行检查以确保借款是允许的（例如，足够的抵押品，不超过借款上限）。

InitializableImmutableAdminUpgradeabilityProxy.mint(user = 0xd24cba..., onBehalfOf = 0xd24cba..., amount = ...)VariableDebtToken：这反映了对函数的调用mint。

user这里的参数来自params.user（BorrowLogic即msg.sender）。

参数onBehalfOf来自。params.onBehalfOf​BorrowLogic

在 Tenderly 的例子中，发送者为自己借款，user并且onBehalfOf是相同的。在信用委托场景中，user是受托人（Bob），onBehalfOf是委托人（Alice）。债务代币会被铸造到该onBehalfOf地址。

InitializableImmutableAdminUpgradeabilityProxy.transferUnderlyingTo(target = 0xd24cba..., amount = ...)AToken：这显示了对函数的调用transferUnderlyingTo。

参数target来自（即params.user）。BorrowLogicmsg.sender

这会将实际借入的基础资产（例如 DAI）转移到msg.sender。

BorrowLogic.updateInterestRatesAndVirtualBalance(...)：借入后最终状态更新。

Aave V3 关键概念的实际应用
此交易流程突出了几个重要的 Aave V3 架构模式和概念：

代理模式：Aave V3 的Pool合约使用可升级的代理（InitializableImmutableAdminUpgradeabilityProxy），允许在不更改主合约地址的情况下进行逻辑更新。实际的业务逻辑位于实现合约中（例如PoolInstance）。

库合约：BorrowLogic.sol库合约的典型示例。它封装了可重用的借用逻辑，促进了模块化，使主合约更加清晰，并有助于管理合约大小限制。

债务代币（VariableDebtToken）：这些是符合 ERC20 标准的代币，代表用户对特定资产的未偿债务。至关重要的是，它们会被铸造到特定onBehalfOf地址，表明该地址负责偿还债务。

AToken：这些是有利息的 ERC20 代币，代表用户在 Aave 中提供的流动性或抵押品。在借款过程中，AToken合约会将借入的标的资产转移给发起借款的一方msg.sender。user

信用委托：此强大功能由参数启用onBehalfOf。

它允许委托人（onBehalfOf地址，例如 Alice）授予另一个用户，即受委托人（地址msg.sender/ user，例如 Bob），以委托人的抵押品进行借款的权限。

委托人（onBehalfOf）累积债务（接收债务代币）。

受托人（msg.sender/ user）收到借入的标的资产。

此流程需要委托人事先批准受托人。Alice 通常会approveDelegation在特定的可变债务代币合约中调用类似函数，授予 Bob 一笔借贷额度。该_decreaseBorrowAllowance函数（参见VariableDebtToken.sol其基础代码）会在 Bob 的借贷交易中消耗这笔预先批准的额度。

Aave V3 借用：最佳实践和注意事项
Gas 优化：此BorrowLogic.cache步骤是一种常见的优化模式。在复杂函数开始时将必要的状态变量（例如储备数据）加载到内存中，可以避免多次昂贵的 SLOAD 操作，从而显著降低 Gas 成本。

Aave V3 债务模型：重要的是要记住，对于在 Aave V3 中发起的新借款，通常只有浮动利率模型可用。

信用委托示例：Alice 和 Bob
让我们明确一下信用委托流程：

Alice（委托人）拥有 Aave 的抵押品，并希望允许 Bob（被委托人）借入 100 DAI。

Alice 在可变债务 DAI 代币合约上调用该approveDelegation函数（或类似的批准函数），指定 Bob 的地址和限额（例如 100 DAI 或更多）。

Bob（代表）Pool.borrow()通过以下参数 调用来发起借贷：

asset：DAI 的地址。

amount：100 DAI（单位：wei）。

interestRateMode：2（多变的）。

referralCode:（0或推荐代码）。

onBehalfOf：爱丽丝的地址。

交易执行：

msg.sender交易上下文中将是 Bob 的地址。

Aave 协议验证了 Alice 对 Bob 的批准。

可变债务 DAI 代币（代表 100 DAI 债务）被铸造到Alice 的地址。

100 DAI（实际底层代币）被转移到Bob的地址。

Alice 之前授予 Bob 的借款限额减少了 100 DAI。

这项详细的分析阐明了 Aave V3 如何精心处理借贷操作，特别是如何利用onBehalfOf参数来实现诸如信用委托之类的复杂功能。这确保了债务的精准归属，同时为用户管理其 DeFi 交互提供了灵活性。
