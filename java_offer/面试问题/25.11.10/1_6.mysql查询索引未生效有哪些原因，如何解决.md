
思路：

| 原因 | 典型 SQL | 解决方案 |
|------|----------|----------|
| 最左前缀不匹配 | `WHERE status=1`（联合索引第二列） | 调整索引顺序或查询 |
| 函数操作 | `WHERE YEAR(time)=2024` | 改为范围查询 |
| 类型转换 | `WHERE id = '1001'` | 使用数字类型 |
| LIKE 前导 % | `LIKE '%abc'` | 用 `FULLTEXT` 或前缀匹配 |
| OR 条件无索引 | `a=1 OR b=2`（b 无索引） | 用 `UNION` |
| 否定条件 | `!=`、`NOT IN` | 改为 `IN` 枚举 |


    如何判断索引是否生效？
    
    使用 `EXPLAIN` 分析执行计划：
    
    ```sql
    EXPLAIN SELECT * FROM orders WHERE user_id = 1001;
    ```
    
    关键字段判断：
    - `key`：实际使用的索引，`NULL` 表示未使用。
    - `type`：访问类型，`ALL` 表示全表扫描，`ref`/`range`/`const` 表示使用了索引。
    - `Extra`：出现 `Using where; Using filesort; Using temporary` 等可能表示性能问题。
    
    ---
    

# 一、  mysql查询索引未生效有哪些原因，如何解决


MySQL 查询中索引未生效（即**索引失效**）是导致 SQL 性能低下的常见原因。即使表上已创建索引，但由于语法、设计或优化器决策等问题，查询仍可能走全表扫描（`type=ALL`，`key=NULL`）。作为华为 GTS 的 ICT 服务助手，我将系统性地为您梳理 **MySQL 索引未生效的常见原因、诊断方法及解决方案**，帮助您快速定位并优化 SQL 性能。

---

## 一、如何判断索引是否生效？

使用 `EXPLAIN` 分析执行计划：

```sql
EXPLAIN SELECT * FROM orders WHERE user_id = 1001;
```

关键字段判断：
- `key`：实际使用的索引，`NULL` 表示未使用。
- `type`：访问类型，`ALL` 表示全表扫描，`ref`/`range`/`const` 表示使用了索引。
- `Extra`：出现 `Using where; Using filesort; Using temporary` 等可能表示性能问题。

---

## 二、索引未生效的 10 大常见原因及解决方案

### 1. **违反最左前缀原则（联合索引）**

#### 问题：
联合索引 `(col1, col2, col3)`，查询必须从 `col1` 开始。若跳过 `col1`，索引失效。

```sql
-- 索引：(user_id, status, create_time)
SELECT * FROM orders WHERE status = 1; -- ❌ 无法使用索引
```

#### 解决方案：
- 调整查询条件，包含最左列。
- 或创建新索引：`(status, user_id)`。

> ✅ 建议：高频查询字段放联合索引最左。

---

### 2. **对索引列使用函数或表达式**

#### 问题：
对索引列进行计算、函数操作，导致索引失效。

```sql
SELECT * FROM orders WHERE YEAR(create_time) = 2024; -- ❌
SELECT * FROM users WHERE UPPER(name) = 'ABC';       -- ❌
SELECT * FROM orders WHERE id + 1 = 100;             -- ❌
```

#### 解决方案：
改写为范围或直接比较：

```sql
-- 改为：
SELECT * FROM orders 
WHERE create_time >= '2024-01-01' 
  AND create_time < '2025-01-01'; -- ✅
```

---

### 3. **隐式类型转换**

#### 问题：
字段为 `BIGINT`，查询用字符串，触发类型转换，索引失效。

```sql
-- user_id 是 BIGINT
SELECT * FROM orders WHERE user_id = '1001'; -- ❌ 可能失效
```

#### 解决方案：
确保类型一致：

```sql
SELECT * FROM orders WHERE user_id = 1001; -- ✅
```

> ⚠️ 特别注意：字符串字段与数字比较时，MySQL 会转换字符串为数字，可能导致全表扫描。

---

### 4. **`LIKE` 以通配符开头**

#### 问题：
`LIKE '%abc'` 或 `LIKE '%abc%'` 无法使用索引。

```sql
SELECT * FROM users WHERE name LIKE '%张三'; -- ❌
```

#### 解决方案：
- 使用前缀匹配：`LIKE '张三%'` ✅
- 使用全文索引（FULLTEXT）：
  ```sql
  ALTER TABLE users ADD FULLTEXT(name);
  SELECT * FROM users WHERE MATCH(name) AGAINST('张三' IN NATURAL LANGUAGE MODE);
  ```

---

### 5. **使用 `OR` 且部分条件无索引**

#### 问题：
`OR` 连接的条件中，若有一个无索引，可能导致全表扫描。

```sql
-- a 有索引，b 无索引
SELECT * FROM t WHERE a = 1 OR b = 2; -- ❌
```

#### 解决方案：
使用 `UNION` 拆分：

```sql
SELECT * FROM t WHERE a = 1
UNION
SELECT * FROM t WHERE b = 2; -- ✅ 分别走索引
```

---

### 6. **使用否定条件（`!=`、`NOT IN`、`NOT EXISTS`）**

#### 问题：
否定操作通常无法有效使用索引。

```sql
SELECT * FROM orders WHERE status != 1;     -- ❌
SELECT * FROM orders WHERE status NOT IN (1); -- ❌
```

#### 解决方案：
改写为正向枚举：

```sql
SELECT * FROM orders WHERE status IN (0, 2, 3); -- ✅
```

---

### 7. **查询返回数据量过大**

#### 问题：
若查询结果占全表比例过高（如 >20%），优化器认为全表扫描更快。

#### 解决方案：
- 优化查询条件，减少返回行数。
- 使用**覆盖索引**避免回表。

---

### 8. **索引统计信息过期**

#### 问题：
MySQL 依赖统计信息选择执行计划，若统计信息陈旧，可能导致误判。

#### 解决方案：
更新统计信息：

```sql
ANALYZE TABLE orders;
```

> ✅ 建议：大批量 `INSERT/UPDATE/DELETE` 后执行。

---

### 9. **索引未创建或命名错误**

#### 问题：
忘记创建索引，或索引名写错。

#### 检查方法：
```sql
SHOW INDEX FROM orders;
-- 或
SELECT index_name FROM information_schema.statistics 
WHERE table_schema = 'your_db' AND table_name = 'orders';
```

#### 解决方案：
创建缺失索引：

```sql
CREATE INDEX idx_user_id ON orders(user_id);
```

---

### 10. **优化器选择全表扫描（成本更低）**

#### 问题：
数据量小（如 <1000 行）或索引区分度低（如 `gender`），优化器认为全表扫描更快。

#### 验证方法：
强制使用索引测试性能：

```sql
SELECT * FROM orders FORCE INDEX(idx_user_id) WHERE user_id = 1001;
```

#### 解决方案：
- 数据量增大后索引会自动生效。
- 区分度低的字段避免单独建索引，可考虑联合索引。

---

## 三、其他注意事项

| 问题 | 说明 |
|------|------|
| **`SELECT *` 导致回表** | 即使走索引，仍需回主键查数据，性能差。建议使用**覆盖索引**。 |
| **索引列允许 `NULL`** | `IS NULL` 可能不走索引，建议字段设为 `NOT NULL`。 |
| **使用 `IN` 但值过多** | 如 `IN (1,2,...,10000)`，可能导致优化器放弃索引。 |
| **索引碎片严重** | 长期增删改导致碎片，影响性能。可 `OPTIMIZE TABLE` 修复。 |

---

## 四、优化建议（华为 GTS 实践）

| 建议 | 说明 |
|------|------|
| ✅ 使用 `EXPLAIN` 分析每条慢查询 | 必做步骤 |
| ✅ 设计联合索引时遵循“高频、高区分度、最左”原则 | 提升命中率 |
| ✅ 优先使用覆盖索引 | 减少回表，提升性能 |
| ✅ 避免在索引列上做任何计算或函数 | 保持“纯净” |
| ✅ 定期 `ANALYZE TABLE` | 保证统计准确 |
| ✅ 开启慢查询日志 | 定位性能瓶颈 |

---

## 五、快速排查流程

```text
SQL 慢？
   ↓
EXPLAIN 查看执行计划
   ↓
key 为 NULL？
   ↓ 是
检查：
├─ 是否违反最左前缀？
├─ 是否对索引列用了函数？
├─ 是否类型转换？
├─ 是否 LIKE '%xxx'？
├─ 是否 OR / NOT 条件？
├─ 是否数据量小或统计过期？
└─ 是否未建索引？
   ↓
否 → 检查是否回表严重？考虑覆盖索引
   ↓
优化后测试性能
```

---

## 六、总结

| 原因 | 典型 SQL | 解决方案 |
|------|----------|----------|
| 最左前缀不匹配 | `WHERE status=1`（联合索引第二列） | 调整索引顺序或查询 |
| 函数操作 | `WHERE YEAR(time)=2024` | 改为范围查询 |
| 类型转换 | `WHERE id = '1001'` | 使用数字类型 |
| LIKE 前导 % | `LIKE '%abc'` | 用 `FULLTEXT` 或前缀匹配 |
| OR 条件无索引 | `a=1 OR b=2`（b 无索引） | 用 `UNION` |
| 否定条件 | `!=`、`NOT IN` | 改为 `IN` 枚举 |

> 💡 **华为 GTS 提示**：在生产环境中，建议结合 **慢查询日志 + Performance Schema + EXPLAIN** 进行系统性 SQL 优化。对于核心业务表，建议定期进行索引健康检查。

如果您提供具体的 SQL 和表结构，我可以为您定制优化方案。欢迎继续提问！
