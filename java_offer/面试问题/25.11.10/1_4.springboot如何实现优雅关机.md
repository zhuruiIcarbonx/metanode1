# 一、 springboot如何实现优雅关机

在Spring Boot中实现优雅关机（Graceful Shutdown）可以确保应用在关闭时能够正确处理未完成的请求、释放资源并完成必要的清理工作。以下是几种常见的实现方式：

---

### **1. 使用Spring Boot内置的优雅关机（推荐）**
Spring Boot 2.3及以上版本内置了优雅关机支持，只需简单配置即可启用：
```properties
# application.properties
server.shutdown=graceful  # 启用优雅关机
spring.lifecycle.timeout-per-shutdown-phase=30s  # 设置等待超时时间（默认为30秒）
```
启用后：
1. 当接收到关机信号（如`kill -2`或`Ctrl+C`）时，Spring Boot会**停止接收新请求**。
2. 等待当前正在处理的请求完成（最长等待时间由`timeout-per-shutdown-phase`控制）。
3. 超时后强制关闭。

---

### **2. 自定义停机逻辑（通过`DisposableBean`或`@PreDestroy`）**
如果需要自定义清理逻辑（如关闭线程池、释放数据库连接等），可以通过以下方式实现：
```java
@Component
public class MyShutdownHook implements DisposableBean {
    @Override
    public void destroy() throws Exception {
        // 自定义清理逻辑（如关闭资源）
        System.out.println("执行优雅关机清理...");
    }
}
```
或使用`@PreDestroy`注解：
```java
@PreDestroy
public void onShutdown() {
    // 清理逻辑
}
```

---

### **3. 监听Spring上下文关闭事件**
通过监听`ContextClosedEvent`实现更灵活的控制：
```java
@Component
public class ShutdownEventListener {
    @EventListener
    public void handleContextClosed(ContextClosedEvent event) {
        // 在应用上下文关闭前执行逻辑
    }
}
```

---

### **4. 结合Actuator的`shutdown`端点（可选）**
如果需要通过HTTP触发优雅关机，可以启用Spring Boot Actuator：
```properties
# application.properties
management.endpoint.shutdown.enabled=true
management.endpoints.web.exposure.include=shutdown
```
发送POST请求到`/actuator/shutdown`即可触发关机（需确保端点权限安全！）。

---

### **5. 注意事项**
1. **外部请求代理**：如果应用部署在Nginx等反向代理后，需配置代理层的连接超时时间（如`proxy_read_timeout`）大于Spring Boot的优雅关机超时时间。
2. **长时间任务**：对于耗时任务（如批处理），建议在代码中检查`isShuttingDown()`状态，主动中断任务。
3. **信号处理**：确保使用`SIGTERM`（`kill -15`）触发关机，避免`SIGKILL`（`kill -9`）导致强制终止。

---

通过以上方法，Spring Boot应用可以实现安全、有序的关闭流程，避免数据丢失或服务中断问题。


# 一、springboot如何实现优雅关机

在 Spring Boot 应用中实现**优雅关机（Graceful Shutdown）**，是指在接收到关闭信号（如 `SIGTERM`）时，应用不会立即终止，而是：

- 停止接收新的请求；
- 等待正在处理的请求完成；
- 正确释放资源（如数据库连接、线程池、缓存等）；
- 最后再关闭应用上下文。

这对于生产环境中的微服务尤其重要，可以避免请求中断、数据不一致等问题。

---

### ✅ 实现方式（适用于 Spring Boot 2.3+）

Spring Boot 从 **2.3.0 版本开始**内置支持优雅关机功能，支持 Web 服务器（Tomcat、Jetty、Undertow）和响应式服务器（Netty）。

---

## 一、配置 `application.yml`

```yaml
server:
  shutdown: graceful
  tomcat:
    # 可选：设置最大等待时间
    shutdown: graceful

spring:
  lifecycle:
    timeout-per-shutdown-phase: 30s  # 最大等待时间，超过则强制关闭
```

> ⚠️ `timeout-per-shutdown-phase` 是全局控制，表示每个关闭阶段最多等待的时间（默认 30 秒）。

---

## 二、确保使用支持的 Web 服务器

目前支持优雅关机的服务器包括：

- Tomcat（9.0.33+）
- Jetty
- Undertow
- Netty（响应式应用）

如果你使用的是 Tomcat 9.0.33 以下版本，需升级。

---

## 三、发送关闭信号

### 方式1：通过 Actuator 端点（开发/测试可用）

启用 shutdown 端点（⚠️ 生产环境慎用）：

```yaml
management:
  endpoint:
    shutdown:
      enabled: true
  endpoints:
    web:
      exposure:
        include: shutdown
```

然后发送 POST 请求：

```bash
curl -X POST http://localhost:8080/actuator/shutdown
```

> ⚠️ 此方式默认无认证，生产环境不推荐开启。

---

### 方式2：发送 SIGTERM 信号（推荐，K8s/系统级）

在 Linux 或 Kubernetes 环境中，使用：

```bash
kill -15 <pid>
```

或在 K8s 中，Pod 被删除时会自动发送 `SIGTERM`，Spring Boot 会捕获并开始优雅关闭。

---

## 四、自定义关闭逻辑（可选）

你可以监听 `ContextClosedEvent` 或实现 `DisposableBean` 来执行清理逻辑：

```java
@Component
public class GracefulShutdownHandler {

    @EventListener
    public void onContextClosed(ContextClosedEvent event) {
        System.out.println("应用正在关闭，执行清理任务...");
        // 例如：关闭线程池、断开外部连接等
    }
}
```

或者注册一个 `SmartLifecycle`：

```java
@Component
public class CustomShutdownBean implements SmartLifecycle {

    private boolean isRunning = false;

    @Override
    public void stop(Runnable callback) {
        System.out.println("正在执行自定义关闭逻辑...");
        // 模拟清理耗时操作
        try {
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        System.out.println("自定义关闭逻辑完成。");
        callback.run(); // 必须调用，通知 Spring 继续关闭流程
    }

    // 其他方法略...
    @Override public void start() { isRunning = true; }
    @Override public void stop() { stop(() -> {}); }
    @Override public boolean isRunning() { return isRunning; }
    @Override public int getPhase() { return 0; }
    @Override public boolean isAutoStartup() { return true; }
}
```

---

## 五、Kubernetes 中的配合（重要）

在 K8s 中，建议配置：

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-springboot-app
spec:
  template:
    spec:
      containers:
      - name: app
        image: myapp:latest
        ports:
        - containerPort: 8080
        lifecycle:
          preStop:
            exec:
              command: ["/bin/sh", "-c", "sleep 20"]
        terminationGracePeriodSeconds: 40
```

说明：

- `preStop` 中 sleep 一段时间，确保 Spring Boot 有足够时间完成优雅关闭；
- `terminationGracePeriodSeconds` 要大于 `timeout-per-shutdown-phase`，建议设置为 30~60 秒。

---

## 六、验证是否生效

1. 启动应用，发送一个长时间处理的请求（如 `Thread.sleep(20000)`）；
2. 在请求执行中发送 `kill -15 <pid>`；
3. 观察日志：是否等待请求完成后再关闭。

日志中应看到类似：

```
INFO  o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat stopped in [xxx] ms (graceful)
```

---

### ✅ 总结

| 步骤 | 说明 |
|------|------|
| 1. 升级 Spring Boot ≥ 2.3 | 支持优雅关机 |
| 2. 配置 `server.shutdown=graceful` | 启用优雅关闭 |
| 3. 设置 `timeout-per-shutdown-phase` | 控制最大等待时间 |
| 4. 使用 `SIGTERM` 或 Actuator 关闭 | 触发关闭流程 |
| 5. K8s 配合 `preStop` 和 `terminationGracePeriodSeconds` | 确保有足够时间 |

---

如有使用 Dubbo、RabbitMQ、Kafka 等中间件，也需确保其客户端支持优雅关闭，避免消息丢失。

需要我提供一个完整示例项目结构吗？

