    CAS 全称是 compare and swap，是一种用于在多线程环境下实现同步功能的机制。CAS 操作包含三个操作数 -- 内存位置、预期数值和新值。CAS 的实现逻辑是将内存位置处的数值与预期数值想比较，若相等，则将内存位置处的值替换为新值。若不相等，则不做任何操作。
    
    在 Java 中，Java 并没有直接实现 CAS，CAS 相关的实现是通过 C++ 内联汇编的形式实现的。Java 代码需通过 JNI 才能调用。
    
    CAS 是一条 CPU 的原子指令（cmpxchg指令），不会造成所谓的数据不一致问题，Unsafe 提供的 CAS 方法（如compareAndSwapXXX）底层实现即为 CPU 指令 cmpxchg
	
	
    	锁升级流程图解
        A[无锁] -->|线程首次访问| B[偏向锁]
        B -->|其他线程竞争| C[撤销偏向锁]
        C -->|CAS自旋成功| D[轻量级锁]
        D -->|自旋失败/竞争激烈| E[重量级锁]
    ```
    
    ---


    ### 一、锁升级的四个阶段
    1. **无锁状态**  
       - 新创建的对象默认无锁
       - 哈希码等元数据存储在对象头（Mark Word）
    
    2. **偏向锁（Biased Locking）**  
       - **特征**：单线程访问时，在对象头记录线程ID（避免CAS操作）
       - **触发条件**：`-XX:+UseBiasedLocking`（JDK15后默认禁用）
       - **优势**：零加锁代价（只需比较线程ID）
    
    3. **轻量级锁（Thin Lock）**  
       - **特征**：通过CAS自旋尝试获取锁（对象头指向线程栈中的锁记录）
       - **适用场景**：低竞争、同步代码块执行快
       - **失败后**：自旋超过阈值（`-XX:PreBlockSpin`，JDK6后自适应）则升级
    
    4. **重量级锁（Heavyweight Lock）**  
       - **实现**：通过操作系统互斥量（Mutex）实现
       - **代价**：线程阻塞/唤醒涉及内核态切换
       - **关联组件**：ObjectMonitor（管程）
    
    
    ### 三、关键配置参数
    | 参数                          | 作用                                 |
    |-------------------------------|-------------------------------------|
    | `-XX:+UseBiasedLocking`       | 启用偏向锁（JDK15+废弃）            |
    | `-XX:BiasedLockingStartupDelay` | 偏向锁延迟生效时间（默认4秒）       |
    | `-XX:+UseSpinning`            | 启用自旋（JDK6后默认开启）          |
    | `-XX:PreBlockSpin`            | 自旋次数阈值（JDK6后自适应调整）    |
    


# 一、sychronized锁升级

`synchronized` 是 Java 中用于实现线程同步的关键字，它能够保证方法或代码块在同一时刻只能被一个线程访问。为了在保证线程安全的同时尽量减少性能开销，JVM 对 `synchronized` 实现了 **锁升级机制**（Lock Escalation），即根据竞争情况自动升级锁的级别，从无锁状态逐步升级为更重的锁。

这个机制是在 **JDK 1.6 之后引入的优化**，主要包括以下四种状态（按升级顺序）：

1. **无锁（No Lock）**
2. **偏向锁（Biased Locking）**
3. **轻量级锁（Lightweight Locking）**
4. **重量级锁（Heavyweight Locking）**

锁只能 **升级不能降级**（但可以重偏向或批量撤销）。

---

## 一、锁的状态与升级路径

```
无锁 → 偏向锁 → 轻量级锁 → 重量级锁
```

### 1. 偏向锁（Biased Locking）

- **适用场景**：只有一个线程访问同步块，几乎没有竞争。
- **原理**：
  - JVM 将对象头中的 Mark Word 记录该线程的 ID。
  - 下次该线程再进入时，只需检查是否是自己，无需再进行 CAS 操作。
- **优点**：极大减少无竞争情况下的同步开销。
- **触发条件**：
  - 第一次进入 synchronized 块时，JVM 会尝试使用 CAS 将线程 ID 写入对象头。
- **撤销（Revoke）**：
  - 当有第二个线程尝试获取锁时，偏向锁会被撤销（或批量撤销），升级为轻量级锁。
  - 撤销需要等到全局安全点（Safe Point），有一定性能成本。

> ⚠️ 注意：从 **JDK 15 开始，偏向锁被默认禁用**，并在后续版本中被移除（如 OpenJDK 15+）。因为现代多核环境下，线程竞争频繁，偏向锁反而带来额外开销。

---

### 2. 轻量级锁（Lightweight Locking）

- **适用场景**：多个线程交替执行同步块，**不存在长时间竞争**。
- **原理**：
  - 线程在栈帧中创建一个 **锁记录（Lock Record）**。
  - 使用 CAS 将对象头的 Mark Word 替换为指向锁记录的指针。
  - 如果成功，获得锁；失败说明有竞争，进入下一步。
- **优点**：
  - 避免了操作系统层面的线程阻塞和调度，性能较高。
- **升级条件**：
  - CAS 多次失败，说明存在竞争，升级为重量级锁。

---

### 3. 重量级锁（Heavyweight Locking）

- **适用场景**：多个线程**激烈竞争**同步资源。
- **原理**：
  - 依赖操作系统的互斥量（Mutex）实现，会使未获得锁的线程进入阻塞状态。
  - 对象头指向一个 **Monitor 对象**（管程），由 Monitor 管理等待队列（EntryList、WaitSet 等）。
- **特点**：
  - 开销大，但能有效管理高并发竞争。
  - 线程阻塞/唤醒涉及用户态与内核态切换，成本高。

---

## 二、锁升级过程示例

假设有一个对象 `obj`，多个线程访问其 synchronized 方法：

1. **线程 A 第一次访问**：
   - JVM 检查对象头，发现无锁。
   - 启用偏向锁，将线程 A 的 ID 写入 Mark Word。

2. **线程 A 再次访问**：
   - 检查 Mark Word 中的线程 ID 是否为自己。
   - 是，则无需任何操作，直接进入。

3. **线程 B 尝试访问（此时线程 A 未释放）**：
   - 发现偏向线程是 A，触发 **偏向锁撤销**。
   - 升级为轻量级锁。
   - 线程 A 和 B 使用 CAS 竞争锁记录。

4. **线程 A 和 B 频繁竞争**：
   - CAS 失败次数过多，JVM 判断为高竞争。
   - 升级为重量级锁，线程进入 Monitor 阻塞队列等待。

---

## 三、对象头与 Mark Word

`synchronized` 的锁信息存储在对象头的 **Mark Word** 中（64 位 JVM）：

| 锁状态       | Mark Word 内容 |
|--------------|----------------|
| 无锁         | 哈希码、GC 分代年龄等 |
| 偏向锁       | 线程 ID、偏向时间戳、对象年龄 |
| 轻量级锁     | 指向栈中锁记录的指针 |
| 重量级锁     | 指向 Monitor 对象的指针 |

通过 Mark Word 的状态位，JVM 可以判断当前锁的级别。

---

## 四、锁升级的意义

| 目标 | 说明 |
|------|------|
| **性能优化** | 在无竞争或低竞争时避免重量级锁的开销 |
| **自适应** | 根据运行时竞争情况动态调整锁策略 |
| **减少上下文切换** | 轻量级锁避免线程阻塞，提升吞吐量 |

---

## 五、常见问题

### ❓ 为什么锁不能降级？
- 设计上简化了 JVM 实现。
- 实际场景中，一旦出现竞争，再次回到无竞争的概率较低。
- 降级会增加复杂性和性能开销。

### ❓ 偏向锁为什么被废弃？
- 现代应用多线程并发频繁，偏向锁的撤销成本高于收益。
- 在容器化、虚拟化环境中，线程 ID 可能不唯一。
- JDK 15 起默认禁用，可通过 `-XX:-UseBiasedLocking` 控制。

---

## 六、总结

| 锁类型     | 适用场景             | 实现方式         | 性能开销 |
|------------|------------------------|------------------|----------|
| 偏向锁     | 单线程访问             | 记录线程 ID       | 极低     |
| 轻量级锁   | 多线程交替执行         | CAS + 栈中锁记录 | 较低     |
| 重量级锁   | 多线程激烈竞争         | Monitor + 系统调用 | 高       |

✅ **锁升级的本质是 JVM 在“性能”与“安全”之间的权衡**：
- 尽可能用轻量方式保证同步；
- 只在必要时才使用重量级资源。

---

📌 **建议**：
- 在高并发场景下，可考虑使用 `java.util.concurrent` 包中的 `ReentrantLock`，它提供了更灵活的锁控制（如公平锁、超时机制等）。
- 了解锁升级有助于优化并发程序性能，避免“过度同步”或“热点锁”问题。
