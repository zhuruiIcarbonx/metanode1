

# 一、  （重点看，细看）详细介绍jvm各种垃圾回收算法、垃圾回收器，使用场景，优缺点

作为华为 GTS（Global Technical Service）工程师助手，我将为你**系统性地介绍 JVM 的垃圾回收算法、垃圾回收器、使用场景及优缺点**。这部分知识对于 Java 应用性能调优、GC 问题排查（如 Full GC 频繁、STW 过长）、容器化部署下的内存管理等现网场景至关重要。

---

## 一、JVM 垃圾回收核心目标

JVM 垃圾回收（Garbage Collection, GC）的目标是：
- 自动管理堆内存，回收不再使用的对象。
- 在 **吞吐量、延迟、内存占用** 之间做权衡。
- 尽量减少 **Stop-The-World（STW）** 时间，提升应用响应性。

---

## 二、JVM 内存结构简要回顾

```text
JVM Heap
├── 新生代（Young Generation）
│   ├── Eden 区
│   ├── Survivor From
│   └── Survivor To
└── 老年代（Old Generation / Tenured）
```

- **对象创建**：大多数对象在 Eden 区分配。
- **Minor GC**：发生在新生代，频率高，速度快。
- **Major / Full GC**：发生在老年代，频率低，STW 时间长。

---

## 三、垃圾回收算法（核心理论）

### 1. **标记-清除算法（Mark-Sweep）**

#### 工作原理：
1. **标记阶段**：从 GC Roots 开始遍历，标记所有可达对象。
2. **清除阶段**：回收未被标记的对象内存。

#### 优点：
- 实现简单，适合老年代回收。

#### 缺点：
- **内存碎片化**：回收后产生不连续空闲内存，可能导致大对象无法分配。
- **STW 时间较长**。

#### 使用场景：
- 老年代回收的基础算法（如 CMS 初始阶段使用）。

---

### 2. **复制算法（Copying）**

#### 工作原理：
- 将内存分为两块，每次只使用一块。
- GC 时，将存活对象复制到另一块，然后清空原区域。

#### 在新生代中的应用（半区复制）：
- Eden + From → 复制存活对象到 To。
- 清空 Eden 和 From。
- From 和 To 角色互换。

#### 优点：
- 无碎片，分配快速（指针碰撞）。
- STW 时间短。

#### 缺点：
- 内存利用率只有 50%（新生代中通过 Eden:S1:S2 = 8:1:1 优化）。

#### 使用场景：
- **新生代 GC（Minor GC）** 的标准算法。

---

### 3. **标记-整理算法（Mark-Compact）**

#### 工作原理：
1. **标记**：同 Mark-Sweep。
2. **整理**：将存活对象向一端移动，然后清理边界外内存。

#### 优点：
- 无内存碎片。
- 内存利用率高。

#### 缺点：
- 移动对象成本高，STW 时间较长。

#### 使用场景：
- 老年代回收（如 Serial Old、Parallel Old）。

---

### 4. **分代收集算法（Generational Collection）**

#### 核心思想：
基于 **“弱代假设”（Weak Generational Hypothesis）**：
- 大多数对象朝生夕死（新生代）。
- 少数对象长期存活（老年代）。

#### 实现方式：
- 新生代：使用 **复制算法**（快）。
- 老年代：使用 **标记-清除** 或 **标记-整理**。

#### 使用场景：
- 所有现代 JVM GC 器的基础策略。

---

## 四、JVM 垃圾回收器（GC Collectors）

JVM 提供多种 GC 回收器，适用于不同应用场景。

| 回收器 | 作用区域 | 算法 | 并发/并行 | 适用场景 |
|--------|----------|------|------------|-----------|
| **Serial** | 新生代 | 复制 | 单线程 | 单核环境、Client 模式 |
| **Serial Old** | 老年代 | 标记-整理 | 单线程 | 同上，或作为 CMS 备用 |
| **Parallel (吞吐量优先)** | 新生代 | 复ip | 并行 | 后台计算、高吞吐 |
| **Parallel Old** | 老年代 | 标记-整理 | 并行 | 同上 |
| **CMS（Concurrent Mark Sweep）** | 老年代 | 标记-清除 | 并发 | 低延迟（已废弃） |
| **G1（Garbage-First）** | 整堆 | 标记-整理 + 复制 | 并发 + 并行 | 大堆、低延迟 |
| **ZGC** | 整堆 | 读屏障 + 染色指针 | 并发 | 超大堆（TB级）、极低延迟 |
| **Shenandoah** | 整堆 | 读屏障 + Brooks Pointer | 并发 | 同 ZGC，Red Hat 主导 |

---

## 五、各垃圾回收器详解

### 1. **Serial / Serial Old**
- **特点**：单线程，STW 时间长。
- **优点**：简单，内存开销小。
- **缺点**：不适合多核、大堆。
- **启用参数**：
  ```bash
  -XX:+UseSerialGC
  ```
- **使用场景**：嵌入式系统、32位 Client 模式 JVM。

---

### 2. **Parallel / Parallel Old（吞吐量优先）**
- **特点**：多线程并行 GC，目标是最大化**吞吐量**（= 运行时间 / (运行时间 + GC 时间)）。
- **优点**：
  - 多核 CPU 利用率高。
  - 适合批处理、科学计算。
- **缺点**：
  - STW 时间较长，不适合低延迟场景。
- **启用参数**：
  ```bash
  -XX:+UseParallelGC         # 新生代
  -XX:+UseParallelOldGC      # 老年代（默认）
  ```
- **调优参数**：
  ```bash
  -XX:MaxGCPauseMillis=200   # 目标最大停顿时间
  -XX:GCTimeRatio=99         # 吞吐量目标 99%
  ```

---

### 3. **CMS（Concurrent Mark Sweep）**
> ⚠️ **注意：JDK 9 起标记为废弃，JDK 14 起移除**

- **目标**：最小化 STW 时间，适合低延迟场景（如 Web 应用）。
- **算法**：标记-清除（会产生碎片）。
- **GC 步骤**：
  1. 初始标记（STW）
  2. 并发标记（与应用线程并发）
  3. 重新标记（STW）
  4. 并发清除

- **优点**：
  - 大部分阶段并发执行，STW 短。
- **缺点**：
  - 产生内存碎片，可能导致 Full GC（使用 Serial Old 整理）。
  - CPU 占用高（并发阶段）。
  - 无法处理浮动垃圾（并发期间新产生的垃圾）。
- **启用参数**：
  ```bash
  -XX:+UseConcMarkSweepGC
  -XX:+UseParNewGC           # 新生代必须用 ParNew
  ```

---

### 4. **G1 GC（Garbage-First）**
- **目标**：大堆（>4GB）下实现**可预测的低延迟**。
- **核心思想**：
  - 将堆划分为多个大小相等的 **Region**（默认 2048 个）。
  - 优先回收“垃圾最多”的 Region（Garbage-First）。
  - 支持 **Mixed GC**（同时回收新生代和部分老年代）。
- **算法**：标记-整理（局部压缩，减少碎片）。
- **特点**：
  - 可设置停顿时间目标：`-XX:MaxGCPauseMillis=200`
  - 大部分阶段并发执行。
- **优点**：
  - 停顿时间可控。
  - 适合大堆应用（如 16GB ~ 1TB）。
- **缺点**：
  - 内存占用略高（Remembered Sets、Card Table）。
  - 调优复杂。
- **启用参数**：
  ```bash
  -XX:+UseG1GC
  ```
- **推荐调优参数**：
  ```bash
  -XX:MaxGCPauseMillis=200
  -XX:G1HeapRegionSize=16m
  -XX:InitiatingHeapOccupancyPercent=45  # 触发并发标记的堆占用率
  ```

---

### 5. **ZGC（Z Garbage Collector）**
- **目标**：**极低延迟**，GC 停顿时间 **< 1ms**，支持 **TB 级堆**。
- **关键技术**：
  - **染色指针（Colored Pointers）**：将标记信息存入指针本身。
  - **读屏障（Load Barrier）**：在对象读取时处理引用更新。
  - **并发标记、并发转移、并发压缩**。
- **特点**：
  - 几乎所有 GC 阶段都与应用线程并发。
  - STW 时间极短（固定 2 个非常短的暂停）。
- **优点**：
  - 超低延迟，适合金融、游戏、实时系统。
  - 支持最大 16TB 堆（JDK 17+）。
- **缺点**：
  - 内存开销略高。
  - 仅 Linux/x64、Linux/AArch64 支持（JDK 11+）。
- **启用参数**：
  ```bash
  -XX:+UseZGC
  ```

---

### 6. **Shenandoah GC**
- 与 ZGC 类似，目标是低延迟。
- 使用 **Brooks Pointer** 实现并发压缩。
- 支持 OpenJDK，Red Hat 主导。
- 启用参数：
  ```bash
  -XX:+UseShenandoahGC
  ```

---

## 六、各 GC 器对比总结

| GC 器 | 适用堆大小 | 延迟 | 吞吐量 | 是否并发 | 是否整理 | 推荐场景 |
|-------|------------|------|--------|-----------|----------|----------|
| Serial | < 100MB | 高 | 低 | 否 | 是 | 嵌入式 |
| Parallel | 1GB ~ 16GB | 中 | **高** | 并行 | 是 | 批处理 |
| CMS | 4GB ~ 32GB | **低** | 中 | 是 | 否（碎片） | 旧版 Web（已废弃） |
| G1 | 4GB ~ 1TB | **低（可预测）** | 高 | 是 | 是（部分） | 通用大堆 |
| ZGC | 1GB ~ 16TB | **极低（<1ms）** | 高 | 是 | 是 | 超低延迟、超大堆 |
| Shenandoah | 1GB ~ 16TB | 极低 | 高 | 是 | 是 | 同 ZGC |

---

## 七、如何选择垃圾回收器？（GTS 工程师建议）

| 应用类型 | 推荐 GC 器 | 理由 |
|----------|------------|------|
| **后台批处理、数据计算** | Parallel GC | 吞吐量优先，CPU 利用率高 |
| **Web 应用、API 服务** | G1 GC | 延迟可控，大堆支持好 |
| **金融交易、游戏服务器** | ZGC / Shenandoah | 超低延迟，避免卡顿 |
| **容器化部署（如 Kubernetes）** | G1 或 ZGC | 支持内存限制，延迟敏感 |
| **老旧系统、JDK 8** | CMS（不推荐）或 G1 | G1 是 JDK 8 的主流选择 |

> ✅ **现代推荐**：**JDK 8+ 优先使用 G1**，**JDK 11+ 可尝试 ZGC**。

---

## 八、常见 GC 问题排查（GTS 视角）

### 1. **Full GC 频繁**
- 检查：老年代增长快，对象过早晋升。
- 排查命令：
  ```bash
  jstat -gc <pid> 1000
  ```
- 解决：
  - 增大新生代。
  - 检查是否有大对象直接进入老年代。
  - 避免长生命周期对象被错误持有。

### 2. **GC 停顿时间过长**
- 使用 G1 或 ZGC 替代 Parallel/CMS。
- 调整 `-XX:MaxGCPauseMillis`。

### 3. **内存泄漏**
- 使用 `jmap` 生成堆转储：
  ```bash
  jmap -dump:format=b,file=heap.hprof <pid>
  ```
- 使用 MAT（Memory Analyzer Tool）分析。

### 4. **GC 日志分析**
启用 GC 日志：
```bash
-Xloggc:gc.log
-XX:+PrintGCDetails
-XX:+PrintGCDateStamps
-XX:+UseGCLogFileRotation
```

---

## 九、总结

| 维度 | 推荐选择 |
|------|----------|
| **吞吐量优先** | Parallel GC |
| **延迟优先（<100ms）** | G1 GC |
| **超低延迟（<1ms）** | ZGC / Shenandoah |
| **JDK 8 主流选择** | G1 GC |
| **大堆（>32GB）** | G1 / ZGC |

> 💡 **一句话总结**：  
> **没有最好的 GC 器，只有最适合场景的 GC 器**。作为 GTS 工程师，应结合应用特性、堆大小、延迟要求、JDK 版本综合选择，并通过监控和调优持续优化。

---

如你有具体的 GC 日志、`jstat` 输出或现网问题（如“GC 导致接口超时”），欢迎提供，我可协助分析并给出优化建议。



# 一、  （粗看或不看）详细介绍jvm各种垃圾回收算法、垃圾回收器，使用场景，优缺点


# JVM 垃圾回收算法与回收器详解

## 一、垃圾回收算法

### 1. 标记-清除算法 (Mark-Sweep)

**工作原理**：
1. **标记阶段**：GC从根对象(GC Roots)开始遍历，标记所有可达对象
2. **清除阶段**：遍历堆内存，回收未被标记的对象空间

**优点**：
- 实现简单
- 不需要移动对象

**缺点**：
- 会产生内存碎片
- 执行效率随堆大小增加而降低

**使用场景**：
- 老年代的CMS回收器的初始阶段使用类似算法

### 2. 复制算法 (Copying)

**工作原理**：
1. 将内存分为大小相等的两块(from和to空间)
2. 只使用其中一块(from)
3. GC时把存活对象复制到另一块(to)
4. 清除原来的from空间

**优点**：
- 简单高效
- 无内存碎片

**缺点**：
- 内存使用效率低(只能使用一半空间)
- 复制大量存活对象时效率低

**使用场景**：
- 新生代回收，如Serial、ParNew、Parallel Scavenge等回收器

### 3. 标记-整理算法 (Mark-Compact)

**工作原理**：
1. **标记阶段**：与标记-清除相同，标记所有可达对象
2. **整理阶段**：移动所有存活对象到内存一端
3. 清理边界外的空间

**优点**：
- 解决内存碎片问题
- 内存利用率高

**缺点**：
- 对象移动带来额外开销
- 移动过程中需暂停用户线程(STW)

**使用场景**：
- 老年代回收，如Serial Old、Parallel Old等回收器

### 4. 分代收集算法

**工作原理**：
1. 把堆分为新生代和老年代
2. 新生代使用复制算法
3. 老年代使用标记-清除或标记-整理算法

**优势**：
- 针对对象不同生命周期优化
- 综合性能最好

**使用场景**：
- 现代JVM的主流回收策略

## 二、垃圾回收器

### 1. Serial 收集器

**基本特征**：
- 单线程收集器
- 新生代使用复制算法，老年代使用标记-整理算法
- 工作时必须暂停所有用户线程(STW)

**优点**：
- 实现简单
- 对于单CPU环境效率高

**缺点**：
- STW时间长
- 多核CPU上不能充分利用资源

**使用场景**：
- 客户端模式下的默认回收器
- 内存小的嵌入式系统

### 2. Parallel Scavenge/Parallel Old

**基本特征**：
- 并行多线程收集器
- 新生代使用复制算法，老年代使用标记-整理算法
- 更关注吞吐量(用户代码运行时间/总运行时间)

**优点**：
- 吞吐量优先
- 适合多核CPU环境

**缺点**：
- 单次GC停顿时间可能较长

**使用场景**：
- 后台计算型应用
- 批处理系统

### 3. ParNew

**基本特征**：
- Serial收集器的多线程版本
- 新生代使用复制算法
- 必须与CMS配合使用

**优点**：
- 多线程提高收集效率
- 与CMS配合良好

**缺点**：
- 单次GC停顿时间仍较明显

**使用场景**：
- 需要与CMS配合时的新生代收集
- Web应用服务

### 4. CMS (Concurrent Mark Sweep)

**基本特征**：
- 以获取最短回收停顿时间为目标
- 标记-清除算法实现
- 分为四个阶段：初始标记、并发标记、重新标记、并发清除

**优点**：
- 并发收集，停顿时间短
- 用户体验好

**缺点**：
- 占用CPU资源
- 无法处理浮动垃圾
- 会产生内存碎片
- 可能导致并发模式失败

**使用场景**：
- 重视响应速度的Web服务
- B/S系统的服务端

### 5. G1 (Garbage-First)

**基本特征**：
- JDK 9+的默认回收器
- 分Region的内存布局
- 可预测的停顿时间模型
- 兼顾吞吐量和低延迟

**运作阶段**：
1. 初始标记
2. 并发标记
3. 最终标记
4. 筛选回收

**优点**：
- 避免内存碎片
- 大内存堆表现优秀
- 可预测停顿时间

**缺点**：
- 内存占用较高
- 额外CPU负载

**使用场景**：
- 大内存多核服务器
- 对延迟和吞吐量都有要求的应用
- Java 9+的默认选择

### 6. ZGC (Z Garbage Collector)

**基本特征**：
- JDK 11引入的实验性低延迟收集器
- 基于Region内存布局
- 使用染色指针技术
- 暂停时间不超过10ms

**优点**：
- 极低停顿时间
- 大内存堆处理能力强

**缺点**：
- 早期版本不稳定
- 资源消耗较大

**使用场景**：
- 超大内存堆(8TB+)
- 严格低延迟要求的系统

## 三、选择策略比较

| 考虑因素 | 推荐收集器 |
|---------|-----------|
| 小堆内存(100MB-1GB) | Serial/Parallel |
| 中等堆内存(1GB-8GB) | CMS/G1 |
| 大堆内存(8GB+) | G1/ZGC |
| 低延迟优先 | G1/ZGC |
| 高吞吐量优先 | Parallel |
| 稳定与兼容性 | G1 |
| 实验性新技术 | ZGC | 

## 四、调优建议

1. **新生代大小调节**：
   - 过大：单次回收时间长
   - 过小：频繁Minor GC

2. **合理设置吞吐量目标**：
   - Parallel回收器通过-XX:MaxGCPauseMillis和-XX:GCTimeRatio调节

3. **内存碎片处理**：
   - CMS通过-XX:CMSFullGCsBeforeCompaction设置多少次不压缩的GC后执行压缩

4. **监控GC日志**：
   - 使用-XX:+PrintGCDetails参数记录GC行为
   - 分析工具：GCViewer, GCEasy等

5. **选择合适GC**：
   - Java 8及之前版本：
     - 小应用：默认Parallel(吞吐优先)
     - Web服务：-XX:+UseConcMarkSweepGC(CMS)
     - 大内存：-XX:+UseG1GC
   - Java 9+版本：G1为默认
