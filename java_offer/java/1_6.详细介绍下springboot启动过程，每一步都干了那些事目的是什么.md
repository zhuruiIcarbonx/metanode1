
    springboot启动过程 都是围绕着 application_*展开的，重点是applicationcontext
    两大步骤：
	  1、 new 一个 springapplication    (ApplicationContextInitializer 提前进行)
	  2、 调用 springapplication.run()
	  
	  
	  详细步骤：
	  
	  1、 new 一个 springapplication    (ApplicationContextInitializer 提前进行)
	  
	  1.1 加载ApplicationContextInitializer 
	  *   **做了什么**：使用 Spring 的 `SpringFactoriesLoader` 机制，从 `META-INF/spring.factories` 文件和所有 	  
	  Jar 包中，加载所有配置的 `ApplicationContextInitializer`。
	  *   **目的**：这些初始化器允许我们在 ApplicationContext 被 **刷新（Refresh）** 之前，对其做一些初始化和
	  配置。例如，设置环境变量、注册自定义 Bean 等。这是框架扩展的一个关键点。
	  1.2  加载 ApplicationListener
	    **做了什么**：同样通过 `SpringFactoriesLoader` 加载所有配置的 `ApplicationListener`。
	  *   **目的**：这些监听器用于监听 Spring 应用在后面启动过程中发布的各类事件（如 `ApplicationStartedEvent`, 
	  `ApplicationFailedEvent` 等），实现事件驱动的编程模型。
	 
	 
	  2、 调用 springapplication.run()
	  
	  2.1 发布applicatonStartEvent事件
	  2.2 准备合读取 环境配置文件 
	  2.3 aplicationContext--[ 创建 ]
	  2.4 aplicationContext--[ 准备 ] 加载2.2环境配置
	  2.5 aplicationContext--[ .refesh() ]
	  2.6 aplicationContext--[ 发布readyEvent ]
	  2.7 aplicationRunner.run()、commandRunner.run()


      


好的，这是一个非常核心的面试题和技术点。Spring Boot 的启动过程精妙地封装了传统 Spring 应用的复杂性。下面我将详细分解这个过程，并解释每一步的目的。

### 核心概览

Spring Boot 的启动入口通常是 `SpringApplication.run(ApplicationClass, args)` 方法。整个过程可以概括为：
1.  **初始化阶段**：创建 `SpringApplication` 实例，准备初始环境。
2.  **运行阶段**：执行 `run` 方法，一步步启动容器，加载 Bean，运行内置服务器。

---

### 详细启动步骤分解

我们以一个标准的启动类为例：
```java
@SpringBootApplication
public class MyApplication {
    public static void main(String[] args) {
        SpringApplication.run(MyApplication.class, args);
    }
}
```

#### 第一阶段：实例化 `SpringApplication` (`new SpringApplication(...)`)

当调用 `SpringApplication.run(...)` 时，首先会创建一个 `SpringApplication` 的实例。

**步骤 1：推断应用类型**
*   **做了什么**：检查当前应用的类路径下是否存在特定的类，来判断应用类型。
    *   存在 `org.springframework.web.reactive.DispatcherHandler` -> `REACTIVE` (WebFlux)
    *   不存在 Reactive 相关类，但存在 `javax.servlet.Servlet` -> `SERVLET` (传统的 Spring MVC)
    *   都不存在 -> `NONE` (非 Web 应用，如控制台程序)
*   **目的**：根据不同类型，后续会创建不同的 ApplicationContext（如 `AnnotationConfigServletWebServerApplicationContext` 或 `AnnotationConfigReactiveWebServerApplicationContext`），并决定是否启动 Web 服务器。

**步骤 2：加载 `ApplicationContextInitializer`**
*   **做了什么**：使用 Spring 的 `SpringFactoriesLoader` 机制，从 `META-INF/spring.factories` 文件和所有 Jar 包中，加载所有配置的 `ApplicationContextInitializer`。
*   **目的**：这些初始化器允许我们在 ApplicationContext 被 **刷新（Refresh）** 之前，对其做一些初始化和配置。例如，设置环境变量、注册自定义 Bean 等。这是框架扩展的一个关键点。

**步骤 3：加载 `ApplicationListener`**
*   **做了什么**：同样通过 `SpringFactoriesLoader` 加载所有配置的 `ApplicationListener`。
*   **目的**：这些监听器用于监听 Spring 应用在启动过程中发布的各类事件（如 `ApplicationStartedEvent`, `ApplicationFailedEvent` 等），实现事件驱动的编程模型。

**步骤 4：推断主配置类**
*   **做了什么**：遍历 `main` 方法的调用栈，找到包含 `main` 方法的那个类（即我们的 `MyApplication.class`）。
*   **目的**：将这个类作为主要的配置源（Source），后续会将其注册到 Bean 定义中。

#### 第二阶段：执行 `run` 方法

这是启动过程的核心。

**步骤 5：创建并启动计时器**
*   **做了什么**：启动一个 `StopWatch`。
*   **目的**：用于统计整个 Spring Boot 应用的启动时间，并在日志中输出。

**步骤 6：配置 Headless 模式**
*   **做了什么**：如果系统没有设置 `java.awt.headless` 属性，则默认设置为 `true`。
*   **目的**：确保在服务器环境（没有显示设备、键盘、鼠标）中也能正常运行，即使应用用到了 AWT（例如用于图片处理）。

**步骤 7：发布 `ApplicationStartingEvent` 事件**
*   **做了什么**：发布应用启动开始的事件。
*   **目的**：通知所有之前加载的 `ApplicationListener`，应用开始启动了。此时 `ApplicationContext` 还未创建。

**步骤 8：准备环境 (`Environment`)**
*   **做了什么**：
    1.  创建并配置应用环境（Environment），它包含了 Profiles（如 `dev`, `prod`）和 Properties（配置属性）。
    2.  根据应用类型（SERVLET/REACTIVE）配置相应的环境。
    3.  **处理所有配置源**：包括命令行参数 (`--server.port=8081`)、JNDI、系统属性、操作系统环境变量，以及应用的配置文件（`application.properties`/`application.yml`）。这里会完成配置文件的加载和解析。
*   **目的**：为应用的运行准备好所有的配置信息，这些信息将用于后续创建 ApplicationContext 和 Bean。

**步骤 9：创建 `ApplicationContext`**
*   **做了什么**：根据第一步推断出的应用类型，通过反射实例化对应的 `ApplicationContext` 类。
    *   Servlet Web 应用：`AnnotationConfigServletWebServerApplicationContext`
    *   Reactive Web 应用：`AnnotationConfigReactiveWebServerApplicationContext`
    *   非 Web 应用：`AnnotationConfigApplicationContext`
*   **目的**：创建 Spring 的 IoC 容器，这是所有 Bean 的家。

**步骤 10：准备 `ApplicationContext`**
*   **做了什么**：
    1.  将步骤 8 准备好的 `Environment` 设置给 `ApplicationContext`。
    2.  进行 Bean 定义注册的后置处理（例如，对主配置类 `MyApplication` 进行解析）。
    3.  **调用所有 `ApplicationContextInitializer` 的 `initialize` 方法**。
    4.  发布 `ApplicationContextInitializedEvent` 事件。
*   **目的**：在容器刷新前，对容器进行最后的定制和扩展。

**步骤 11：刷新 `ApplicationContext` - 最核心的一步**
*   **做了什么**：调用 `ApplicationContext` 的 `refresh()` 方法。这是 Spring 框架的核心，它完成了 IoC 容器的启动。这个过程非常复杂，主要包括：
    1.  **`prepareRefresh()`**： 设置容器的启动日期、激活标志，初始化属性源等。
    2.  **`obtainFreshBeanFactory()`**： 获取或刷新内部的 `BeanFactory`。
    3.  **`prepareBeanFactory(beanFactory)`**： 配置 `BeanFactory` 的标准上下文特性，如 `ClassLoader`、`BeanPostProcessor` 等。
    4.  **`postProcessBeanFactory(beanFactory)`**： 空方法，留给子类扩展。
    5.  **`invokeBeanFactoryPostProcessors(beanFactory)`**： **关键！** 实例化并调用所有 `BeanFactoryPostProcessor`。这里会：
        *   解析 `@Configuration`, `@Component`, `@Service`, `@Repository` 等注解，扫描并注册 Bean 定义。
        *   **处理 `@SpringBootApplication` 注解**：其背后的 `@EnableAutoConfiguration` 会触发 **自动配置** 机制。通过 `SpringFactoriesLoader` 加载 `META-INF/spring.factories` 中的 `EnableAutoConfiguration` 配置，根据条件（如类路径、已有 Bean、配置属性）决定哪些配置类生效，并将其 Bean 定义注册到容器中。
    6.  **`registerBeanPostProcessors(beanFactory)`**： 实例化并注册所有 `BeanPostProcessor`，为后续 Bean 的实例化做准备。
    7.  **`initMessageSource()`**： 初始化国际化相关组件。
    8.  **`initApplicationEventMulticaster()`**： 初始化事件广播器。
    9.  **`onRefresh()`**： **关键！** 模板方法，留给子类实现。对于 Web 应用，这里会：
        *   **创建内嵌的 Web 服务器**（如 Tomcat, Jetty, Undertow）。
    10. **`registerListeners()`**： 注册监听器，将其加入到事件广播器中。
    11. **`finishBeanFactoryInitialization(beanFactory)`**： **关键！** 初始化所有剩余的非懒加载单例 Bean。这里会完成所有 Bean 的实例化、依赖注入（DI）和初始化（调用 `@PostConstruct` 方法等）。
    12. **`finishRefresh()`**： 完成容器的刷新过程。发布 `ContextRefreshedEvent` 事件。同时，如果创建了 Web 服务器，会在这里完成服务器的启动，使其开始监听指定端口。
*   **目的**：启动整个 Spring IoC 容器，完成从配置到 Bean 实例的完整生命周期管理。

**步骤 12：发布 `ApplicationReadyEvent` 或 `ApplicationFailedEvent`**
*   **做了什么**：
    *   如果启动成功，发布 `ApplicationReadyEvent`。
    *   如果启动过程中发生异常，发布 `ApplicationFailedEvent`。
*   **目的**：通知监听器应用已经**完全准备就绪**，可以开始处理请求了（与 `ApplicationStartedEvent` 的区别在于，后者在容器刷新后立即发布，但此时 Bean 可能还未完全初始化完毕）。

**步骤 13：调用 `CommandLineRunner` 和 `ApplicationRunner`**
*   **做了什么**：从容器中获取所有 `CommandLineRunner` 和 `ApplicationRunner` 类型的 Bean，并调用它们的 `run` 方法。
*   **目的**：提供一种在应用启动后、开始正常服务前，执行一些特定代码（如数据初始化、缓存预热）的便捷方式。

### 总结与目的

Spring Boot 启动过程的每一步都旨在：

1.  **简化配置**：通过条件化自动配置，免去了大量繁琐的 XML 或 Java Config。
2.  **提供扩展点**：通过 `Initializer`, `Listener`, `Runner` 等接口，让开发者可以在生命周期的特定阶段插入自定义逻辑。
3.  **统一管理**：将环境配置、容器创建、Bean 生命周期、服务器启动等步骤串联成一个流畅的、可预测的流程。
4.  **面向约定**：默认提供了大量合理的默认值（如内嵌服务器、默认端口），遵循“约定大于配置”的原则。

整个过程将传统的、需要手动搭建的 Spring 应用，转变为一个“开箱即用”的、自包含的、可直接运行的独立应用。
