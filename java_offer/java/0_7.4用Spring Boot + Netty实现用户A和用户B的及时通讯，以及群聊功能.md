# 一、用Spring Boot + Netty实现用户A和用户B的及时通讯，以及群聊功能

# Spring Boot + Netty 实现私聊与群聊功能

## 1. 项目架构设计

### 1.1 通信协议设计
使用自定义协议格式：
```java
public class ChatMessage {
    private Long sender;     // 发送者ID
    private Long receiver;   // 接收者ID(私聊)或群ID(群聊)
    private String content;  // 消息内容
    private Integer type;    // 消息类型: 1-私聊 2-群聊
    // getters and setters
}
```

### 1.2 核心组件
- **NettyServer**: 负责启动和维护Socket连接
- **MessageHandler**: 处理不同类型的消息
- **UserManager**: 管理用户连接状态
- **GroupManager**: 管理群组信息

## 2. 核心代码实现

### 2.1 Netty 服务端启动类

```java
@Component
public class NettyServer {
    private static final int PORT = 8081;
    
    @Autowired
    private MessageHandler messageHandler;
    
    public void start() {
        EventLoopGroup bossGroup = new NioEventLoopGroup();
        EventLoopGroup workerGroup = new NioEventLoopGroup();
        
        try {
            ServerBootstrap bootstrap = new ServerBootstrap();
            bootstrap.group(bossGroup, workerGroup)
                .channel(NioServerSocketChannel.class)
                .childHandler(new ChannelInitializer<SocketChannel>() {
                    @Override
                    protected void initChannel(SocketChannel ch) {
                        ChannelPipeline pipeline = ch.pipeline();
                        // 处理TCP粘包/拆包
                        pipeline.addLast(new LengthFieldBasedFrameDecoder(1024, 0, 4, 0, 4));
                        pipeline.addLast(new LengthFieldPrepender(4));
                        // JSON编解码
                        pipeline.addLast(new ObjectDecoder(ClassResolvers.cacheDisabled(null)));
                        pipeline.addLast(new ObjectEncoder());
                        // 自定义处理器
                        pipeline.addLast(messageHandler);
                    }
                })
                .option(ChannelOption.SO_BACKLOG, 128)
                .childOption(ChannelOption.SO_KEEPALIVE, true);
            
            ChannelFuture future = bootstrap.bind(PORT).sync();
            future.channel().closeFuture().sync();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            bossGroup.shutdownGracefully();
            workerGroup.shutdownGracefully();
        }
    }
}
```

### 2.2 用户管理类

```java
@Component
public class UserManager {
    // userId -> channel 映射
    private static final ConcurrentHashMap<Long, Channel> userChannels = new ConcurrentHashMap    
    // channel -> userId 映射
    private static final ConcurrentHashMap<Channel, Long> channelUsers = new ConcurrentHashMap    
    public void addUser(Long userId, Channel channel) {
        userChannels.put(userId, channel);
        channelUsers.put(channel, userId);
    }
    
    public void removeUser(Channel channel) {
        Long userId = channelUsers.remove(channel);
        if (userId != null) {
            userChannels.remove(userId);
        }
    }
    
    public Channel getUserChannel(Long userId) {
        return userChannels.get(userId);
    }
    
    public Long getUserId(Channel channel) {
        return channelUsers.get(channel);
    }
}
```

### 2.3 群组管理类

```java
@Component
public class GroupManager {
    // groupId -> 成员列表
    private static final ConcurrentHashMap<Long, Set<Long>> groups = new ConcurrentHashMap    
    public void createGroup(Long groupId, Set<Long> members) {
        groups.putIfAbsent(groupId, new CopyOnWriteArraySetmembers));
    }
    
    public void addMember(Long groupId, Long userId) {
        groups.computeIfAbsent(groupId, k -> new CopyOnWriteArraySet<>()).add(userId);
    }
    
    public void removeMember(Long groupId, Long userId) {
        Set<Long> members = groups.get(groupId);
        if (members != null) {
            members.remove(userId);
        }
    }
    
    public Set<Long> getGroupMembers(Long groupId) {
        return groups.getOrDefault(groupId, Collections.emptySet());
    }
}
```

### 2.4 消息处理器

```java
@Component
@ChannelHandler.Sharable
public class MessageHandler extends SimpleChannelInboundHandler<ChatMessage> {
    
    @Autowired
    private UserManager userManager;
    
    @Autowired
    private GroupManager groupManager;
    
    @Override
    public void handlerAdded(ChannelHandlerContext ctx) {
        // 连接建立时调用
    }
    
    @Override
    public void handlerRemoved(ChannelHandlerContext ctx) {
        Long userId = userManager.getUserId(ctx.channel());
        if (userId != null) {
            userManager.removeUser(ctx.channel());
            System.out.println("用户" + userId + "断开连接");
        }
    }
    
    @Override
    protected void channelRead0(ChannelHandlerContext ctx, ChatMessage msg) {
        switch (msg.getType()) {
            case 1: // 私聊
                handlePrivateMessage(msg);
                break;
            case 2: // 群聊
                handleGroupMessage(msg);
                break;
            case 3: // 登录
                handleLogin(ctx, msg);
                break;
            case 4: // 创建群组
                handleCreateGroup(msg);
                break;
            default:
                System.out.println("未知消息类型");
        }
    }
    
    private void handleLogin(ChannelHandlerContext ctx, ChatMessage msg) {
        Long userId = msg.getSender();
        userManager.addUser(userId, ctx.channel());
        System.out.println("用户" + userId + "登录成功");
    }
    
    private void handlePrivateMessage(ChatMessage msg) {
        Channel receiverChannel = userManager.getUserChannel(msg.getReceiver());
        if (receiverChannel != null) {
            receiverChannel.writeAndFlush(msg);
            System.out.println("发送私聊消息从" + msg.getSender() + "到" + msg.getReceiver());
        } else {
            System.out.println("用户" + msg.getReceiver() + "不在线");
        }
    }
    
    private void handleGroupMessage(ChatMessage msg) {
        Set<Long> members = groupManager.getGroupMembers(msg.getReceiver());
        members.forEach(memberId -> {
            if (!memberId.equals(msg.getSender())) { // 不给自己发
                Channel memberChannel = userManager.getUserChannel(memberId);
                if (memberChannel != null) {
                    memberChannel.writeAndFlush(msg);
                }
            }
        });
        System.out.println("发送群聊消息到群" + msg.getReceiver());
    }
    
    private void handleCreateGroup(ChatMessage msg) {
        Set<Long> members = new HashSet<>();
        members.add(msg.getSender()); // 创建者默认在群里
        members.add(msg.getReceiver()); // 假设消息里携带了另一个成员
        
        Long groupId = System.currentTimeMillis(); // 使用时间戳作为临时群ID
        groupManager.createGroup(groupId, members);
        
        // 通知群成员
        members.forEach(userId -> {
            Channel channel = userManager.getUserChannel(userId);
            if (channel != null) {
                ChatMessage notice = new ChatMessage();
                notice.setType(5); // 群创建通知
                notice.setReceiver(groupId);
                notice.setSender(msg.getSender());
                notice.setContent("您已被邀请加入群聊");
                channel.writeAndFlush(notice);
            }
        });
    }
    
    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
        cause.printStackTrace();
        ctx.close();
    }
}
```

## 3. 客户端实现

### 3.1 模拟客户端类

```java
public class Client {
    public static void main(String[] args) throws Exception {
        startClient(1001L); // 用户A
        startClient(1002L); // 用户B
        startClient(1003L); // 用户C
    }
    
    private static void startClient(Long userId) {
        new Thread(() -> {
            EventLoopGroup group = new NioEventLoopGroup();
            try {
                Bootstrap bootstrap = new Bootstrap();
                bootstrap.group(group)
                    .channel(NioSocketChannel.class)
                    .handler(new ChannelInitializer<SocketChannel>() {
                        @Override
                        protected void initChannel(SocketChannel ch) {
                            ChannelPipeline pipeline = ch.pipeline();
                            pipeline.addLast(new LengthFieldBasedFrameDecoder(1024, 0, 4, 0, 4));
                            pipeline.addLast(new LengthFieldPrepender(4));
                            pipeline.addLast(new ObjectDecoder(ClassResolvers.cacheDisabled(null)));
                            pipeline.addLast(new ObjectEncoder());
                            pipeline.addLast(new ClientHandler(userId));
                        }
                    });
                
                ChannelFuture future = bootstrap.connect("localhost", 8081).sync();
                
                // 登录
                ChatMessage loginMsg = new ChatMessage();
                loginMsg.setType(3); // 登录
                loginMsg.setSender(userId);
                future.channel().writeAndFlush(loginMsg);
                
                System.out.println("用户" + userId + "已连接");
                
                // 模拟用户交互
                if (userId == 1001L) { // 用户A
                    Thread.sleep(1000);
                    
                    // 创建群聊
                    ChatMessage createGroup = new ChatMessage();
                    createGroup.setType(4); // 创建群
                    createGroup.setSender(1001L);
                    createGroup.setReceiver(1002L); // 邀请用户B
                    future.channel().writeAndFlush(createGroup);
                    
                    Thread.sleep(1000);
                    
                    // 发送群消息
                    ChatMessage groupMsg = new ChatMessage();
                    groupMsg.setType(2); // 群聊
                    groupMsg.setSender(1001L);
                    groupMsg.setReceiver(123456L); // 群ID
                    groupMsg.setContent("大家好，这是群消息");
                    future.channel().writeAndFlush(groupMsg);
                }
                
                future.channel().closeFuture().sync();
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                group.shutdownGracefully();
            }
        }).start();
    }
}

class ClientHandler extends SimpleChannelInboundHandler<ChatMessage> {
    private final Long userId;
    
    public ClientHandler(Long userId) {
        this.userId = userId;
    }
    
    @Override
    protected void channelRead0(ChannelHandlerContext ctx, ChatMessage msg) {
        switch (msg.getType()) {
            case 1:
                System.out.println("[" + userId + "] 收到私聊消息来自" + msg.getSender() + ": " + msg.getContent());
                break;
            case 2:
                System.out.println("[" + userId + "] 收到群聊消息来自" + msg.getSender() + "在群" + msg.getReceiver() + ": " + msg.getContent());
                break;
            case 5:
                System.out.println("[" + userId + "] 收到系统消息: " + msg.getContent() + " 群ID: " + msg.getReceiver());
                break;
            default:
                System.out.println("[" + userId + "] 收到未知类型消息");
        }
    }
}
```

## 4. 测试流程

1. 启动服务器应用
2. 启动三个客户端(用户A、B、C)
3. 用户A创建群聊并邀请用户B
4. 用户A发送群消息
5. 用户B会收到群消息通知

## 5. 扩展功能建议

1. **消息持久化**:
   - 将消息存储到数据库
   - 实现离线消息功能

2. **心跳机制**:
   - 检测连接状态
   - 自动重连

3. **消息确认**:
   - 实现消息已读回执
   - 消息状态追踪

4. **安全认证**:
   - 使用Token进行身份验证
   - 消息加密传输

5. **扩展消息类型**:
   - 支持图片、文件等多媒体消息
   - 语音/视频通话

6. **性能优化**:
   - 消息压缩传输
   - 批量消息处理

这个实现提供了基础的私聊和群聊功能，可以根据实际需求进行扩展和优化。Netty的高性能特性使得这个IM系统能够处理大量的并发连接和消息。


# 一、用Spring Boot + Netty实现用户A和用户B的及时通讯，以及群聊功能



以下是基于 Spring Boot + Netty 实现 **点对点通讯 + 群聊功能** 的完整方案，包含核心代码和关键逻辑说明：

---

### 一、消息协议设计（JSON 格式）
```java
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Message {
    private String type;        // "chat"/"group_chat"/"join_group"/"leave_group"
    private String sender;      // 发送者ID
    private String receiver;    // 接收者ID（点对点时使用）
    private String groupId;     // 群组ID（群聊时使用）
    private String content;     // 消息内容
    private long timestamp;     // 时间戳
}
```

---

### 二、群组管理模块
```java
@Component
public class GroupManager {
    // 群组ID -> 用户ID集合
    private final Map<String, Set<String>> groups = new ConcurrentHashMap    // 用户ID -> 群组ID集合（可选：记录用户加入的群组）
    private final Map<String, Set<String>> userGroups = new ConcurrentHashMap    // 加入群组
    public void joinGroup(String userId, String groupId) {
        groups.computeIfAbsent(groupId, k -> new HashSet<>()).add(userId);
        userGroups.computeIfAbsent(userId, k -> new HashSet()).add(groupId);
    }

    // 退出群组
    public void leaveGroup(String userId, String groupId) {
        groups.getOrDefault(groupId, Collections.emptySet()).remove(userId);
        userGroups.getOrDefault(userId, Collections.emptySet()).remove(groupId);
    }

    // 获取群组成员
    public Set<String> getGroupMembers(String groupId) {
        return groups.getOrDefault(groupId, Collections.emptySet());
    }
}
```

---

### 三、消息处理逻辑（关键代码）
```java
@ChannelHandler.Sharable
@Component
public class MessageHandler extends SimpleChannelInboundHandler<String> {

    @Autowired
    private GroupManager groupManager;

    // 在线用户管理：用户ID -> Channel
    private static final Map<String, Channel> onlineUsers = new ConcurrentHashMap<>();

    @Override
    protected void channelRead0(ChannelHandlerContext ctx, String msg) {
        Message message = JSON.parseObject(msg, Message.class);
        
        switch (message.getType()) {
            case "chat": // 点对点消息
                sendToUser(message.getReceiver(), msg);
                break;
            case "group_chat": // 群聊消息
                sendToGroup(message.getGroupId(), msg);
                break;
            case "join_group": // 加入群组
                groupManager.joinGroup(message.getSender(), message.getGroupId());
                break;
            case "leave_group": // 退出群组
                groupManager.leaveGroup(message.getSender(), message.getGroupId());
                break;
        }
    }

    // 发送点对点消息
    private void sendToUser(String userId, String message) {
        Channel channel = onlineUsers.get(userId);
        if (channel != null && channel.isActive()) {
            channel.writeAndFlush(message);
        }
    }

    // 发送群聊消息
    private void sendToGroup(String groupId, String message) {
        Set<String> members = groupManager.getGroupMembers(groupId);
        members.forEach(userId -> sendToUser(userId, message));
    }

    // 用户上线
    @Override
    public void handlerAdded(ChannelHandlerContext ctx) {
        String userId = extractUserId(ctx); // 从握手或登录消息中获取用户ID
        onlineUsers.put(userId, ctx.channel());
    }

    // 用户下线
    @Override
    public void handlerRemoved(ChannelHandlerContext ctx) {
        String userId = findUserIdByChannel(ctx.channel());
        onlineUsers.remove(userId);
        // 可选：自动退出所有群组
        groupManager.userGroups.getOrDefault(userId, Collections.emptySet())
            .forEach(groupId -> groupManager.leaveGroup(userId, groupId));
    }
}
```

---

### 四、客户端交互示例（WebSocket）
#### 1. 点对点通讯
```javascript
// 用户A发送消息给用户B
socket.send(JSON.stringify({
    type: "chat",
    sender: "A",
    receiver: "B",
    content: "你好！"
}));
```

#### 2. 群聊流程
```javascript
// 用户A加入群组"GROUP_1"
socket.send(JSON.stringify({
    type: "join_group",
    sender: "A",
    groupId: "GROUP_1"
}));

// 用户A发送群消息
socket.send(JSON.stringify({
    type: "group_chat",
    sender: "A",
    groupId: "GROUP_1",
    content: "群内消息！"
}));
```

---

### 五、关键优化点
1. **消息序列化**：  
   使用 Protobuf 替代 JSON 提升性能（需定义 `.proto` 文件）。

2. **消息确认机制**：  
   添加 `messageId` 字段，客户端收到消息后发送 ACK，服务端重试未确认消息。

3. **离线消息存储**：  
   用户不在线时，将消息存入数据库（如 Redis + Spring Data JPA）。

4. **分布式支持**：  
   使用 Redis 发布/订阅实现多节点消息广播，或集成 RocketMQ/Kafka。

5. **安全增强**：  
   添加 JWT 鉴权，验证消息发送者的身份与 receiver/group_id 的权限。

---

### 六、测试建议
1. **点对点**：  
   启动两个客户端（A 和 B），A 发送消息给 B，验证 B 能收到。

2. **群聊**：  
   启动三个客户端（A/B/C），全部加入 `GROUP_1`，A 发送群消息，验证 B/C 收到。

3. **边界测试**：  
   - 发送消息到不存在的群组  
   - 用户未加入群组时发送群消息  
   - 用户离线后重新上线接收离线消息（需扩展功能）

---

完整项目可在 [GitHub - netty-im-demo](https://github.com/example/netty-im-demo) 获取（示例链接需替换为实际项目）。生产环境需补充日志、监控、连接池等模块。
