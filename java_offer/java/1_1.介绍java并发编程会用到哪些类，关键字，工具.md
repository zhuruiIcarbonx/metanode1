**原子性**
<br>

    定义： 一个或多个操作要么全部成功执行，要么全部失败，不可分割。
    例子： 在银行转账时，从一个账户扣款和给另一个账户存款这两个操作必须作为一个整体，要么都成功，要么都不成功。
    解决方式： 在Java中，可以使用synchronized关键字或锁机制来确保复合操作的原子性。 
**可见性**
<br>

    定义： 当一个线程修改了共享变量的值时，其他线程能够立刻看到这个最新值。
    问题根源： 在多线程环境下，线程可能拥有自己本地的缓存，修改的值可能没有立即同步到主内存，其他线程读取到的是旧值。
    解决方式： 使用volatile关键字可以强制线程从主内存中读取变量，而不是使用本地缓存。synchronized和Lock也可以保证可见性。 
**有序性**
<br>

    定义： 程序执行的顺序按照代码的先后顺序执行。
    问题根源： 处理器和编译器为了提高性能，会进行指令重排序，使得实际执行顺序和代码顺序不一致。
    解决方式： synchronized关键字和volatile关键字都可以通过内存屏障来禁止指令重排序，保证执行的有序性

# 一、  介绍java并发编程会用到哪些类，关键字，工具

在Java并发编程中，常用的类、关键字和工具可以归纳为以下几类：

---

### **1. 关键字**
- **`synchronized`**  
  用于方法或代码块，提供互斥锁，保证原子性和可见性。
  ```java
  synchronized (lockObject) { /* 临界区代码 */ }
  ```

- **`volatile`**  
  保证变量的可见性（直接读写主内存），禁止指令重排序，但不保证原子性。
  ```java
  private volatile boolean flag;
  ```

- **`final`**  
  不可变性支持，线程安全的初始化（通过JVM的`happens-before`规则）。

---

### **2. 核心类（`java.util.concurrent`包）**
#### **锁机制**
- **`ReentrantLock`**  
  可重入锁，替代`synchronized`，支持公平锁、非公平锁和条件变量（`Condition`）。
  ```java
  Lock lock = new ReentrantLock();
  lock.lock();
  try { /* 临界区 */ } finally { lock.unlock(); }
  ```

- **`ReadWriteLock`**  
  读写分离锁（`ReentrantReadWriteLock`），提高读多写少场景的性能。

#### **线程管理**
- **`Thread`** 和 **`Runnable`**  
  基础线程类与任务接口。
  ```java
  new Thread(() -> System.out.println("Run")).start();
  ```

- **`ExecutorService`** 与线程池  
  通过`Executors`工厂类创建（如`newFixedThreadPool`、`newCachedThreadPool`），推荐使用`ThreadPoolExecutor`自定义参数。

#### **同步工具**
- **`CountDownLatch`**  
  等待一组操作完成（一次性屏障）。
  ```java
  CountDownLatch latch = new CountDownLatch(3);
  latch.await(); // 阻塞直到计数器归零
  ```

- **`CyclicBarrier`**  
  可重复使用的同步屏障（所有线程到达屏障后继续执行）。

- **`Semaphore`**  
  控制并发线程数（信号量）。
  ```java
  Semaphore semaphore = new Semaphore(5);
  semaphore.acquire(); // 获取许可
  ```

- **`Phaser`**  
  更灵活的阶段性同步（JDK7+）。

#### **线程安全集合**
- **`ConcurrentHashMap`**  
  高并发哈希表，分段锁（JDK8后改为CAS优化）。
- **`CopyOnWriteArrayList`**  
  读多写少场景的线程安全列表（写时复制）。
- **`BlockingQueue`**  
  阻塞队列（如`ArrayBlockingQueue`、`LinkedBlockingQueue`），用于生产者-消费者模型。

#### **原子类（`java.util.concurrent.atomic`）**
- **`AtomicInteger`**, **`AtomicLong`**, **`AtomicReference`**  
  通过CAS（Compare-And-Swap）实现无锁线程安全操作。
  ```java
  AtomicInteger counter = new AtomicInteger(0);
  counter.incrementAndGet();
  ```

---

### **3. 工具类与框架**
- **`CompletableFuture`** (JDK8+)  
  异步编程工具，支持链式调用和组合任务。
  ```java
  CompletableFuture.supplyAsync(() -> "Hello").thenAccept(System.out::println);
  ```

- **`ForkJoinPool`**  
  分治任务框架（配合`RecursiveTask`/`RecursiveAction`）。

- **`StampedLock`** (JDK8+)  
  乐观读锁，减少读写冲突。

---

### **4. 其他重要概念**
- **`ThreadLocal`**  
  线程本地变量，避免共享（但需注意内存泄漏）。
- **`Callable` 与 `Future`**  
  支持返回结果的线程任务。
- **`ThreadPoolExecutor`**  
  自定义线程池的核心类（核心线程数、队列策略等）。

---

### **5. 监控与调试**
- **`ThreadDump`**  
  通过`jstack`或`VisualVM`分析线程状态。
- **`LockSupport`**  
  底层线程阻塞/唤醒工具（`park()`/`unpark()`）。

---

### **最佳实践建议**
1. **优先使用高层工具**（如`ExecutorService`、`ConcurrentHashMap`）而非直接操作线程。
2. **避免死锁**：按固定顺序获取锁，或使用`tryLock`超时机制。
3. **性能考量**：读多写少用`ReadWriteLock`，高竞争用CAS（原子类）。

如果需要具体场景的示例或深入某个工具，可以进一步探讨！


# 一、  介绍java并发编程会用到哪些类，关键字，工具

在 Java 并发编程中，为了实现多线程的协作、资源共享和线程安全，Java 提供了丰富的类、关键字和工具。以下是常用的并发编程元素分类介绍：

---

### 一、关键字（Keywords）

1. **`synchronized`**
   - 用于保证线程的互斥访问，可修饰方法或代码块。
   - JVM 会为对象或类创建监视器锁（Monitor Lock）。
   - 示例：
     ```java
     synchronized void method() { ... }
     synchronized(this) { ... }
     ```

2. **`volatile`**
   - 保证变量的可见性，禁止指令重排序。
   - 适用于状态标志变量，但不保证原子性。
   - 示例：
     ```java
     private volatile boolean running = true;
     ```

3. **`transient`**（间接相关）
   - 虽非并发专用，但在并发中用于控制序列化时的状态，避免不一致。

---

### 二、核心类与接口（java.util.concurrent 包）

#### 1. 线程管理
- **`Thread` / `Runnable` / `Callable`**
  - `Runnable`：无返回值的线程任务。
  - `Callable<V>`：有返回值的线程任务，配合 `Future` 使用。

- **`Future` / `FutureTask`**
  - 用于获取异步任务的执行结果。
  - `Future.get()` 会阻塞直到结果返回。

- **`Executor` / `ExecutorService`**
  - 线程池接口，管理线程生命周期。
  - 示例：
    ```java
    ExecutorService executor = Executors.newFixedThreadPool(4);
    executor.submit(task);
    ```

- **`Executors`**（工具类）
  - 提供创建常见线程池的工厂方法：
    - `newFixedThreadPool`
    - `newCachedThreadPool`
    - `newSingleThreadExecutor`
    - `newScheduledThreadPool`

#### 2. 同步工具类
- **`ReentrantLock`**
  - 可重入的显式锁，比 `synchronized` 更灵活，支持公平锁、尝试锁（`tryLock`）、中断锁等。

- **`ReentrantReadWriteLock`**
  - 读写锁，允许多个读线程并发，写线程独占。

- **`StampedLock`**（Java 8+）
  - 更高性能的读写锁，支持乐观读。

- **`Semaphore`**
  - 信号量，控制并发线程数量（如限流）。

- **`CountDownLatch`**
  - 等待一组线程完成，主线程再继续。
  - 计数一次性使用。

- **`CyclicBarrier`**
  - 多个线程相互等待，达到屏障点后一起继续。
  - 可重复使用。

- **`Phaser`**
  - 更灵活的同步屏障，支持动态注册线程。

#### 3. 并发集合（线程安全）
- **`ConcurrentHashMap`**
  - 高性能线程安全的 HashMap，支持并发读写。

- **`CopyOnWriteArrayList` / `CopyOnWriteArraySet`**
  - 写时复制，适合读多写少的场景。

- **`BlockingQueue` 接口及实现**
  - 线程安全的队列，用于生产者-消费者模式。
  - 常见实现：
    - `ArrayBlockingQueue`（有界）
    - `LinkedBlockingQueue`（可有界）
    - `PriorityBlockingQueue`（优先级）
    - `SynchronousQueue`（不存储元素）

- **`ConcurrentLinkedQueue`**
  - 非阻塞的线程安全队列，基于 CAS 实现。

#### 4. 原子类（`java.util.concurrent.atomic`）
- 使用 CAS（Compare-And-Swap）实现无锁并发。
- 常见类：
  - `AtomicInteger`, `AtomicLong`, `AtomicBoolean`
  - `AtomicReference`（对象引用原子操作）
  - `AtomicIntegerArray`, `AtomicLongArray`
  - `AtomicStampedReference`（解决 ABA 问题）

---

### 三、并发设计模式与工具

- **`ForkJoinPool` / `RecursiveTask` / `RecursiveAction`**
  - 用于分治算法，实现工作窃取（Work-Stealing）。

- **`CompletableFuture`**（Java 8+）
  - 异步编程工具，支持链式调用、组合多个异步任务。
  - 示例：
    ```java
    CompletableFuture.supplyAsync(() -> compute())
                     .thenApply(result -> result * 2)
                     .thenAccept(System.out::println);
    ```

- **`ThreadLocal`**
  - 线程本地变量，每个线程有独立副本，避免共享。

- **`ScheduledExecutorService`**
  - 支持定时和周期性任务执行。
  - 替代 `Timer`，更健壮。

---

### 四、常见设计原则与技巧

- 使用线程池避免频繁创建线程。
- 优先使用 `java.util.concurrent` 中的工具类，而非手动同步。
- 避免死锁：按顺序获取锁，使用超时机制。
- 使用 `volatile` 保证状态可见性，`synchronized` 或 `Lock` 保证原子性。
- 合理选择集合类：高并发下优先 `ConcurrentHashMap`、`BlockingQueue` 等。

---

### 总结

Java 并发编程的核心在于 **线程管理、同步控制、线程安全集合和原子操作**。合理使用以下元素可以构建高效、安全的并发程序：

| 类别       | 关键代表 |
|------------|----------|
| 关键字     | `synchronized`, `volatile` |
| 线程池     | `ExecutorService`, `ThreadPoolExecutor` |
| 锁         | `ReentrantLock`, `ReadWriteLock` |
| 同步工具   | `CountDownLatch`, `CyclicBarrier`, `Semaphore` |
| 并发集合   | `ConcurrentHashMap`, `BlockingQueue` |
| 原子类     | `AtomicInteger`, `AtomicReference` |
| 异步编程   | `CompletableFuture` |

掌握这些工具，是编写高性能 Java 并发程序的基础。


