# ä¸€ã€è¯¦ç»†ä»‹ç»javaçº¿ç¨‹æ± å†…éƒ¨ç»“æ„ï¼Œå·¥ä½œåŸç†ï¼›å†™å‡ºä»£ç å®ç°çº¿ç¨‹æ± å¯¹ä»»åŠ¡çš„å¹¶å‘å¤„ç†

# Javaçº¿ç¨‹æ± è¯¦è§£ä¸å®ç°

## ä¸€ã€çº¿ç¨‹æ± å†…éƒ¨ç»“æ„

### 1. æ ¸å¿ƒç»„ä»¶

çº¿ç¨‹æ± (ThreadPoolExecutor)ä¸»è¦ç”±ä»¥ä¸‹æ ¸å¿ƒç»„ä»¶æ„æˆï¼š

| ç»„ä»¶                | ä½œç”¨                                                                 |
|---------------------|----------------------------------------------------------------------|
| **æ ¸å¿ƒçº¿ç¨‹æ± (corePool)** | å¸¸é©»çš„å·¥ä½œçº¿ç¨‹ï¼Œå³ä½¿ç©ºé—²ä¹Ÿä¸ä¼šè¢«å›æ”¶                                |
| **å·¥ä½œé˜Ÿåˆ—(workQueue)**  | ç”¨äºå­˜æ”¾å¾…å¤„ç†ä»»åŠ¡çš„é˜»å¡é˜Ÿåˆ—                                        |
| **æœ€å¤§çº¿ç¨‹æ± (maximumPool)** | å½“å·¥ä½œé˜Ÿåˆ—æ»¡äº†ä¹‹åå¯ä»¥åˆ›å»ºçš„æœ€å¤§çº¿ç¨‹æ•°                              |
| **çº¿ç¨‹å·¥å‚(threadFactory)** | åˆ›å»ºæ–°çº¿ç¨‹çš„å·¥å‚ç±»                                                  |
| **æ‹’ç»ç­–ç•¥(rejectedPolicy)** | å½“çº¿ç¨‹æ± å’Œå·¥ä½œé˜Ÿåˆ—éƒ½æ»¡æ—¶çš„å¤„ç†ç­–ç•¥                                  |
| **å­˜æ´»æ—¶é—´(keepAliveTime)** | éæ ¸å¿ƒçº¿ç¨‹ç©ºé—²æ—¶çš„å­˜æ´»æ—¶é—´                                          |

### 2. æ ¸å¿ƒæ•°æ®ç»“æ„

```java
public class ThreadPoolExecutor extends AbstractExecutorService {
    // æ§åˆ¶çŠ¶æ€å’Œçº¿ç¨‹æ•°çš„åŸå­æ•´æ•°
    private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
    
    // å·¥ä½œé˜Ÿåˆ—
    private final BlockingQueue<Runnable> workQueue;
    
    // å·¥ä½œçº¿ç¨‹é›†åˆ
    private final HashSet<Worker> workers = new HashSet    
    // çº¿ç¨‹å·¥å‚
    private volatile ThreadFactory threadFactory;
    
    // æ‹’ç»ç­–ç•¥
    private volatile RejectedExecutionHandler handler;
    
    // ...
}
```

## äºŒã€çº¿ç¨‹æ± å·¥ä½œåŸç†

### 1. ä»»åŠ¡æäº¤æµç¨‹

```mermaid
graph TD
    A[æäº¤ä»»åŠ¡] --> B{æ ¸å¿ƒçº¿ç¨‹æ˜¯å¦å·²æ»¡?}
    B -- å¦ --> C[åˆ›å»ºæ ¸å¿ƒçº¿ç¨‹æ‰§è¡Œä»»åŠ¡]
    B -- æ˜¯ --> D{å·¥ä½œé˜Ÿåˆ—æ˜¯å¦å·²æ»¡?}
    D -- å¦ --> E[ä»»åŠ¡åŠ å…¥å·¥ä½œé˜Ÿåˆ—]
    D -- æ˜¯ --> F{çº¿ç¨‹æ•°æ˜¯å¦è¾¾åˆ°æœ€å¤§å€¼?}
    F -- å¦ --> G[åˆ›å»ºéæ ¸å¿ƒçº¿ç¨‹æ‰§è¡Œä»»åŠ¡]
    F -- æ˜¯ --> H[æ‰§è¡Œæ‹’ç»ç­–ç•¥]
```

### 2. å…³é”®å·¥ä½œæ­¥éª¤

1. **ä»»åŠ¡æäº¤**ï¼šè°ƒç”¨`execute()`æˆ–`submit()`æ–¹æ³•
2. **çº¿ç¨‹åˆ›å»º**ï¼š
   - å½“å‰çº¿ç¨‹æ•° < corePoolSize â†’ åˆ›å»ºæ–°çº¿ç¨‹(å³ä½¿æœ‰ç©ºé—²çº¿ç¨‹)
   - é˜Ÿåˆ—å·²æ»¡ä¸”çº¿ç¨‹æ•° < maximumPoolSize â†’ åˆ›å»ºæ–°çº¿ç¨‹
3. **ä»»åŠ¡æ’é˜Ÿ**ï¼šçº¿ç¨‹æ•° â‰¥ corePoolSizeæ—¶ï¼Œä»»åŠ¡è¿›å…¥å·¥ä½œé˜Ÿåˆ—
4. **ä»»åŠ¡æ‹’ç»**ï¼šé˜Ÿåˆ—å’Œçº¿ç¨‹æ± éƒ½æ»¡æ—¶ï¼Œæ‰§è¡Œæ‹’ç»ç­–ç•¥
5. **çº¿ç¨‹å›æ”¶**ï¼šéæ ¸å¿ƒçº¿ç¨‹ç©ºé—²è¶…è¿‡keepAliveTimeåè¢«å›æ”¶

## ä¸‰ã€çº¿ç¨‹æ± å®ç°ä»£ç ç¤ºä¾‹

### 1. è‡ªå®šä¹‰çº¿ç¨‹æ± å®ç°

```java
import java.util.HashSet;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;

public class CustomThreadPool {
    // çº¿ç¨‹æ± çŠ¶æ€
    private volatile boolean isRunning = true;
    
    // æ ¸å¿ƒå‚æ•°
    private final int corePoolSize;
    private final int maximumPoolSize;
    private final long keepAliveTime;
    private final TimeUnit unit;
    private final BlockingQueue<Runnable> workQueue;
    
    // å·¥ä½œçº¿ç¨‹é›†åˆ
    private final HashSet<Worker> workers = new HashSet    private final AtomicInteger threadCount = new AtomicInteger(0);
    
    // æ„é€ æ–¹æ³•
    public CustomThreadPool(int corePoolSize, int maximumPoolSize,
                          long keepAliveTime, TimeUnit unit,
                          BlockingQueue<Runnable> workQueue) {
        this.corePoolSize = corePoolSize;
        this.maximumPoolSize = maximumPoolSize;
        this.keepAliveTime = keepAliveTime;
        this.unit = unit;
        this.workQueue = workQueue;
    }
    
    // æ‰§è¡Œä»»åŠ¡
    public void execute(Runnable task) {
        if (task == null) throw new NullPointerException();
        if (!isRunning) throw new IllegalStateException("ThreadPool not running");
        
        // 1. å½“å‰çº¿ç¨‹æ•° < corePoolSize â†’ åˆ›å»ºæ–°çº¿ç¨‹
        if (threadCount.get() < corePoolSize) {
            if (addWorker(task, true)) {
                return;
            }
        }
        
        // 2. å°è¯•å°†ä»»åŠ¡åŠ å…¥é˜Ÿåˆ—
        if (workQueue.offer(task)) {
            // æ£€æŸ¥çº¿ç¨‹æ± çŠ¶æ€
            if (!isRunning && workQueue.remove(task)) {
                rejectTask(task);
            } else if (threadCount.get() == 0) {
                addWorker(null, false); // åˆ›å»ºæ–°çš„éæ ¸å¿ƒçº¿ç¨‹
            }
        }
        // 3. é˜Ÿåˆ—å·²æ»¡ â†’ å°è¯•åˆ›å»ºéæ ¸å¿ƒçº¿ç¨‹
        else if (!addWorker(task, false)) {
            // 4. çº¿ç¨‹æ•°å·²è¾¾max â†’ æ‹’ç»ä»»åŠ¡
            rejectTask(task);
        }
    }
    
    // æ·»åŠ å·¥ä½œçº¿ç¨‹
    private boolean addWorker(Runnable firstTask, boolean core) {
        if (threadCount.get() >= (core ? corePoolSize : maximumPoolSize)) {
            return false;
        }
        
        boolean workerStarted = false;
        boolean workerAdded = false;
        Worker worker = new Worker(firstTask);
        Thread thread = worker.thread;
        
        if (thread != null) {
            synchronized (workers) {
                if (isRunning) {
                    workers.add(worker);
                    workerAdded = true;
                }
            }
            
            if (workerAdded) {
                thread.start();
                workerStarted = true;
                threadCount.incrementAndGet();
            } else {
                worker.thread.interrupt();
            }
        }
        return workerStarted;
    }
    
    // å·¥ä½œçº¿ç¨‹ç±»
    private final class Worker implements Runnable {
        final Thread thread;
        Runnable firstTask;
        
        Worker(Runnable firstTask) {
            this.firstTask = firstTask;
            this.thread = new Thread(this);
        }
        
        @Override
        public void run() {
            runWorker(this);
        }
    }
    
    // è¿è¡Œå·¥ä½œçº¿ç¨‹
    private void runWorker(Worker worker) {
        Runnable task = worker.firstTask;
        worker.firstTask = null;
        
        while (task != null || (task = getTask()) != null) {
            try {
                task.run();
            } finally {
                task = null; // å¸®åŠ©GC
            }
        }
        
        synchronized (workers) {
            workers.remove(worker);
            threadCount.decrementAndGet();
        }
    }
    
    // ä»é˜Ÿåˆ—è·å–ä»»åŠ¡
    private Runnable getTask() {
        boolean timed = threadCount.get() > corePoolSize;
        
        try {
            return timed ? 
                workQueue.poll(keepAliveTime, unit) :
                workQueue.take();
        } catch (InterruptedException e) {
            return null;
        }
    }
    
    // æ‹’ç»ä»»åŠ¡ç­–ç•¥
    private void rejectTask(Runnable task) {
        System.out.println("Task rejected: " + task.toString());
    }
    
    // å…³é—­çº¿ç¨‹æ± 
    public void shutdown() {
        isRunning = false;
        synchronized (workers) {
            for (Worker worker : workers) {
                worker.thread.interrupt();
            }
        }
    }
}
```

### 2. ä½¿ç”¨ç¤ºä¾‹

```java
public class ThreadPoolDemo {
    public static void main(String[] args) {
        // åˆ›å»ºè‡ªå®šä¹‰çº¿ç¨‹æ± 
        CustomThreadPool pool = new CustomThreadPool(
            2,  // æ ¸å¿ƒçº¿ç¨‹æ•°
            4,  // æœ€å¤§çº¿ç¨‹æ•°
            60, // ç©ºé—²æ—¶é—´
            TimeUnit.SECONDS,
            new LinkedBlockingQueue<>(10) // ä»»åŠ¡é˜Ÿåˆ—
        );
        
        // æäº¤20ä¸ªä»»åŠ¡
        for (int i = 0; i < 20; i++) {
            final int taskId = i;
            pool.execute(() -> {
                System.out.println(Thread.currentThread().getName() + 
                    " executing task " + taskId);
                try {
                    Thread.sleep(1000); // æ¨¡æ‹Ÿä»»åŠ¡æ‰§è¡Œ
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            });
        }
        
        // å…³é—­çº¿ç¨‹æ± 
        try {
            Thread.sleep(5000);
            pool.shutdown();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

## å››ã€æ ‡å‡†çº¿ç¨‹æ± ä½¿ç”¨

Javaé€šè¿‡`Executors`æä¾›äº†å‡ ç§å¸¸ç”¨çº¿ç¨‹æ± ï¼š

### 1. å›ºå®šå¤§å°çº¿ç¨‹æ± 

```java
ExecutorService fixedPool = Executors.newFixedThreadPool(5);
fixedPool.execute(() -> {
    System.out.println("Task running in fixed thread pool");
});
```

### 2. å¯ç¼“å­˜çº¿ç¨‹æ± 

```java
ExecutorService cachedPool = Executors.newCachedThreadPool();
Future<String> future = cachedPool.submit(() -> {
    return "Result from cached thread pool";
});
```

### 3. å•çº¿ç¨‹æ± 

```java
ExecutorService singlePool = Executors.newSingleThreadExecutor();
singlePool.submit(() -> {
    System.out.println("Task running in single thread executor");
});
```

### 4. å®šæ—¶ä»»åŠ¡çº¿ç¨‹æ± 

```java
ScheduledExecutorService scheduledPool = Executors.newScheduledThreadPool(3);
scheduledPool.scheduleAtFixedRate(() -> {
    System.out.println("Periodic task running");
}, 1, 1, TimeUnit.SECONDS);
```

## äº”ã€å…³é”®æ³¨æ„äº‹é¡¹

1. **çº¿ç¨‹æ± å¤§å°è®¾ç½®**ï¼š
   - CPUå¯†é›†å‹ï¼š`æ ¸å¿ƒæ•° + 1`
   - IOå¯†é›†å‹ï¼š`æ ¸å¿ƒæ•° * (1 + å¹³å‡ç­‰å¾…æ—¶é—´/å¹³å‡è®¡ç®—æ—¶é—´)`

2. **ä»»åŠ¡é˜Ÿåˆ—é€‰æ‹©**ï¼š
   - `LinkedBlockingQueue`ï¼šæ— ç•Œé˜Ÿåˆ—(å°å¿ƒOOM)
   - `ArrayBlockingQueue`ï¼šæœ‰ç•Œé˜Ÿåˆ—
   - `SynchronousQueue`ï¼šç›´æ¥ä¼ é€’é˜Ÿåˆ—

3. **æ‹’ç»ç­–ç•¥**ï¼š
   - AbortPolicy(é»˜è®¤)ï¼šæŠ›å‡ºRejectedExecutionException
   - CallerRunsPolicyï¼šç”±è°ƒç”¨çº¿ç¨‹æ‰§è¡Œ
   - DiscardOldestPolicyï¼šä¸¢å¼ƒé˜Ÿåˆ—æœ€æ—§ä»»åŠ¡
   - DiscardPolicyï¼šé™é»˜ä¸¢å¼ƒæ–°ä»»åŠ¡

4. **èµ„æºå…³é—­**ï¼š
   - `shutdown()`ï¼šæ¸©å’Œå…³é—­ï¼Œå¤„ç†å®Œé˜Ÿåˆ—ä»»åŠ¡
   - `shutdownNow()`ï¼šç«‹å³ä¸­æ–­æ‰€æœ‰çº¿ç¨‹

é€šè¿‡åˆç†é…ç½®çº¿ç¨‹æ± å‚æ•°ï¼Œå¯ä»¥ä¼˜åŒ–ç³»ç»Ÿæ€§èƒ½å¹¶é˜²æ­¢èµ„æºè€—å°½é—®é¢˜ã€‚


# ä¸€ã€è¯¦ç»†ä»‹ç»javaçº¿ç¨‹æ± å†…éƒ¨ç»“æ„ï¼Œå·¥ä½œåŸç†ï¼›å†™å‡ºä»£ç å®ç°çº¿ç¨‹æ± å¯¹ä»»åŠ¡çš„å¹¶å‘å¤„ç†

Java çº¿ç¨‹æ± æ˜¯å¹¶å‘ç¼–ç¨‹ä¸­çš„æ ¸å¿ƒç»„ä»¶ä¹‹ä¸€ï¼Œå®ƒé€šè¿‡å¤ç”¨çº¿ç¨‹ã€æ§åˆ¶èµ„æºæ¶ˆè€—ã€æé«˜å“åº”é€Ÿåº¦ï¼Œæå¤§åœ°æå‡äº†å¤šçº¿ç¨‹ç¨‹åºçš„æ€§èƒ½å’Œç¨³å®šæ€§ã€‚ä¸‹é¢å°†ä» **çº¿ç¨‹æ± çš„å†…éƒ¨ç»“æ„ã€å·¥ä½œåŸç†** å‡ºå‘ï¼Œå¹¶ç»“åˆ **ä»£ç å®ç°ä¸€ä¸ªç®€å•çš„ä»»åŠ¡å¹¶å‘å¤„ç†ç¤ºä¾‹**ï¼Œå…¨é¢è®²è§£ã€‚

---

## ä¸€ã€Java çº¿ç¨‹æ± çš„å†…éƒ¨ç»“æ„

Java ä¸­çš„çº¿ç¨‹æ± ä¸»è¦ç”± `java.util.concurrent.ThreadPoolExecutor` ç±»å®ç°ï¼Œå…¶æ ¸å¿ƒç»“æ„åŒ…æ‹¬ä»¥ä¸‹å‡ ä¸ªå…³é”®ç»„æˆéƒ¨åˆ†ï¼š

### 1. **æ ¸å¿ƒçº¿ç¨‹æ•°ï¼ˆcorePoolSizeï¼‰**
- çº¿ç¨‹æ± ä¸­**é•¿æœŸä¿ç•™çš„çº¿ç¨‹æ•°é‡**ã€‚
- å³ä½¿è¿™äº›çº¿ç¨‹ç©ºé—²ï¼Œä¹Ÿä¸ä¼šè¢«é”€æ¯ï¼ˆé™¤éè®¾ç½®äº† `allowCoreThreadTimeOut(true)`ï¼‰ã€‚

### 2. **æœ€å¤§çº¿ç¨‹æ•°ï¼ˆmaximumPoolSizeï¼‰**
- çº¿ç¨‹æ± ä¸­å…è®¸å­˜åœ¨çš„**æœ€å¤§çº¿ç¨‹æ•°é‡**ã€‚
- å½“ä»»åŠ¡é˜Ÿåˆ—å·²æ»¡ä¸”æ ¸å¿ƒçº¿ç¨‹éƒ½åœ¨å·¥ä½œæ—¶ï¼Œä¼šåˆ›å»ºæ–°çº¿ç¨‹ï¼Œç›´åˆ°è¾¾åˆ°æ­¤å€¼ã€‚

### 3. **ä»»åŠ¡é˜Ÿåˆ—ï¼ˆworkQueueï¼‰**
- å­˜æ”¾å¾…æ‰§è¡Œä»»åŠ¡çš„é˜»å¡é˜Ÿåˆ—ã€‚
- å¸¸è§å®ç°ï¼š
  - `LinkedBlockingQueue`ï¼šæ— ç•Œé˜Ÿåˆ—ï¼ˆé»˜è®¤ï¼‰
  - `ArrayBlockingQueue`ï¼šæœ‰ç•Œé˜Ÿåˆ—
  - `SynchronousQueue`ï¼šä¸å­˜å‚¨å…ƒç´ ï¼Œæ¯ä¸ªæ’å…¥å¿…é¡»ç­‰å¾…å–å‡º

### 4. **éæ ¸å¿ƒçº¿ç¨‹ç©ºé—²å­˜æ´»æ—¶é—´ï¼ˆkeepAliveTimeï¼‰**
- è¶…è¿‡ `corePoolSize` çš„çº¿ç¨‹åœ¨ç©ºé—²æ—¶çš„å­˜æ´»æ—¶é—´ã€‚
- è¶…æ—¶åä¼šè¢«å›æ”¶ã€‚

### 5. **çº¿ç¨‹å·¥å‚ï¼ˆThreadFactoryï¼‰**
- ç”¨äºåˆ›å»ºæ–°çº¿ç¨‹ã€‚
- å¯è‡ªå®šä¹‰çº¿ç¨‹åç§°ã€æ˜¯å¦ä¸ºå®ˆæŠ¤çº¿ç¨‹ç­‰ã€‚

### 6. **æ‹’ç»ç­–ç•¥ï¼ˆRejectedExecutionHandlerï¼‰**
- å½“çº¿ç¨‹æ± å…³é—­æˆ–ä»»åŠ¡é˜Ÿåˆ—å’Œçº¿ç¨‹æ•°éƒ½è¾¾åˆ°ä¸Šé™æ—¶ï¼Œæ–°æäº¤çš„ä»»åŠ¡å°†è¢«æ‹’ç»ã€‚
- å¸¸è§ç­–ç•¥ï¼š
  - `AbortPolicy`ï¼šæŠ›å‡º `RejectedExecutionException`ï¼ˆé»˜è®¤ï¼‰
  - `CallerRunsPolicy`ï¼šç”±è°ƒç”¨è€…çº¿ç¨‹ç›´æ¥æ‰§è¡Œä»»åŠ¡
  - `DiscardPolicy`ï¼šé™é»˜ä¸¢å¼ƒä»»åŠ¡
  - `DiscardOldestPolicy`ï¼šä¸¢å¼ƒé˜Ÿåˆ—ä¸­æœ€è€çš„ä»»åŠ¡ï¼Œç„¶åé‡è¯•æäº¤

---

## äºŒã€çº¿ç¨‹æ± çš„å·¥ä½œåŸç†ï¼ˆä»»åŠ¡è°ƒåº¦æµç¨‹ï¼‰

å½“è°ƒç”¨ `execute(Runnable command)` æäº¤ä»»åŠ¡æ—¶ï¼Œçº¿ç¨‹æ± æŒ‰ä»¥ä¸‹é¡ºåºå¤„ç†ï¼š

```text
1. å¦‚æœå½“å‰çº¿ç¨‹æ•° < corePoolSizeï¼š
   â†’ åˆ›å»ºæ–°çº¿ç¨‹æ‰§è¡Œä»»åŠ¡ï¼ˆå³ä½¿æœ‰ç©ºé—²çº¿ç¨‹ï¼‰

2. å¦åˆ™ï¼Œå¦‚æœ workQueue æœªæ»¡ï¼š
   â†’ å°†ä»»åŠ¡åŠ å…¥é˜Ÿåˆ—ç­‰å¾…ç©ºé—²çº¿ç¨‹å¤„ç†

3. å¦åˆ™ï¼Œå¦‚æœå½“å‰çº¿ç¨‹æ•° < maximumPoolSizeï¼š
   â†’ åˆ›å»ºâ€œéæ ¸å¿ƒçº¿ç¨‹â€ç«‹å³æ‰§è¡Œä»»åŠ¡

4. å¦åˆ™ï¼š
   â†’ æ‰§è¡Œæ‹’ç»ç­–ç•¥
```

### ğŸ”„ å·¥ä½œæµç¨‹å›¾ï¼ˆæ–‡å­—æè¿°ï¼‰ï¼š

```
æäº¤ä»»åŠ¡
   â†“
çº¿ç¨‹æ•° < corePoolSizeï¼Ÿ â†’ æ˜¯ â†’ åˆ›å»ºæ ¸å¿ƒçº¿ç¨‹æ‰§è¡Œ
   â†“å¦
é˜Ÿåˆ—æœªæ»¡ï¼Ÿ             â†’ æ˜¯ â†’ å…¥é˜Ÿç­‰å¾…
   â†“å¦
çº¿ç¨‹æ•° < maxï¼Ÿ         â†’ æ˜¯ â†’ åˆ›å»ºéæ ¸å¿ƒçº¿ç¨‹æ‰§è¡Œ
   â†“å¦
æ‰§è¡Œæ‹’ç»ç­–ç•¥
```

> âš ï¸ æ³¨æ„ï¼šä½¿ç”¨ `SynchronousQueue` æ—¶ï¼Œä»»åŠ¡ä¸ä¼šå…¥é˜Ÿï¼Œè€Œæ˜¯ç›´æ¥å°è¯•äº¤ç»™ç©ºé—²çº¿ç¨‹ï¼›è‹¥æ— ç©ºé—²çº¿ç¨‹ä¸”çº¿ç¨‹æ•°æœªè¾¾ä¸Šé™ï¼Œåˆ™æ–°å»ºçº¿ç¨‹ã€‚

---

## ä¸‰ã€Java çº¿ç¨‹æ± ä»£ç å®ç°ï¼šå¹¶å‘å¤„ç†ä»»åŠ¡

ä¸‹é¢æ˜¯ä¸€ä¸ªå®Œæ•´çš„ç¤ºä¾‹ï¼Œä½¿ç”¨ `ThreadPoolExecutor` å®ç°å¤šä»»åŠ¡å¹¶å‘å¤„ç†ã€‚

### âœ… åœºæ™¯è¯´æ˜ï¼š
æ¨¡æ‹Ÿå¤šä¸ªç”¨æˆ·è¯·æ±‚ä¸‹è½½æ–‡ä»¶ï¼Œæ¯ä¸ªä»»åŠ¡ç‹¬ç«‹æ‰§è¡Œã€‚

```java
import java.util.concurrent.*;
import java.util.Random;

public class ThreadPoolExample {

    public static void main(String[] args) {
        // è‡ªå®šä¹‰çº¿ç¨‹å·¥å‚ï¼Œä¾¿äºè°ƒè¯•
        ThreadFactory threadFactory = new ThreadFactory() {
            private int counter = 0;

            @Override
            public Thread newThread(Runnable r) {
                return new Thread(r, "CustomThread-" + (++counter));
            }
        };

        // æ‹’ç»ç­–ç•¥ï¼šç”±ä¸»çº¿ç¨‹æ‰§è¡Œ
        RejectedExecutionHandler handler = new ThreadPoolExecutor.CallerRunsPolicy();

        // åˆ›å»ºçº¿ç¨‹æ± 
        ThreadPoolExecutor executor = new ThreadPoolExecutor(
                2,              // corePoolSize: æ ¸å¿ƒçº¿ç¨‹æ•° 2
                4,              // maximumPoolSize: æœ€å¤§çº¿ç¨‹æ•° 4
                60L,            // keepAliveTime: éæ ¸å¿ƒçº¿ç¨‹ç©ºé—² 60 ç§’åå›æ”¶
                TimeUnit.SECONDS,// æ—¶é—´å•ä½
                new ArrayBlockingQueue10), // ä»»åŠ¡é˜Ÿåˆ—ï¼šæœ€å¤šå®¹çº³ 10 ä¸ªç­‰å¾…ä»»åŠ¡
                threadFactory,  // çº¿ç¨‹å·¥å‚
                handler         // æ‹’ç»ç­–ç•¥
        );

        // æ¨¡æ‹Ÿæäº¤ 20 ä¸ªä»»åŠ¡
        Random random = new Random();
        for (int i = 1; i <= 20; i++) {
            final int taskId = i;
            Runnable task = () -> {
                String threadName = Thread.currentThread().getName();
                System.out.println("ä»»åŠ¡ " + taskId + " æ­£åœ¨ç”±çº¿ç¨‹ " + threadName + " æ‰§è¡Œ...");

                // æ¨¡æ‹Ÿä»»åŠ¡è€—æ—¶ï¼ˆ1~3ç§’ï¼‰
                try {
                    Thread.sleep(1000 + random.nextInt(2000));
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    System.out.println("ä»»åŠ¡ " + taskId + " è¢«ä¸­æ–­");
                }

                System.out.println("ä»»åŠ¡ " + taskId + " æ‰§è¡Œå®Œæˆ");
            };

            // æäº¤ä»»åŠ¡
            executor.execute(task);
        }

        // å…³é—­çº¿ç¨‹æ± ï¼ˆä¸å†æ¥æ”¶æ–°ä»»åŠ¡ï¼Œç­‰å¾…å·²æäº¤ä»»åŠ¡å®Œæˆï¼‰
        executor.shutdown();

        // å¯é€‰ï¼šç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆï¼ˆæœ€å¤šç­‰å¾… 10 åˆ†é’Ÿï¼‰
        try {
            if (!executor.awaitTermination(10, TimeUnit.MINUTES)) {
                System.out.println("çº¿ç¨‹æ± æœªåœ¨è§„å®šæ—¶é—´å†…ç»ˆæ­¢");
            }
        } catch (InterruptedException e) {
            executor.shutdownNow();
            Thread.currentThread().interrupt();
        }

        System.out.println("æ‰€æœ‰ä»»åŠ¡å·²å¤„ç†å®Œæ¯•ï¼Œä¸»çº¿ç¨‹é€€å‡ºã€‚");
    }
}
```

---

## å››ã€è¿è¡Œç»“æœç¤ºä¾‹ï¼ˆéƒ¨åˆ†è¾“å‡ºï¼‰

```text
ä»»åŠ¡ 1 æ­£åœ¨ç”±çº¿ç¨‹ CustomThread-1 æ‰§è¡Œ...
ä»»åŠ¡ 2 æ­£åœ¨ç”±çº¿ç¨‹ CustomThread-2 æ‰§è¡Œ...
ä»»åŠ¡ 3 æ­£åœ¨ç”±çº¿ç¨‹ CustomThread-3 æ‰§è¡Œ...
ä»»åŠ¡ 4 æ­£åœ¨ç”±çº¿ç¨‹ CustomThread-4 æ‰§è¡Œ...
ä»»åŠ¡ 5 æ­£åœ¨ç”±çº¿ç¨‹ CustomThread-1 æ‰§è¡Œ...
...
ä»»åŠ¡ 1 æ‰§è¡Œå®Œæˆ
ä»»åŠ¡ 3 æ‰§è¡Œå®Œæˆ
ä»»åŠ¡ 5 æ‰§è¡Œå®Œæˆ
...
æ‰€æœ‰ä»»åŠ¡å·²å¤„ç†å®Œæ¯•ï¼Œä¸»çº¿ç¨‹é€€å‡ºã€‚
```

> è¯´æ˜ï¼šå¯ä»¥çœ‹åˆ°çº¿ç¨‹è¢«å¤ç”¨ï¼Œä»»åŠ¡å¹¶å‘æ‰§è¡Œï¼Œä½“ç°äº†çº¿ç¨‹æ± çš„ä¼˜åŠ¿ã€‚

---

## äº”ã€å¸¸è§çº¿ç¨‹æ± å·¥å…·ç±»ï¼ˆExecutorsï¼‰

Java æä¾›äº† `Executors` å·¥å…·ç±»æ¥å¿«é€Ÿåˆ›å»ºå¸¸ç”¨çº¿ç¨‹æ± ï¼Œä½†**ç”Ÿäº§ç¯å¢ƒå»ºè®®æ‰‹åŠ¨åˆ›å»º `ThreadPoolExecutor`**ï¼Œé¿å…æ½œåœ¨é£é™©ã€‚

| æ–¹æ³• | è¯´æ˜ | é£é™© |
|------|------|------|
| `newFixedThreadPool(n)` | å›ºå®šå¤§å°çº¿ç¨‹æ±  | ä½¿ç”¨æ— ç•Œé˜Ÿåˆ—ï¼Œå¯èƒ½å¯¼è‡´ OOM |
| `newCachedThreadPool()` | ç¼“å­˜çº¿ç¨‹æ± ï¼Œçº¿ç¨‹ç©ºé—² 60s å›æ”¶ | çº¿ç¨‹æ•°æ— ä¸Šé™ï¼Œå¯èƒ½åˆ›å»ºè¿‡å¤šçº¿ç¨‹ |
| `newSingleThreadExecutor()` | å•çº¿ç¨‹æ±  | é€‚åˆé¡ºåºæ‰§è¡Œä»»åŠ¡ |
| `newScheduledThreadPool(n)` | æ”¯æŒå®šæ—¶/å‘¨æœŸæ€§ä»»åŠ¡ | é€‚ç”¨äºè°ƒåº¦ä»»åŠ¡ |

> âœ… æ¨èï¼š**å§‹ç»ˆä½¿ç”¨ `ThreadPoolExecutor` æ˜¾å¼æ„é€ **ï¼Œä¾¿äºæ§åˆ¶èµ„æºã€‚

---

## å…­ã€æœ€ä½³å®è·µå»ºè®®

1. **åˆç†è®¾ç½®æ ¸å¿ƒå‚æ•°**ï¼š
   - CPU å¯†é›†å‹ä»»åŠ¡ï¼š`corePoolSize = CPU æ ¸å¿ƒæ•° + 1`
   - IO å¯†é›†å‹ä»»åŠ¡ï¼š`corePoolSize = 2 * CPU æ ¸å¿ƒæ•°` æˆ–æ›´é«˜

2. **ä½¿ç”¨æœ‰ç•Œé˜Ÿåˆ—**ï¼šé˜²æ­¢å†…å­˜æº¢å‡ºï¼ˆOOMï¼‰

3. **ç›‘æ§çº¿ç¨‹æ± çŠ¶æ€**ï¼š
   - `getActiveCount()`ï¼šå½“å‰æ´»è·ƒçº¿ç¨‹æ•°
   - `getQueue().size()`ï¼šç­‰å¾…ä»»åŠ¡æ•°
   - `getCompletedTaskCount()`ï¼šå·²å®Œæˆä»»åŠ¡æ•°

4. **ä¼˜é›…å…³é—­çº¿ç¨‹æ± **ï¼š
   - ä½¿ç”¨ `shutdown()` + `awaitTermination()`
   - é¿å… `shutdownNow()` å¼ºåˆ¶ä¸­æ–­ï¼ˆé™¤éå¿…è¦ï¼‰

5. **è®°å½•æ—¥å¿—æˆ–é›†æˆç›‘æ§ç³»ç»Ÿ**ï¼ˆå¦‚ Prometheusï¼‰

---

## ä¸ƒã€æ€»ç»“

| ç»„ä»¶ | ä½œç”¨ |
|------|------|
| `corePoolSize` | ä¿æŒçš„æœ€å°çº¿ç¨‹æ•° |
| `workQueue` | å­˜æ”¾å¾…å¤„ç†ä»»åŠ¡ |
| `maximumPoolSize` | æœ€å¤§å¯æ‰©å®¹çº¿ç¨‹æ•° |
| `keepAliveTime` | éæ ¸å¿ƒçº¿ç¨‹ç©ºé—²å­˜æ´»æ—¶é—´ |
| `RejectedExecutionHandler` | ä»»åŠ¡æ‹’ç»æ—¶çš„å¤„ç†ç­–ç•¥ |

âœ… **çº¿ç¨‹æ± æœ¬è´¨æ˜¯ä¸€ä¸ªâ€œç”Ÿäº§è€…-æ¶ˆè´¹è€…â€æ¨¡å‹**ï¼š
- ç”Ÿäº§è€…ï¼šæäº¤ä»»åŠ¡çš„çº¿ç¨‹
- æ¶ˆè´¹è€…ï¼šå·¥ä½œçº¿ç¨‹ä»é˜Ÿåˆ—å–ä»»åŠ¡æ‰§è¡Œ

é€šè¿‡åˆç†é…ç½®ï¼Œçº¿ç¨‹æ± èƒ½æœ‰æ•ˆå¹³è¡¡èµ„æºä½¿ç”¨ä¸å¹¶å‘æ€§èƒ½ï¼Œæ˜¯é«˜å¹¶å‘ç³»ç»Ÿçš„åŸºçŸ³ã€‚

---

ğŸ“Œ **ç»“è¯­**ï¼šæŒæ¡çº¿ç¨‹æ± çš„åŸç†ä¸ä½¿ç”¨ï¼Œæ˜¯ Java å·¥ç¨‹å¸ˆè¿›é˜¶çš„å¿…ç»ä¹‹è·¯ã€‚å»ºè®®åœ¨å®é™…é¡¹ç›®ä¸­ç»“åˆç›‘æ§ã€æ—¥å¿—å’Œå‹æµ‹ä¸æ–­ä¼˜åŒ–çº¿ç¨‹æ± å‚æ•°ã€‚
