# Spring MVC 工作原理详解

Spring MVC 是基于 Java 实现 MVC 设计模式的请求驱动类型的轻量级 Web 框架，通过把 Model、View、Controller 分离，实现 Web 应用的解耦和高效开发。

## Spring MVC 核心架构

### 1. 整体请求处理流程

```
客户端请求 → DispatcherServlet → HandlerMapping → Controller → ModelAndView → ViewResolver → 视图渲染 → 响应客户端
```

## 核心组件详解

### 1. DispatcherServlet - 前端控制器

```java
// web.xml 配置方式
public class WebInitializer implements WebApplicationInitializer {
    @Override
    public void onStartup(ServletContext servletContext) {
        // 注册 DispatcherServlet
        AnnotationConfigWebApplicationContext context = new AnnotationConfigWebApplicationContext();
        context.register(AppConfig.class);
        
        DispatcherServlet servlet = new DispatcherServlet(context);
        ServletRegistration.Dynamic registration = servletContext.addServlet("app", servlet);
        registration.setLoadOnStartup(1);
        registration.addMapping("/");
    }
}

// Java Config 配置方式
public class WebMvcConfig implements WebMvcConfigurer {
    
    @Override
    public void configureViewResolvers(ViewResolverRegistry registry) {
        registry.jsp("/WEB-INF/views/", ".jsp");
    }
    
    @Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) {
        registry.addResourceHandler("/resources/**")
                .addResourceLocations("/static/");
    }
}
```

### 2. HandlerMapping - 处理器映射

```java
@Configuration
public class HandlerMappingExample {
    
    // Spring MVC 内置的 HandlerMapping:
    // 1. RequestMappingHandlerMapping - 处理 @RequestMapping
    // 2. BeanNameUrlHandlerMapping - 根据 Bean 名称映射
    // 3. SimpleUrlHandlerMapping - 简单 URL 映射
    
    @Bean
    public SimpleUrlHandlerMapping customHandlerMapping() {
        SimpleUrlHandlerMapping mapping = new SimpleUrlHandlerMapping();
        Map<String, Object> urlMap = new HashMap<>();
        urlMap.put("/legacy/**", legacyController());
        mapping.setUrlMap(urlMap);
        mapping.setOrder(1); // 设置优先级
        return mapping;
    }
    
    @Bean
    public Controller legacyController() {
        return new LegacyController();
    }
}
```

### 3. HandlerAdapter - 处理器适配器

```java
// Spring MVC 内置的 HandlerAdapter:
// 1. RequestMappingHandlerAdapter - 处理 @Controller
// 2. SimpleControllerHandlerAdapter - 处理 Controller 接口
// 3. HttpRequestHandlerAdapter - 处理 HttpRequestHandler 接口

@Component
public class CustomHandlerAdapter implements HandlerAdapter {
    
    @Override
    public boolean supports(Object handler) {
        return handler instanceof CustomController;
    }
    
    @Override
    public ModelAndView handle(HttpServletRequest request, 
                             HttpServletResponse response, 
                             Object handler) throws Exception {
        CustomController controller = (CustomController) handler;
        return controller.processRequest(request, response);
    }
    
    @Override
    public long getLastModified(HttpServletRequest request, Object handler) {
        return -1;
    }
}
```

## 详细请求处理流程

### 1. 完整请求处理序列

```java
// DispatcherServlet 的核心处理流程
public class DispatcherServletProcess {
    
    protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {
        HttpServletRequest processedRequest = request;
        HandlerExecutionChain mappedHandler = null;
        ModelAndView mv = null;
        Exception dispatchException = null;
        
        try {
            // 1. 检查是否是文件上传请求
            processedRequest = checkMultipart(request);
            
            // 2. 确定处理当前请求的处理器
            mappedHandler = getHandler(processedRequest);
            if (mappedHandler == null) {
                noHandlerFound(processedRequest, response);
                return;
            }
            
            // 3. 获取处理器适配器
            HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());
            
            // 4. 执行处理器拦截器的 preHandle()
            if (!mappedHandler.applyPreHandle(processedRequest, response)) {
                return;
            }
            
            // 5. 实际处理器执行，返回 ModelAndView
            mv = ha.handle(processedRequest, response, mappedHandler.getHandler());
            
            // 6. 设置默认视图名
            applyDefaultViewName(processedRequest, mv);
            
            // 7. 执行处理器拦截器的 postHandle()
            mappedHandler.applyPostHandle(processedRequest, response, mv);
            
        } catch (Exception ex) {
            dispatchException = ex;
        }
        
        // 8. 处理分发结果，进行视图渲染
        processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);
    }
    
    private void processDispatchResult(HttpServletRequest request, 
                                     HttpServletResponse response,
                                     HandlerExecutionChain mappedHandler, 
                                     ModelAndView mv,
                                     Exception exception) throws Exception {
        
        // 处理异常
        if (exception != null) {
            mv = processHandlerException(request, response, mappedHandler, exception);
        }
        
        // 渲染视图
        if (mv != null && !mv.wasCleared()) {
            render(mv, request, response);
            // 清理请求属性
            request.removeAttribute(WebUtils.INCLUDE_REQUEST_URI_ATTRIBUTE);
        }
        
        // 触发拦截器的 afterCompletion()
        if (mappedHandler != null) {
            mappedHandler.triggerAfterCompletion(request, response, null);
        }
    }
}
```

## 控制器详解

### 1. 基于注解的控制器

```java
@Controller
@RequestMapping("/users")
public class UserController {
    
    private final UserService userService;
    
    public UserController(UserService userService) {
        this.userService = userService;
    }
    
    // GET 请求处理
    @GetMapping
    public String listUsers(Model model) {
        List<User> users = userService.findAll();
        model.addAttribute("users", users);
        return "users/list";
    }
    
    // 路径变量
    @GetMapping("/{id}")
    public String getUser(@PathVariable Long id, Model model) {
        User user = userService.findById(id);
        model.addAttribute("user", user);
        return "users/detail";
    }
    
    // 表单提交
    @PostMapping
    public String createUser(@Valid UserForm form, 
                           BindingResult result,
                           RedirectAttributes redirectAttributes) {
        if (result.hasErrors()) {
            return "users/create";
        }
        
        User user = userService.createUser(form);
        redirectAttributes.addFlashAttribute("message", "用户创建成功");
        return "redirect:/users/" + user.getId();
    }
    
    // JSON API
    @GetMapping("/api/{id}")
    @ResponseBody
    public ResponseEntity<User> getUserApi(@PathVariable Long id) {
        return userService.findById(id)
                .map(user -> ResponseEntity.ok(user))
                .orElse(ResponseEntity.notFound().build());
    }
    
    // 文件上传
    @PostMapping("/{id}/avatar")
    public String uploadAvatar(@PathVariable Long id,
                             @RequestParam("file") MultipartFile file) {
        if (!file.isEmpty()) {
            userService.saveAvatar(id, file);
        }
        return "redirect:/users/" + id;
    }
    
    // 异常处理
    @ExceptionHandler(UserNotFoundException.class)
    public ResponseEntity<String> handleUserNotFound(UserNotFoundException ex) {
        return ResponseEntity.status(HttpStatus.NOT_FOUND)
                .body(ex.getMessage());
    }
}
```

### 2. 方法参数解析

```java
@Controller
public class ParameterResolutionController {
    
    // 1. 请求参数
    @GetMapping("/search")
    public String search(@RequestParam String keyword,
                        @RequestParam(defaultValue = "1") int page,
                        @RequestParam(required = false) String sort) {
        // 处理搜索逻辑
        return "search/results";
    }
    
    // 2. 请求头
    @GetMapping("/info")
    public String getInfo(@RequestHeader("User-Agent") String userAgent,
                         @RequestHeader(value = "X-Custom-Header", required = false) String customHeader) {
        return "info";
    }
    
    // 3. Cookie 值
    @GetMapping("/preferences")
    public String getPreferences(@CookieValue("theme") String theme) {
        return "preferences";
    }
    
    // 4. 会话属性
    @PostMapping("/cart")
    public String addToCart(@SessionAttribute("cart") ShoppingCart cart,
                           @ModelAttribute Product product) {
        cart.addProduct(product);
        return "redirect:/cart";
    }
    
    // 5. 请求体
    @PostMapping("/api/users")
    @ResponseBody
    public User createUser(@RequestBody @Valid User user) {
        return userService.save(user);
    }
    
    // 6. 矩阵变量
    @GetMapping("/products/{category}")
    public String filterProducts(@MatrixVariable Map<String, String> filters) {
        // 处理矩阵参数
        return "products/filtered";
    }
}
```

## 视图解析和渲染

### 1. 视图解析器配置

```java
@Configuration
@EnableWebMvc
public class ViewResolverConfig implements WebMvcConfigurer {
    
    @Override
    public void configureViewResolvers(ViewResolverRegistry registry) {
        // JSP 视图解析器
        registry.jsp("/WEB-INF/views/", ".jsp");
        
        // Thymeleaf 视图解析器
        registry.viewResolver(thymeleafViewResolver());
        
        // JSON 视图解析器
        registry.enableContentNegotiation(new MappingJackson2JsonView());
    }
    
    @Bean
    public ThymeleafViewResolver thymeleafViewResolver() {
        ThymeleafViewResolver resolver = new ThymeleafViewResolver();
        resolver.setTemplateEngine(templateEngine());
        resolver.setCharacterEncoding("UTF-8");
        return resolver;
    }
    
    @Bean
    public SpringTemplateEngine templateEngine() {
        SpringTemplateEngine engine = new SpringTemplateEngine();
        engine.setTemplateResolver(templateResolver());
        return engine;
    }
    
    private ITemplateResolver templateResolver() {
        SpringResourceTemplateResolver resolver = new SpringResourceTemplateResolver();
        resolver.setPrefix("classpath:/templates/");
        resolver.setSuffix(".html");
        resolver.setTemplateMode(TemplateMode.HTML);
        return resolver;
    }
}
```

### 2. 视图技术集成

```java
@Controller
public class ViewController {
    
    // 1. JSP 视图
    @GetMapping("/jsp-view")
    public String jspView(Model model) {
        model.addAttribute("message", "Hello JSP");
        return "hello"; // 解析为 /WEB-INF/views/hello.jsp
    }
    
    // 2. Thymeleaf 视图
    @GetMapping("/thymeleaf-view")
    public String thymeleafView(Model model) {
        model.addAttribute("users", userService.findAll());
        return "users/list"; // 解析为 classpath:/templates/users/list.html
    }
    
    // 3. JSON 响应
    @GetMapping("/api/data")
    @ResponseBody
    public Map<String, Object> jsonData() {
        Map<String, Object> data = new HashMap<>();
        data.put("timestamp", System.currentTimeMillis());
        data.put("status", "success");
        return data;
    }
    
    // 4. 重定向
    @PostMapping("/process")
    public String processForm(FormData form) {
        // 处理表单数据
        return "redirect:/result"; // 重定向到 /result
    }
    
    // 5. 转发
    @GetMapping("/forward")
    public String forwardExample() {
        return "forward:/internal/endpoint"; // 转发到内部端点
    }
}
```

## 拦截器机制

### 1. 自定义拦截器

```java
@Component
public class LoggingInterceptor implements HandlerInterceptor {
    
    private static final Logger logger = LoggerFactory.getLogger(LoggingInterceptor.class);
    
    @Override
    public boolean preHandle(HttpServletRequest request, 
                           HttpServletResponse response, 
                           Object handler) throws Exception {
        long startTime = System.currentTimeMillis();
        request.setAttribute("startTime", startTime);
        
        logger.info("请求开始: {} {}", request.getMethod(), request.getRequestURI());
        
        // 身份验证检查
        if (!isAuthenticated(request)) {
            response.sendRedirect("/login");
            return false; // 中断请求处理
        }
        
        return true; // 继续处理
    }
    
    @Override
    public void postHandle(HttpServletRequest request, 
                         HttpServletResponse response, 
                         Object handler,
                         ModelAndView modelAndView) throws Exception {
        long startTime = (Long) request.getAttribute("startTime");
        long endTime = System.currentTimeMillis();
        long executionTime = endTime - startTime;
        
        logger.info("请求处理完成: {} {}, 耗时: {}ms", 
                   request.getMethod(), request.getRequestURI(), executionTime);
        
        if (modelAndView != null) {
            modelAndView.addObject("executionTime", executionTime);
        }
    }
    
    @Override
    public void afterCompletion(HttpServletRequest request, 
                              HttpServletResponse response, 
                              Object handler, 
                              Exception ex) throws Exception {
        if (ex != null) {
            logger.error("请求处理异常: {} {}", request.getMethod(), request.getRequestURI(), ex);
        }
        
        logger.info("请求完成: {} {}, 状态: {}", 
                   request.getMethod(), request.getRequestURI(), response.getStatus());
    }
    
    private boolean isAuthenticated(HttpServletRequest request) {
        // 实现身份验证逻辑
        return request.getSession().getAttribute("user") != null;
    }
}

// 注册拦截器
@Configuration
public class InterceptorConfig implements WebMvcConfigurer {
    
    @Autowired
    private LoggingInterceptor loggingInterceptor;
    
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(loggingInterceptor)
                .addPathPatterns("/**")
                .excludePathPatterns("/login", "/static/**", "/public/**");
        
        // 添加更多拦截器
        registry.addInterceptor(new CacheInterceptor())
                .addPathPatterns("/api/**");
    }
}
```

## 异常处理机制

### 1. 全局异常处理

```java
@ControllerAdvice
public class GlobalExceptionHandler {
    
    private static final Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler.class);
    
    // 处理业务异常
    @ExceptionHandler(BusinessException.class)
    public ResponseEntity<ErrorResponse> handleBusinessException(BusinessException ex) {
        ErrorResponse error = new ErrorResponse("BUSINESS_ERROR", ex.getMessage());
        return ResponseEntity.badRequest().body(error);
    }
    
    // 处理资源不存在异常
    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<ErrorResponse> handleResourceNotFound(ResourceNotFoundException ex) {
        ErrorResponse error = new ErrorResponse("NOT_FOUND", ex.getMessage());
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(error);
    }
    
    // 处理数据验证异常
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorResponse> handleValidationException(MethodArgumentNotValidException ex) {
        List<String> errors = ex.getBindingResult()
                .getFieldErrors()
                .stream()
                .map(error -> error.getField() + ": " + error.getDefaultMessage())
                .collect(Collectors.toList());
        
        ErrorResponse error = new ErrorResponse("VALIDATION_ERROR", "数据验证失败", errors);
        return ResponseEntity.badRequest().body(error);
    }
    
    // 处理所有未捕获的异常
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleGenericException(Exception ex) {
        logger.error("未处理的异常", ex);
        
        ErrorResponse error = new ErrorResponse("INTERNAL_ERROR", "服务器内部错误");
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(error);
    }
    
    // 错误响应类
    @Data
    @AllArgsConstructor
    public static class ErrorResponse {
        private String code;
        private String message;
        private List<String> details;
        
        public ErrorResponse(String code, String message) {
            this.code = code;
            this.message = message;
        }
    }
}
```

## 数据绑定和验证

### 1. 表单处理和验证

```java
@Data
public class UserForm {
    @NotBlank(message = "用户名不能为空")
    @Size(min = 3, max = 20, message = "用户名长度必须在3-20个字符之间")
    private String username;
    
    @Email(message = "邮箱格式不正确")
    @NotBlank(message = "邮箱不能为空")
    private String email;
    
    @Pattern(regexp = "^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d).{8,}$", 
             message = "密码必须包含大小写字母和数字，且长度至少8位")
    private String password;
    
    @DateTimeFormat(pattern = "yyyy-MM-dd")
    @Past(message = "生日必须是过去的时间")
    private LocalDate birthday;
}

@Controller
@RequestMapping("/register")
public class RegistrationController {
    
    @GetMapping
    public String showForm(Model model) {
        model.addAttribute("userForm", new UserForm());
        return "register/form";
    }
    
    @PostMapping
    public String submitForm(@Valid @ModelAttribute UserForm userForm,
                           BindingResult result,
                           RedirectAttributes redirectAttributes) {
        
        // 自定义验证逻辑
        if (userService.existsByUsername(userForm.getUsername())) {
            result.rejectValue("username", "duplicate", "用户名已存在");
        }
        
        if (result.hasErrors()) {
            return "register/form";
        }
        
        // 保存用户
        User user = userService.register(userForm);
        redirectAttributes.addFlashAttribute("success", "注册成功！");
        return "redirect:/login";
    }
}
```

## 异步处理

### 1. 异步请求处理

```java
@RestController
public class AsyncController {
    
    @GetMapping("/async-data")
    public Callable<String> getAsyncData() {
        return () -> {
            // 模拟长时间运行的任务
            Thread.sleep(3000);
            return "异步处理完成: " + System.currentTimeMillis();
        };
    }
    
    @GetMapping("/deferred-result")
    public DeferredResult<ResponseEntity<String>> getDeferredResult() {
        DeferredResult<ResponseEntity<String>> deferredResult = new DeferredResult<>();
        
        CompletableFuture.supplyAsync(() -> {
            // 异步处理
            try {
                Thread.sleep(2000);
                return "处理结果";
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        }).whenComplete((result, throwable) -> {
            if (throwable != null) {
                deferredResult.setErrorResult(throwable);
            } else {
                deferredResult.setResult(ResponseEntity.ok(result));
            }
        });
        
        return deferredResult;
    }
}
```

## Spring MVC 配置最佳实践

### 1. 完整配置示例

```java
@Configuration
@EnableWebMvc
@ComponentScan("com.example.web")
public class WebMvcConfig implements WebMvcConfigurer {
    
    // 静态资源处理
    @Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) {
        registry.addResourceHandler("/static/**")
                .addResourceLocations("classpath:/static/")
                .setCachePeriod(3600);
    }
    
    // 视图解析器
    @Override
    public void configureViewResolvers(ViewResolverRegistry registry) {
        registry.jsp("/WEB-INF/views/", ".jsp");
    }
    
    // 消息转换器
    @Override
    public void configureMessageConverters(List<HttpMessageConverter<?>> converters) {
        converters.add(new MappingJackson2HttpMessageConverter());
        converters.add(new StringHttpMessageConverter(StandardCharsets.UTF_8));
    }
    
    // 跨域配置
    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/api/**")
                .allowedOrigins("http://localhost:3000")
                .allowedMethods("GET", "POST", "PUT", "DELETE")
                .allowCredentials(true);
    }
    
    // 格式化
    @Override
    public void addFormatters(FormatterRegistry registry) {
        registry.addFormatter(new DateFormatter("yyyy-MM-dd"));
    }
    
    // 路径匹配配置
    @Override
    public void configurePathMatch(PathMatchConfigurer configurer) {
        configurer.setUseTrailingSlashMatch(true);
        configurer.setUseRegisteredSuffixPatternMatch(true);
    }
}
```

## 总结

Spring MVC 的工作原理可以概括为：

1. **请求接收**：DispatcherServlet 作为前端控制器接收所有请求
2. **处理器映射**：通过 HandlerMapping 找到对应的处理器
3. **处理器适配**：通过 HandlerAdapter 执行处理器方法
4. **视图解析**：通过 ViewResolver 解析视图名称
5. **视图渲染**：将模型数据渲染到视图并返回响应

关键特性包括：
- 灵活的 URL 映射
- 强大的数据绑定和验证
- 多种视图技术支持
- 拦截器机制
- 全局异常处理
- 异步处理支持
- RESTful Web 服务支持

通过深入理解 Spring MVC 的工作原理，可以更好地进行 Web 应用开发和技术问题排查。
