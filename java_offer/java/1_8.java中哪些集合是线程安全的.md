# 以前

**Vector/Hashtable/Stack**:早期JDK中的同步实现(通过给所有方法加synchronized锁),但性能较差

# 现在
在Java中，线程安全的集合主要分为以下几类：

## 1. java.util.concurrent 包中的线程安全集合

### ConcurrentHashMap
```java
// 高并发场景下的Map实现
ConcurrentHashMap<String, Integer> map = new ConcurrentHashMap<>();
map.put("key1", 1);
map.putIfAbsent("key2", 2); // 原子操作

// 线程安全的遍历
map.forEach((k, v) -> System.out.println(k + ": " + v));
```

### CopyOnWriteArrayList
```java
// 读多写少的List，写操作会复制整个数组
CopyOnWriteArrayList<String> list = new CopyOnWriteArrayList<>();
list.add("item1");
list.addIfAbsent("item2"); // 原子操作

// 遍历时不需要同步，因为遍历的是快照
for (String item : list) {
    System.out.println(item);
}
```

### CopyOnWriteArraySet
```java
// 基于CopyOnWriteArrayList的Set实现
CopyOnWriteArraySet<String> set = new CopyOnWriteArraySet<>();
set.add("element1");
set.add("element2");
```

### ConcurrentLinkedQueue
```java
// 无锁的线程安全队列
ConcurrentLinkedQueue<String> queue = new ConcurrentLinkedQueue<>();
queue.offer("task1");
queue.offer("task2");
String task = queue.poll(); // 非阻塞获取
```

### ConcurrentLinkedDeque
```java
// 双向并发队列
ConcurrentLinkedDeque<String> deque = new ConcurrentLinkedDeque<>();
deque.addFirst("first");
deque.addLast("last");
```

### ConcurrentSkipListMap
```java
// 并发的有序Map
ConcurrentSkipListMap<Integer, String> sortedMap = new ConcurrentSkipListMap<>();
sortedMap.put(3, "three");
sortedMap.put(1, "one");
sortedMap.put(2, "two");
```

### ConcurrentSkipListSet
```java
// 并发的有序Set
ConcurrentSkipListSet<Integer> sortedSet = new ConcurrentSkipListSet<>();
sortedSet.add(3);
sortedSet.add(1);
sortedSet.add(2);
```

## 2. 阻塞队列（Blocking Queues）

### ArrayBlockingQueue
```java
// 有界阻塞队列
ArrayBlockingQueue<String> queue = new ArrayBlockingQueue<>(100);
queue.put("item"); // 阻塞插入
String item = queue.take(); // 阻塞获取
```

### LinkedBlockingQueue
```java
// 可选的边界阻塞队列
LinkedBlockingQueue<String> queue = new LinkedBlockingQueue<>(100);
// 或无界
LinkedBlockingQueue<String> unboundedQueue = new LinkedBlockingQueue<>();
```

### PriorityBlockingQueue
```java
// 带优先级的阻塞队列
PriorityBlockingQueue<Integer> priorityQueue = new PriorityBlockingQueue<>();
priorityQueue.put(5);
priorityQueue.put(1);
priorityQueue.put(3); // 按优先级顺序取出
```

### SynchronousQueue
```java
// 直接传递的队列，每个插入操作必须等待对应的移除操作
SynchronousQueue<String> syncQueue = new SynchronousQueue<>();
// 生产者线程
new Thread(() -> {
    try {
        syncQueue.put("data");
    } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
    }
}).start();

// 消费者线程
new Thread(() -> {
    try {
        String data = syncQueue.take();
        System.out.println("Received: " + data);
    } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
    }
}).start();
```

### DelayQueue
```java
// 延迟队列，元素只有在延迟期满时才能被取出
class DelayedTask implements Delayed {
    private final String name;
    private final long startTime;
    
    public DelayedTask(String name, long delayInMillis) {
        this.name = name;
        this.startTime = System.currentTimeMillis() + delayInMillis;
    }
    
    @Override
    public long getDelay(TimeUnit unit) {
        long diff = startTime - System.currentTimeMillis();
        return unit.convert(diff, TimeUnit.MILLISECONDS);
    }
    
    @Override
    public int compareTo(Delayed o) {
        return Long.compare(this.startTime, ((DelayedTask) o).startTime);
    }
}

DelayQueue<DelayedTask> delayQueue = new DelayQueue<>();
delayQueue.put(new DelayedTask("task1", 5000)); // 5秒后可用
```

### LinkedTransferQueue
```java
// 传输队列，结合了ConcurrentLinkedQueue、SynchronousQueue和LinkedBlockingQueue的特性
LinkedTransferQueue<String> transferQueue = new LinkedTransferQueue<>();
```

## 3. 使用Collections工具类包装的同步集合

```java
// 同步List
List<String> syncList = Collections.synchronizedList(new ArrayList<>());

// 同步Set
Set<String> syncSet = Collections.synchronizedSet(new HashSet<>());

// 同步Map
Map<String, Integer> syncMap = Collections.synchronizedMap(new HashMap<>());

// 使用示例
List<String> list = Collections.synchronizedList(new ArrayList<>());
// 遍历时需要手动同步
synchronized (list) {
    Iterator<String> it = list.iterator();
    while (it.hasNext()) {
        System.out.println(it.next());
    }
}
```

## 4. 线程安全集合的性能比较

| 集合类型 | 适用场景 | 特点 | 性能 |
|---------|----------|------|------|
| ConcurrentHashMap | 高并发Map | 分段锁，支持并发读写 | 高 |
| CopyOnWriteArrayList | 读多写少List | 写时复制，读无锁 | 读高写低 |
| ConcurrentLinkedQueue | 高并发队列 | 无锁算法 | 很高 |
| ArrayBlockingQueue | 生产者消费者 | 有界，阻塞操作 | 中等 |
| synchronizedList | 一般并发 | 全表锁 | 较低 |

## 5. 使用示例和最佳实践

### 正确的复合操作
```java
public class ThreadSafeCollectionExample {
    private final ConcurrentHashMap<String, AtomicInteger> counterMap = 
        new ConcurrentHashMap<>();
    
    // 正确的计数方式
    public void increment(String key) {
        counterMap.computeIfAbsent(key, k -> new AtomicInteger()).incrementAndGet();
    }
    
    // 错误的用法：即使使用ConcurrentHashMap，复合操作也需要原子性
    public void unsafeIncrement(String key) {
        Integer count = counterMap.get(key);
        if (count == null) {
            counterMap.put(key, 1); // 这里可能有竞态条件
        } else {
            counterMap.put(key, count + 1);
        }
    }
}
```

### 选择合适的阻塞队列
```java
public class ProducerConsumer {
    private final BlockingQueue<String> queue = new ArrayBlockingQueue<>(100);
    
    public void produce(String item) throws InterruptedException {
        queue.put(item); // 队列满时会阻塞
    }
    
    public String consume() throws InterruptedException {
        return queue.take(); // 队列空时会阻塞
    }
}
```

## 6. 注意事项

1. **迭代器的弱一致性**：大多数并发集合的迭代器是弱一致的，反映创建时的状态
2. **复合操作**：即使集合本身线程安全，复合操作也需要额外同步
3. **null值限制**：ConcurrentHashMap不允许null键和null值
4. **性能考量**：根据读写比例选择合适的并发集合

Java的并发集合提供了高效的线程安全实现，在选择时应根据具体的并发需求、性能要求和功能特性来做出合适的选择。
