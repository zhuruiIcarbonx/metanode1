# Java 接口与抽象类的区别详解

## 基本概念

### 1. 抽象类 (Abstract Class)

```java
// 抽象类定义
public abstract class Animal {
    // 实例变量
    protected String name;
    protected int age;
    
    // 构造方法
    public Animal(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    // 具体方法 - 有实现
    public void eat() {
        System.out.println(name + "正在吃东西...");
    }
    
    public void sleep() {
        System.out.println(name + "正在睡觉...");
    }
    
    // 抽象方法 - 无实现，必须由子类实现
    public abstract void makeSound();
    
    // 抽象方法 - 无实现
    public abstract void move();
    
    // 具体方法
    public void displayInfo() {
        System.out.println("名称: " + name + ", 年龄: " + age + "岁");
    }
}

// 继承抽象类
public class Dog extends Animal {
    private String breed;
    
    public Dog(String name, int age, String breed) {
        super(name, age); // 调用父类构造方法
        this.breed = breed;
    }
    
    // 必须实现所有抽象方法
    @Override
    public void makeSound() {
        System.out.println(name + "汪汪叫!");
    }
    
    @Override
    public void move() {
        System.out.println(name + "用四条腿跑动");
    }
    
    // 可以添加自己的方法
    public void fetch() {
        System.out.println(name + "正在接飞盘");
    }
}

// 使用示例
public class AbstractClassExample {
    public static void main(String[] args) {
        Animal dog = new Dog("小黑", 3, "金毛");
        dog.eat();       // 继承的具体方法
        dog.makeSound(); // 实现的抽象方法
        dog.displayInfo(); // 继承的具体方法
        
        // 不能实例化抽象类
        // Animal animal = new Animal(); // 编译错误
    }
}
```

### 2. 接口 (Interface)

```java
// 接口定义 - Java 8 之前
public interface Flyable {
    // 常量 (默认 public static final)
    int MAX_HEIGHT = 10000;
    
    // 抽象方法 (默认 public abstract)
    void fly();
    
    void land();
}

// 接口定义 - Java 8 及以后
public interface AdvancedFlyable extends Flyable {
    // 默认方法 - 有实现
    default void takeOff() {
        System.out.println("默认起飞方式");
    }
    
    // 静态方法
    static void showMaxHeight() {
        System.out.println("最大飞行高度: " + MAX_HEIGHT + "米");
    }
    
    // 私有方法 (Java 9+)
    private void logFlight(String action) {
        System.out.println("飞行日志: " + action);
    }
    
    default void takeOffWithLog() {
        logFlight("起飞");
        takeOff();
    }
}

// 实现接口
public class Bird implements AdvancedFlyable {
    private String species;
    
    public Bird(String species) {
        this.species = species;
    }
    
    @Override
    public void fly() {
        System.out.println(species + "在天空中飞翔");
    }
    
    @Override
    public void land() {
        System.out.println(species + "降落在树枝上");
    }
    
    // 可以选择重写默认方法
    @Override
    public void takeOff() {
        System.out.println(species + "从地面振翅起飞");
    }
}

// 实现多个接口
public interface Swimmable {
    void swim();
    void dive();
}

public class Duck implements AdvancedFlyable, Swimmable {
    @Override
    public void fly() {
        System.out.println("鸭子低空飞行");
    }
    
    @Override
    public void land() {
        System.out.println("鸭子降落在水面上");
    }
    
    @Override
    public void swim() {
        System.out.println("鸭子在水中游泳");
    }
    
    @Override
    public void dive() {
        System.out.println("鸭子潜入水中");
    }
}

// 使用示例
public class InterfaceExample {
    public static void main(String[] args) {
        AdvancedFlyable bird = new Bird("鸽子");
        bird.fly();
        bird.takeOff();
        bird.land();
        
        // 调用接口静态方法
        AdvancedFlyable.showMaxHeight();
        
        // 多接口实现
        Duck duck = new Duck();
        duck.fly();
        duck.swim();
        
        // 多态
        Swimmable swimmable = duck;
        swimmable.swim();
    }
}
```

## 核心区别对比

### 1. 语法层面的区别

| 特性 | 抽象类 | 接口 |
|------|--------|------|
| 定义关键字 | `abstract class` | `interface` |
| 继承/实现 | `extends` | `implements` |
| 构造方法 | 可以有 | 不能有 |
| 方法实现 | 可以有具体方法和抽象方法 | Java 8前只能有抽象方法，Java 8+可以有默认方法 |
| 字段 | 可以有实例变量和静态变量 | 只能有常量 (public static final) |
| 多继承 | 单继承 | 多实现 |

```java
// 语法区别示例
public class SyntaxComparison {
    // 抽象类示例
    abstract class AbstractExample {
        // 实例变量
        private int instanceVar;
        
        // 静态变量
        protected static String staticVar = "抽象类静态变量";
        
        // 构造方法
        public AbstractExample(int instanceVar) {
            this.instanceVar = instanceVar;
        }
        
        // 具体方法
        public void concreteMethod() {
            System.out.println("具体方法实现");
        }
        
        // 抽象方法
        public abstract void abstractMethod();
    }
    
    // 接口示例
    interface InterfaceExample {
        // 常量 (隐式 public static final)
        String CONSTANT = "接口常量";
        
        // 抽象方法 (隐式 public abstract)
        void abstractMethod();
        
        // 默认方法 (Java 8+)
        default void defaultMethod() {
            System.out.println("默认方法实现");
        }
        
        // 静态方法 (Java 8+)
        static void staticMethod() {
            System.out.println("接口静态方法");
        }
        
        // 私有方法 (Java 9+)
        private void privateMethod() {
            System.out.println("私有方法");
        }
    }
}
```

### 2. 设计层面的区别

```java
// 抽象类 - 表示 "is-a" 关系，代码复用
abstract class Vehicle {
    protected String brand;
    protected int speed;
    
    public Vehicle(String brand) {
        this.brand = brand;
        this.speed = 0;
    }
    
    // 所有交通工具共有的行为
    public void start() {
        System.out.println(brand + "启动");
    }
    
    public void stop() {
        this.speed = 0;
        System.out.println(brand + "停止");
    }
    
    // 子类必须实现的特定行为
    public abstract void accelerate();
    public abstract void brake();
    
    // 模板方法模式 - 使用抽象类的最佳场景
    public final void drive() { // final 防止子类修改流程
        start();
        accelerate();
        System.out.println("行驶中...");
        brake();
        stop();
    }
}

class Car extends Vehicle {
    public Car(String brand) {
        super(brand);
    }
    
    @Override
    public void accelerate() {
        speed += 20;
        System.out.println(brand + "汽车加速到" + speed + "km/h");
    }
    
    @Override
    public void brake() {
        speed -= 15;
        System.out.println(brand + "汽车刹车，速度降至" + speed + "km/h");
    }
}

// 接口 - 表示能力/契约，定义行为
interface Electric {
    void charge();
    int getBatteryLevel();
}

interface Autonomous {
    void selfDrive();
    void autoPark();
}

interface Connectable {
    void connectToInternet();
    void updateSoftware();
}

// 类可以实现多个接口，获得多种能力
class Tesla extends Vehicle implements Electric, Autonomous, Connectable {
    private int batteryLevel;
    
    public Tesla() {
        super("Tesla");
        this.batteryLevel = 100;
    }
    
    @Override
    public void accelerate() {
        speed += 30;
        System.out.println("特斯拉电动加速到" + speed + "km/h");
        batteryLevel -= 2;
    }
    
    @Override
    public void brake() {
        speed -= 10;
        System.out.println("特斯拉能量回收刹车");
        batteryLevel += 1; // 能量回收
    }
    
    // Electric 接口实现
    @Override
    public void charge() {
        batteryLevel = 100;
        System.out.println("特斯拉充电完成");
    }
    
    @Override
    public int getBatteryLevel() {
        return batteryLevel;
    }
    
    // Autonomous 接口实现
    @Override
    public void selfDrive() {
        System.out.println("特斯拉自动驾驶模式启动");
    }
    
    @Override
    public void autoPark() {
        System.out.println("特斯拉自动泊车中...");
    }
    
    // Connectable 接口实现
    @Override
    public void connectToInternet() {
        System.out.println("特斯拉连接到互联网");
    }
    
    @Override
    public void updateSoftware() {
        System.out.println("特斯拉软件更新完成");
    }
}
```

### 3. 实际应用场景对比

```java
// 场景1：抽象类适合定义框架和模板
abstract class DataProcessor {
    // 模板方法 - 定义算法骨架
    public final void process() {
        validateData();
        transformData();
        saveData();
        cleanup();
    }
    
    protected void validateData() {
        System.out.println("基础数据验证");
    }
    
    // 抽象方法 - 子类必须实现
    protected abstract void transformData();
    
    protected void saveData() {
        System.out.println("保存数据到数据库");
    }
    
    protected void cleanup() {
        System.out.println("清理临时数据");
    }
}

class CsvDataProcessor extends DataProcessor {
    @Override
    protected void transformData() {
        System.out.println("转换CSV数据");
    }
    
    @Override
    protected void saveData() {
        System.out.println("保存CSV数据到文件系统");
    }
}

class JsonDataProcessor extends DataProcessor {
    @Override
    protected void transformData() {
        System.out.println("转换JSON数据");
    }
    
    @Override
    protected void validateData() {
        super.validateData();
        System.out.println("额外的JSON数据验证");
    }
}

// 场景2：接口适合定义契约和能力
interface Logger {
    void log(String message);
    void error(String message);
    void warn(String message);
    
    // 默认方法提供通用实现
    default void log(String message, Throwable throwable) {
        log(message + ": " + throwable.getMessage());
    }
}

interface Metrics {
    void incrementCounter(String name);
    void recordTimer(String name, long duration);
}

// 多个类可以实现相同的接口
class FileLogger implements Logger {
    @Override
    public void log(String message) {
        System.out.println("文件日志: " + message);
    }
    
    @Override
    public void error(String message) {
        System.out.println("文件错误: " + message);
    }
    
    @Override
    public void warn(String message) {
        System.out.println("文件警告: " + message);
    }
}

class ConsoleLogger implements Logger, Metrics {
    @Override
    public void log(String message) {
        System.out.println("控制台日志: " + message);
    }
    
    @Override
    public void error(String message) {
        System.out.println("控制台错误: " + message);
    }
    
    @Override
    public void warn(String message) {
        System.out.println("控制台警告: " + message);
    }
    
    @Override
    public void incrementCounter(String name) {
        System.out.println("计数器增加: " + name);
    }
    
    @Override
    public void recordTimer(String name, long duration) {
        System.out.println("计时记录: " + name + " - " + duration + "ms");
    }
}
```

## 选择指南

### 1. 何时使用抽象类

```java
// 情况1：需要在相关的类之间共享代码
abstract class Shape {
    protected String color;
    protected boolean filled;
    
    public Shape(String color, boolean filled) {
        this.color = color;
        this.filled = filled;
    }
    
    // 公共方法
    public String getColor() { return color; }
    public void setColor(String color) { this.color = color; }
    
    // 抽象方法 - 子类必须实现
    public abstract double getArea();
    public abstract double getPerimeter();
    
    // 具体方法
    @Override
    public String toString() {
        return String.format("Shape[color=%s, filled=%s]", color, filled);
    }
}

class Circle extends Shape {
    private double radius;
    
    public Circle(String color, boolean filled, double radius) {
        super(color, filled);
        this.radius = radius;
    }
    
    @Override
    public double getArea() {
        return Math.PI * radius * radius;
    }
    
    @Override
    public double getPerimeter() {
        return 2 * Math.PI * radius;
    }
}

class Rectangle extends Shape {
    private double width;
    private double height;
    
    public Rectangle(String color, boolean filled, double width, double height) {
        super(color, filled);
        this.width = width;
        this.height = height;
    }
    
    @Override
    public double getArea() {
        return width * height;
    }
    
    @Override
    public double getPerimeter() {
        return 2 * (width + height);
    }
}
```

### 2. 何时使用接口

```java
// 情况1：需要定义不相关类的能力
interface Comparable<T> {
    int compareTo(T other);
}

interface Cloneable {
    Object clone();
}

interface Serializable {
    // 标记接口 - 没有方法
}

// 不相关的类可以实现相同的接口
class Student implements Comparable<Student>, Cloneable {
    private String name;
    private int score;
    
    public Student(String name, int score) {
        this.name = name;
        this.score = score;
    }
    
    @Override
    public int compareTo(Student other) {
        return Integer.compare(this.score, other.score);
    }
    
    @Override
    public Object clone() {
        try {
            return super.clone();
        } catch (CloneNotSupportedException e) {
            throw new RuntimeException(e);
        }
    }
}

class Product implements Comparable<Product>, Serializable {
    private String name;
    private double price;
    
    public Product(String name, double price) {
        this.name = name;
        this.price = price;
    }
    
    @Override
    public int compareTo(Product other) {
        return Double.compare(this.price, other.price);
    }
}

// 情况2：需要多继承行为
interface A {
    default void doSomething() {
        System.out.println("A的实现");
    }
}

interface B {
    default void doSomething() {
        System.out.println("B的实现");
    }
}

class C implements A, B {
    // 必须解决默认方法冲突
    @Override
    public void doSomething() {
        A.super.doSomething(); // 选择A的实现
        // 或者提供自己的实现
    }
}
```

## 现代Java中的发展

### 1. 接口的增强

```java
// Java 8+ 接口的现代用法
public interface ModernInterface {
    // 抽象方法
    void abstractMethod();
    
    // 默认方法 - 向后兼容
    default void defaultMethod() {
        privateMethod(); // 调用私有方法
        System.out.println("默认方法");
    }
    
    // 静态方法 - 工具方法
    static void utilityMethod() {
        System.out.println("静态工具方法");
    }
    
    // 私有方法 - 代码复用 (Java 9+)
    private void privateMethod() {
        System.out.println("私有方法");
    }
    
    // 私有静态方法 (Java 9+)
    private static void privateStaticMethod() {
        System.out.println("私有静态方法");
    }
}

// 函数式接口
@FunctionalInterface
interface Calculator {
    int calculate(int a, int b);
    
    // 只能有一个抽象方法，但可以有多个默认方法
    default void printResult(int result) {
        System.out.println("结果: " + result);
    }
}

// 使用函数式接口
public class FunctionalInterfaceExample {
    public static void main(String[] args) {
        // Lambda表达式
        Calculator addition = (a, b) -> a + b;
        Calculator multiplication = (a, b) -> a * b;
        
        System.out.println("加法: " + addition.calculate(5, 3));
        System.out.println("乘法: " + multiplication.calculate(5, 3));
    }
}
```

## 总结对比表格

| 特性 | 抽象类 | 接口 |
|------|--------|------|
| **继承关系** | 单继承 | 多实现 |
| **构造方法** | 有 | 无 |
| **方法实现** | 可以有具体和抽象方法 | Java 8前只有抽象方法 |
| **字段** | 可以有各种变量 | 只有常量 |
| **设计目的** | 代码复用，is-a关系 | 定义契约，has-a能力 |
| **访问修饰符** | 任意 | 默认public |
| **多态性** | 继承多态 | 接口多态 |
| **使用场景** | 模板方法，框架设计 | API定义，能力扩展 |
| **版本兼容** | 修改可能破坏子类 | 默认方法保持兼容 |

**选择原则**：
- 使用**抽象类**：需要代码复用、定义模板方法、在密切相关的类之间共享代码
- 使用**接口**：定义行为契约、需要多继承、定义API、希望不相关的类具有相同能力

在现代Java开发中，接口的功能越来越强大，但在需要共享代码或定义模板时，抽象类仍然是不可替代的选择。
