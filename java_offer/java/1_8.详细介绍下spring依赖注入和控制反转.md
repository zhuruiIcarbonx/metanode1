# Spring依赖注入和控制反转详解

## 控制反转（IoC）概念解析

### 1. 什么是控制反转

控制反转是一种**设计原则**，用于解耦程序的依赖关系。传统程序由开发者主动创建和管理对象，而IoC将这个过程交给容器来处理。

```java
// 传统编程方式 - 主动创建依赖
public class TraditionalCode {
    private UserRepository userRepo = new UserRepositoryImpl();
    private EmailService emailService = new EmailServiceImpl();
    
    public void registerUser(User user) {
        userRepo.save(user);
        emailService.sendWelcomeEmail(user);
    }
}

// IoC方式 - 依赖由外部提供
public class IoCCode {
    private UserRepository userRepo;
    private EmailService emailService;
    
    // 依赖通过构造函数注入
    public IoCCode(UserRepository userRepo, EmailService emailService) {
        this.userRepo = userRepo;
        this.emailService = emailService;
    }
    
    public void registerUser(User user) {
        userRepo.save(user);
        emailService.sendWelcomeEmail(user);
    }
}
```

### 2. IoC容器的作用

Spring IoC容器负责：
- 实例化应用程序对象
- 配置对象
- 组装对象之间的依赖关系

## 依赖注入（DI）的三种方式

### 1. 构造函数注入

```java
@Component
public class UserService {
    private final UserRepository userRepository;
    private final EmailService emailService;
    
    // 构造函数注入 - Spring推荐的方式
    @Autowired
    public UserService(UserRepository userRepository, EmailService emailService) {
        this.userRepository = userRepository;
        this.emailService = emailService;
    }
    
    public void registerUser(String username, String email) {
        User user = new User(username, email);
        userRepository.save(user);
        emailService.sendWelcomeEmail(user);
    }
}

// 配置类方式
@Configuration
public class AppConfig {
    
    @Bean
    public UserRepository userRepository() {
        return new JdbcUserRepository();
    }
    
    @Bean
    public EmailService emailService() {
        return new SmtpEmailService();
    }
    
    @Bean
    public UserService userService(UserRepository userRepository, EmailService emailService) {
        return new UserService(userRepository, emailService);
    }
}
```

### 2. Setter方法注入

```java
@Component
public class OrderService {
    private PaymentService paymentService;
    private InventoryService inventoryService;
    
    // Setter注入
    @Autowired
    public void setPaymentService(PaymentService paymentService) {
        this.paymentService = paymentService;
    }
    
    @Autowired
    public void setInventoryService(InventoryService inventoryService) {
        this.inventoryService = inventoryService;
    }
    
    public void processOrder(Order order) {
        inventoryService.reserveItems(order);
        paymentService.processPayment(order);
    }
}
```

### 3. 字段注入

```java
@Component
public class ProductService {
    
    // 字段注入 - 不推荐在生产代码中使用
    @Autowired
    private ProductRepository productRepository;
    
    @Autowired
    private DiscountService discountService;
    
    public Product getProductWithDiscount(Long productId) {
        Product product = productRepository.findById(productId);
        return discountService.applyDiscount(product);
    }
}
```

## Spring IoC容器的核心实现

### 1. BeanFactory - 基础容器

```java
public class BeanFactoryExample {
    public static void main(String[] args) {
        // 创建BeanFactory
        DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory();
        
        // 创建Bean定义
        RootBeanDefinition userServiceDef = new RootBeanDefinition(UserService.class);
        RootBeanDefinition userRepoDef = new RootBeanDefinition(JdbcUserRepository.class);
        
        // 注册Bean定义
        beanFactory.registerBeanDefinition("userService", userServiceDef);
        beanFactory.registerBeanDefinition("userRepository", userRepoDef);
        
        // 获取Bean实例
        UserService userService = beanFactory.getBean(UserService.class);
        userService.registerUser("john", "john@example.com");
    }
}
```

### 2. ApplicationContext - 高级容器

```java
// 基于注解的配置
@Configuration
@ComponentScan("com.example")
@PropertySource("classpath:application.properties")
public class ApplicationContextExample {
    
    public static void main(String[] args) {
        // 创建ApplicationContext
        ApplicationContext context = new AnnotationConfigApplicationContext(
            ApplicationContextExample.class);
        
        // 获取Bean
        UserService userService = context.getBean(UserService.class);
        userService.registerUser("alice", "alice@example.com");
        
        // 获取所有UserService类型的Bean
        Map<String, UserService> userServices = context.getBeansOfType(UserService.class);
        
        // 获取环境配置
        Environment env = context.getEnvironment();
        String dbUrl = env.getProperty("database.url");
    }
}

// XML配置方式
public class XmlConfigExample {
    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");
        UserService userService = context.getBean("userService", UserService.class);
    }
}
```

## Bean的作用域和生命周期

### 1. Bean的作用域

```java
@Component
@Scope(ConfigurableBeanFactory.SCOPE_SINGLETON) // 默认作用域
public class SingletonService {
    // 整个应用程序中只有一个实例
}

@Component
@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE) // 原型作用域
public class PrototypeService {
    // 每次获取时创建新实例
}

@Component
@Scope(WebApplicationContext.SCOPE_REQUEST) // 请求作用域
public class RequestScopedService {
    // 每个HTTP请求创建一个实例
}

@Component
@Scope(WebApplicationContext.SCOPE_SESSION) // 会话作用域
public class SessionScopedService {
    // 每个HTTP会话创建一个实例
}
```

### 2. Bean的生命周期回调

```java
@Component
public class LifecycleBean implements InitializingBean, DisposableBean {
    
    private static final Logger logger = LoggerFactory.getLogger(LifecycleBean.class);
    
    public LifecycleBean() {
        logger.info("1. 构造函数执行");
    }
    
    @Autowired
    public void setDependency(SomeDependency dependency) {
        logger.info("2. 依赖注入完成");
    }
    
    @PostConstruct
    public void postConstruct() {
        logger.info("3. @PostConstruct方法执行");
    }
    
    @Override
    public void afterPropertiesSet() throws Exception {
        logger.info("4. InitializingBean.afterPropertiesSet()执行");
    }
    
    @PreDestroy
    public void preDestroy() {
        logger.info("5. @PreDestroy方法执行");
    }
    
    @Override
    public void destroy() throws Exception {
        logger.info("6. DisposableBean.destroy()执行");
    }
    
    // 自定义初始化方法
    @Bean(initMethod = "customInit", destroyMethod = "customDestroy")
    public AnotherBean anotherBean() {
        return new AnotherBean();
    }
}
```

## 高级依赖注入特性

### 1. 条件化装配

```java
@Configuration
public class ConditionalConfiguration {
    
    @Bean
    @Conditional(WindowsCondition.class)
    public FileSystemService windowsFileSystem() {
        return new WindowsFileSystemService();
    }
    
    @Bean
    @Conditional(LinuxCondition.class)
    public FileSystemService linuxFileSystem() {
        return new LinuxFileSystemService();
    }
    
    @Bean
    @ConditionalOnProperty(name = "cache.enabled", havingValue = "true")
    @ConditionalOnClass(name = "redis.clients.jedis.Jedis")
    public CacheService redisCache() {
        return new RedisCacheService();
    }
    
    @Bean
    @ConditionalOnMissingBean(CacheService.class)
    public CacheService localCache() {
        return new LocalCacheService();
    }
}

// 自定义条件
public class WindowsCondition implements Condition {
    @Override
    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
        return context.getEnvironment().getProperty("os.name").contains("Windows");
    }
}
```

### 2. 多实现类的处理

```java
// 多个实现类
@Component("emailService")
@Primary
public class EmailServiceImpl implements NotificationService {
    @Override
    public void sendNotification(String message, String recipient) {
        // 发送邮件逻辑
    }
}

@Component("smsService")
public class SmsServiceImpl implements NotificationService {
    @Override
    public void sendNotification(String message, String recipient) {
        // 发送短信逻辑
    }
}

@Component("pushService")
@Qualifier("push")
public class PushServiceImpl implements NotificationService {
    @Override
    public void sendNotification(String message, String recipient) {
        // 发送推送通知逻辑
    }
}

// 使用方式
@Service
public class NotificationDispatcher {
    
    // 1. 使用@Primary
    @Autowired
    private NotificationService primaryService;
    
    // 2. 使用@Qualifier指定具体实现
    @Autowired
    @Qualifier("smsService")
    private NotificationService smsService;
    
    // 3. 注入所有实现
    @Autowired
    private List<NotificationService> allServices;
    
    // 4. 使用Map注入
    @Autowired
    private Map<String, NotificationService> serviceMap;
    
    public void broadcast(String message) {
        allServices.forEach(service -> 
            service.sendNotification(message, "all-users"));
    }
    
    public void sendByType(String type, String message) {
        NotificationService service = serviceMap.get(type + "Service");
        if (service != null) {
            service.sendNotification(message, "specific-user");
        }
    }
}
```

### 3. 懒加载和循环依赖

```java
@Component
public class CircularDependencyA {
    
    private final CircularDependencyB dependencyB;
    
    // 构造函数注入可以避免循环依赖问题
    public CircularDependencyA(@Lazy CircularDependencyB dependencyB) {
        this.dependencyB = dependencyB;
    }
}

@Component
public class CircularDependencyB {
    
    private final CircularDependencyA dependencyA;
    
    public CircularDependencyB(CircularDependencyA dependencyA) {
        this.dependencyA = dependencyA;
    }
}

// 懒加载配置
@Configuration
public class LazyConfiguration {
    
    @Bean
    @Lazy  // 只有第一次使用时才初始化
    public ExpensiveService expensiveService() {
        return new ExpensiveService();
    }
    
    @Bean
    public CheapService cheapService() {
        return new CheapService();  // 立即初始化
    }
}
```

## 实际应用案例

### 1. 三层架构的依赖注入

```java
// 数据访问层
@Repository
public class UserRepositoryImpl implements UserRepository {
    
    private final JdbcTemplate jdbcTemplate;
    
    public UserRepositoryImpl(JdbcTemplate jdbcTemplate) {
        this.jdbcTemplate = jdbcTemplate;
    }
    
    @Override
    public User save(User user) {
        // 数据库操作
        return user;
    }
    
    @Override
    public Optional<User> findById(Long id) {
        // 查询逻辑
        return Optional.empty();
    }
}

// 业务逻辑层
@Service
@Transactional
public class UserServiceImpl implements UserService {
    
    private final UserRepository userRepository;
    private final EmailService emailService;
    private final PasswordEncoder passwordEncoder;
    
    public UserServiceImpl(UserRepository userRepository, 
                          EmailService emailService,
                          PasswordEncoder passwordEncoder) {
        this.userRepository = userRepository;
        this.emailService = emailService;
        this.passwordEncoder = passwordEncoder;
    }
    
    @Override
    public User registerUser(UserRegistrationDto dto) {
        // 业务逻辑
        User user = new User();
        user.setUsername(dto.getUsername());
        user.setEmail(dto.getEmail());
        user.setPassword(passwordEncoder.encode(dto.getPassword()));
        
        User savedUser = userRepository.save(user);
        emailService.sendWelcomeEmail(savedUser);
        
        return savedUser;
    }
}

// 控制层
@RestController
@RequestMapping("/api/users")
public class UserController {
    
    private final UserService userService;
    
    public UserController(UserService userService) {
        this.userService = userService;
    }
    
    @PostMapping("/register")
    public ResponseEntity<User> register(@RequestBody UserRegistrationDto dto) {
        User user = userService.registerUser(dto);
        return ResponseEntity.ok(user);
    }
}

// 配置类
@Configuration
@EnableTransactionManagement
public class AppConfig {
    
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
    
    @Bean
    public DataSource dataSource() {
        // 数据源配置
        return new HikariDataSource();
    }
    
    @Bean
    public JdbcTemplate jdbcTemplate(DataSource dataSource) {
        return new JdbcTemplate(dataSource);
    }
}
```

### 2. 测试中的依赖注入

```java
// 单元测试
@ExtendWith(MockitoExtension.class)
class UserServiceTest {
    
    @Mock
    private UserRepository userRepository;
    
    @Mock
    private EmailService emailService;
    
    @Mock
    private PasswordEncoder passwordEncoder;
    
    @InjectMocks
    private UserServiceImpl userService;
    
    @Test
    void shouldRegisterUserSuccessfully() {
        // Given
        UserRegistrationDto dto = new UserRegistrationDto("john", "john@test.com", "password");
        User savedUser = new User(1L, "john", "john@test.com", "encodedPassword");
        
        when(passwordEncoder.encode("password")).thenReturn("encodedPassword");
        when(userRepository.save(any(User.class))).thenReturn(savedUser);
        
        // When
        User result = userService.registerUser(dto);
        
        // Then
        assertThat(result.getId()).isEqualTo(1L);
        verify(emailService).sendWelcomeEmail(savedUser);
    }
}

// 集成测试
@SpringBootTest
@Transactional
class UserServiceIntegrationTest {
    
    @Autowired
    private UserService userService;
    
    @Autowired
    private UserRepository userRepository;
    
    @Test
    void shouldPersistUserInDatabase() {
        // Given
        UserRegistrationDto dto = new UserRegistrationDto("test", "test@test.com", "password");
        
        // When
        User result = userService.registerUser(dto);
        
        // Then
        assertThat(userRepository.findById(result.getId())).isPresent();
    }
}
```

## 最佳实践和注意事项

### 1. 依赖注入的最佳实践

```java
// 推荐：使用构造函数注入
@Service
public class GoodPracticeService {
    private final DependencyA depA;
    private final DependencyB depB;
    
    // 明确的依赖关系，不可变
    public GoodPracticeService(DependencyA depA, DependencyB depB) {
        this.depA = depA;
        this.depB = depB;
    }
}

// 避免：混合使用多种注入方式
@Service
public class BadPracticeService {
    @Autowired
    private DependencyA depA;  // 字段注入
    
    private DependencyB depB;
    
    @Autowired  // Setter注入
    public void setDepB(DependencyB depB) {
        this.depB = depB;
    }
    
    @Autowired  // 构造函数注入
    public BadPracticeService(DependencyC depC) {
        // 混合使用导致依赖关系不清晰
    }
}
```

### 2. 配置管理

```java
@Configuration
@ConfigurationProperties(prefix = "app")
@Data
public class AppProperties {
    private String name;
    private String version;
    private Database database;
    
    @Data
    public static class Database {
        private String url;
        private String username;
        private String password;
        private int poolSize;
    }
}

@Component
public class ConfigUsage {
    private final AppProperties appProperties;
    
    public ConfigUsage(AppProperties appProperties) {
        this.appProperties = appProperties;
    }
    
    public void printConfig() {
        System.out.println("App: " + appProperties.getName() + " v" + appProperties.getVersion());
        System.out.println("DB: " + appProperties.getDatabase().getUrl());
    }
}
```

## 总结

Spring的依赖注入和控制反转提供了：

1. **松耦合**：组件之间依赖接口而非具体实现
2. **可测试性**：依赖可以轻松替换为Mock对象
3. **可维护性**：配置集中管理，修改方便
4. **灵活性**：通过配置可以轻松切换实现
5. **生命周期管理**：容器负责对象的创建、初始化和销毁

通过合理使用依赖注入，可以构建出更加灵活、可维护和可测试的应用程序。构造函数注入是Spring团队推荐的方式，因为它保证了依赖的不可变性和明确性。
