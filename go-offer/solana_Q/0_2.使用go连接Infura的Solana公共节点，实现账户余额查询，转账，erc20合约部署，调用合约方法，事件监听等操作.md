
# 一、使用go连接Infura的Solana公共节点，实现账户余额查询，转账，erc20合约部署，调用合约方法，事件监听等操作



在 Solana 生态中，并不存在 ERC20 标准（ERC20 是以太坊的代币标准），但 Solana 有其原生的代币标准 **SPL Token**，功能上与 ERC20 类似。本文将指导你使用 Go 语言连接 Infura 的 Solana 公共节点，实现账户余额查询、转账、SPL Token 部署、合约调用及事件监听等操作。

---

## 1. 环境准备

### 1.1 安装依赖库

使用 Go 的 Solana SDK：

```bash
go get github.com/gagliardetto/solana-go
go get github.com/gagliardetto/solana-go/programs/system
go get github.com/gagliardetto/solana-go/programs/token
```

### 1.2 Infura 配置

注册 [Infura](https://infura.io/) 并创建 Solana 项目，获取 **Project ID**。

- **RPC URL (主网)**: `https://solana-mainnet.g.alchemy.com/v2/YOUR_INFURA_PROJECT_ID`
- **RPC URL (测试网)**: `https://solana-devnet.g.alchemy.com/v2/YOUR_INFURA_PROJECT_ID`

---

## 2. 查询账户余额

```go
package main

import (
    "context"
    "fmt"
    "github.com/gagliardetto/solana-go"
    "github.com/gagliardetto/solana-go/rpc"
)

func main() {
    client := rpc.New("https://solana-mainnet.g.alchemy.com/v2/YOUR_INFURA_PROJECT_ID")

    // 替换为目标账户地址
    accountPubKey := solana.MustPublicKeyFromBase58("YourAccountAddress")

    // 查询余额
    balance, err := client.GetBalance(context.TODO(), accountPubKey)
    if err != nil {
        panic(err)
    }

    fmt.Printf("Balance: %d lamports\n", balance)
}
```

---

## 3. 转账 SOL

```go
package main

import (
    "context"
    "fmt"
    "github.com/gagliardetto/solana-go"
    "github.com/gagliardetto/solana-go/rpc"
    "github.com/gagliardetto/solana-go/programs/system"
)

func main() {
    client := rpc.New("https://solana-mainnet.g.alchemy.com/v2/YOUR_INFURA_PROJECT_ID")

    // 创建发送方钱包（私钥）
    senderPrivateKey := solana.MustPrivateKeyFromBase58("YourPrivateKey")
    senderPubKey := senderPrivateKey.PublicKey()

    // 接收方地址
    receiverPubKey := solana.MustPublicKeyFromBase58("ReceiverAddress")

    // 获取最新区块哈希
    latestBlockhash, err := client.GetLatestBlockhash(context.TODO(), rpc.CommitmentFinalized)
    if err != nil {
        panic(err)
    }

    // 创建转账指令
    transferInstruction := system.NewTransferInstruction(
        1000000, // 转账金额（单位：lamports，1 SOL = 1e9 lamports）
        senderPubKey,
        receiverPubKey,
    ).Build()

    // 构建交易
    tx, err := solana.NewTransaction(
        []solana.Instruction{transferInstruction},
        latestBlockhash.Value,
        solana.TransactionPayer(senderPubKey),
    )
    if err != nil {
        panic(err)
    }

    // 签名交易
    _, err = tx.Sign(
        func(key solana.PublicKey) *solana.PrivateKey {
            if key.Equals(senderPubKey) {
                return &senderPrivateKey
            }
            return nil
        },
        solana.DefaultSigner,
    )
    if err != nil {
        panic(err)
    }

    // 发送交易
    sig, err := client.SendTransaction(context.TODO(), tx)
    if err != nil {
        panic(err)
    }

    fmt.Printf("Transaction sent: %s\n", sig.String())
}
```

---

## 4. 部署 SPL Token（原生代币）

### 4.1 创建 SPL Token

使用 `spl-token` CLI 工具（需安装 Solana CLI）：

```bash
spl-token create-token
```

输出结果包含 **Token Address**，后续操作需使用该地址。

### 4.2 铸造代币

```bash
spl-token mint <TOKEN_ADDRESS> <AMOUNT> --recipient <RECIPIENT_WALLET_ADDRESS>
```

---

## 5. 调用合约方法（以 SPL Token 为例）

### 5.1 转账 SPL Token

```go
package main

import (
    "context"
    "fmt"
    "github.com/gagliardetto/solana-go"
    "github.com/gagliardetto/solana-go/rpc"
    "github.com/gagliardetto/solana-go/programs/token"
)

func main() {
    client := rpc.New("https://solana-mainnet.g.alchemy.com/v2/YOUR_INFURA_PROJECT_ID")

    senderPrivateKey := solana.MustPrivateKeyFromBase58("YourPrivateKey")
    senderPubKey := senderPrivateKey.PublicKey()

    // Token 地址（SPL Token）
    tokenMint := solana.MustPublicKeyFromBase58("TokenAddress")

    // 接收方钱包地址
    receiverWallet := solana.MustPublicKeyFromBase58("ReceiverWalletAddress")

    // 获取接收方的 Token 账户地址
    receiverTokenAccount, err := token.GetAssociatedTokenAddress(receiverWallet, tokenMint)
    if err != nil {
        panic(err)
    }

    // 创建转账指令
    transferInstruction := token.NewTransferInstruction(
        1000000, // 转账数量（单位：最小单位，如 1 USDC = 1e6）
        senderTokenAccount, // 发送方 Token 账户地址（需预先创建）
        receiverTokenAccount,
        senderPubKey,
        []solana.PublicKey{},
    ).Build()

    // 构建交易（需包含最新区块哈希和签名）
    // ...（与转账 SOL 类似，此处省略重复代码）
}
```

---

## 6. 事件监听（监听账户变更）

使用 WebSocket 监听账户更新：

```go
package main

import (
    "context"
    "fmt"
    "github.com/gagliardetto/solana-go"
    "github.com/gagliardetto/solana-go/rpc"
)

func main() {
    wsClient, err := rpc.NewWebSocket(rpc.MainNetBeta_WS)
    if err != nil {
        panic(err)
    }
    defer wsClient.Close()

    accountToWatch := solana.MustPublicKeyFromBase58("AccountAddress")

    // 订阅账户更新
    sub, err := wsClient.AccountSubscribe(accountToWatch)
    if err != nil {
        panic(err)
    }
    defer sub.Unsubscribe()

    for {
        // 等待更新事件
        packet, err := sub.Recv()
        if err != nil {
            panic(err)
        }

        fmt.Printf("Account updated: %v\n", packet.Value)
    }
}
```

---

## 7. 注意事项

1. **私钥安全**：不要硬编码私钥，建议使用环境变量或加密存储。
2. **测试网络**：开发时使用 Devnet 或 Testnet，避免主网风险。
3. **Gas 费**：Solana 交易需支付少量 SOL 作为手续费。
4. **Infura 限制**：注意免费套餐的请求频率限制。

---

## 参考文档

- [Solana Go SDK](https://pkg.go.dev/github.com/gagliardetto/solana-go)
- [SPL Token CLI](https://spl.solana.com/token)
- [Infura Solana 文档](https://docs.infura.io/infura/networks/solana)

通过以上步骤，你可以使用 Go 语言完成 Solana 的基础交互操作。如需更复杂的合约开发，建议学习 Solana 的 Anchor 框架。


# 一、XXXXXXXXXXXXXXXXXXX

以下是使用 Go 语言连接 Infura 的 Solana 公共节点，并实现常见操作的完整指南（基于 Solana 的 RPC API 和相关 Go 库）：

---

### 1. 准备工作
#### 安装依赖库
```bash
go get github.com/portto/solana-go-sdk
go get github.com/portto/solana-go-sdk/common
go get github.com/portto/solana-go-sdk/program/sysprog
go get github.com/portto/solana-go-sdk/program/tokenprog
```

#### 初始化 Infura 客户端
```go
package main

import (
	"fmt"
	"github.com/portto/solana-go-sdk/client"
)

func main() {
	// 替换为你的 Infura Solana 端点（需要申请 Infura Solana API Key）
	infuraURL := "https://solana-mainnet.infura.io/v3/YOUR_API_KEY"
	rpcClient := client.NewClient(infuraURL)
}
```

---

### 2. 基础操作实现

#### (1) 查询账户余额
```go
func getBalance(cli *client.Client, publicKey string) {
	balance, err := cli.GetBalance(publicKey)
	if err != nil {
		fmt.Println("查询失败:", err)
		return
	}
	fmt.Printf("账户余额: %v SOL (Lamports: %v)\n", float64(balance)/1e9, balance)
}
```

#### (2) SOL 转账
```go
func transferSOL(cli *client.Client, fromPrivateKey, toPublicKey string, amount uint64) {
	// 解析私钥
	account, err := solana.PrivateKeyFromBase58(fromPrivateKey)
	if err != nil {
		panic(err)
	}

	// 构建转账指令
	tx, err := cli.Transfer(
		account.PublicKey().String(),
		toPublicKey,
		amount,
	)
	if err != nil {
		panic(err)
	}

	// 签名并发送交易
	txHash, err := tx.SignAndSend(account)
	if err != nil {
		panic(err)
	}
	fmt.Println("转账成功，交易哈希:", txHash)
}
```

---

### 3. ERC-20 代币操作（基于 SPL Token）

#### (1) 部署 SPL Token 合约
```go
func createToken(cli *client.Client, payerPrivateKey string) {
	payer, _ := solana.PrivateKeyFromBase58(payerPrivateKey)

	// 创建代币 mint 账户
	tokenMint := solana.NewAccount()
	tx, err := tokenprog.CreateMint(
		payer.PublicKey(),
		tokenMint.PublicKey(),
		payer.PublicKey(), // Mint Authority
		9, // 小数位数
	)
	if err != nil {
		panic(err)
	}

	// 发送交易
	txHash, err := tx.SignAndSend(payer, tokenMint)
	if err != nil {
		panic(err)
	}
	fmt.Println("代币合约部署成功")
	fmt.Println("Mint Address:", tokenMint.PublicKey().String())
	fmt.Println("交易哈希:", txHash)
}
```

#### (2) 调用合约方法（转账代币）
```go
func transferToken(cli *client.Client, 
	senderPrivateKey, 
	tokenMintAddress, 
	receiverPublicKey string, 
	amount uint64) {

	sender, _ := solana.PrivateKeyFromBase58(senderPrivateKey)
	
	// 查找关联的 Token 账户
	senderTokenAccount, _ := tokenprog.FindAssociatedTokenAddress(
		sender.PublicKey(),
		solana.MustPublicKeyFromBase58(tokenMintAddress),
	)
	receiverTokenAccount, _ := tokenprog.FindAssociatedTokenAddress(
		solana.MustPublicKeyFromBase58(receiverPublicKey),
		solana.MustPublicKeyFromBase58(tokenMintAddress),
	)

	// 构建转账指令
	tx, err := tokenprog.TransferChecked(
		senderTokenAccount,
		senderTokenAccount, // Source
		receiverTokenAccount,
		sender.PublicKey(),
		amount,
		9, // 小数位数
	)
	if err != nil {
		panic(err)
	}

	// 发送交易
	txHash, err := tx.SignAndSend(sender)
	fmt.Println("代币转账成功，哈希:", txHash)
}
```

---

### 4. 事件监听（通过 WebSocket）
```go
import (
	"github.com/portto/solana-go-sdk/rpc"
)

func watchEvents() {
	wsClient, err := rpc.Connect("wss://solana-mainnet.infura.io/v3/YOUR_API_KEY")
	if err != nil {
		panic(err)
	}

	// 监听新区块
	subId, err := wsClient.SlotSubscribe()
	if err != nil {
		panic(err)
	}
	
	for {
		slot, err := wsClient.ReadSubscription(subId)
		if err != nil {
			fmt.Println("监听错误:", err)
			continue
		}
		fmt.Println("新区块产生，Slot:", slot)
	}
}
```

---

### 关键注意事项
1. **Infura 配置**  
   - 需要先在 [Infura](https://infura.io/) 申请 Solana API Key
   - 主网端点: `https://solana-mainnet.infura.io/v3/YOUR_KEY`
   - 测试网（如 Devnet）需替换为对应 URL

2. **错误处理**  
   - 所有操作都应检查 RPC 响应错误（如网络问题、gas 不足等）
   - 推荐添加重试逻辑（Solana 网络可能拥堵）

3. **手续费计算**  
   - Solana 交易手续费动态变化，可通过 `cli.GetRecentBlockhash()` 获取当前基准费率

4. **代币标准差异**  
   - Solana 使用 SPL Token（非 ERC-20），但功能类似

---

以上代码覆盖了 Solana 链上基本操作。实际使用时建议封装成独立服务，并添加日志、监控等功能。如果需要更复杂的功能（如 Program 交互），需要进一步学习 Solana 的指令（Instruction）构建方法。


