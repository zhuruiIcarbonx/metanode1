# 一、golang使用actor模型处理100个并发任务【重点看：优化版实现 - 使用工作池模式---适合批量处理区块同步】

# Go语言中使用Actor模型处理100个并发任务

Go语言虽然原生不直接内置Actor模型，但可以通过goroutine和channel很好地实现类似Actor模型的并发模式。下面是实现方案：

## 基本实现方案

```go
package main

import (
	"fmt"
	"sync"
)

// Actor结构，包含接收消息的channel
type Actor struct {
	Mailbox chan string
	ID      int
	Wg      *sync.WaitGroup
}

// Actor行为 - 接收并处理消息
func (a *Actor) Run() {
	defer a.Wg.Done()
	
	for msg := range a.Mailbox {
		fmt.Printf("Actor %d 处理消息: %s\n", a.ID, msg)
		// 这里可以添加实际业务逻辑
	}
}

func main() {
	const numActors = 100
	const numMessages = 1000
	
	var wg sync.WaitGroup
	
	// 创建100个Actor
	actors := make([]*Actor, numActors)
	for i := 0; i < numActors; i++ {
		actors[i] = &Actor{
			Mailbox: make(chan string, 10), // 每个actor的邮箱容量为10
			ID:      i,
			Wg:      &wg,
		}
		wg.Add(1)
		go actors[i].Run()
	}
	
	// 派发消息给各个Actor
	wg.Add(1)
	go func() {
		defer wg.Done()
		for i := 0; i < numMessages; i++ {
			actorID := i % numActors
			msg := fmt.Sprintf("消息%d", i)
			actors[actorID].Mailbox <- msg
		}
		
		// 关闭所有邮箱通道
		for _, actor := range actors {
			close(actor.Mailbox)
		}
	}()
	
	wg.Wait()
	fmt.Println("所有任务完成")
}
```

## 优化版实现 - 使用工作池模式

```go
package main

import (
	"fmt"
	"sync"
)

type Task struct {
	ID   int
	Data interface{} // 可以是任意类型的数据
}

type Worker struct {
	ID          int
	TaskChannel chan Task
	Quit        chan bool
}

func NewWorker(id int) *Worker {
	return &Worker{
		ID:          id,
		TaskChannel: make(chan Task),
		Quit:        make(chan bool),
	}
}

func (w *Worker) Start(wg *sync.WaitGroup) {
	wg.Add(1)
	go func() {
		defer wg.Done()
		for {
			select {
			case task := <-w.TaskChannel:
				// 处理任务
				fmt.Printf("Worker %d 处理任务 %d: %v\n", w.ID, task.ID, task.Data)
			case <-w.Quit:
				return
			}
		}
	}()
}

func (w *Worker) Stop() {
	go func() {
		w.Quit <- true
	}()
}

func main() {
	const numWorkers = 100
	const numTasks = 1000
	
	var wg sync.WaitGroup
	workers := make([]*Worker, numWorkers)
	
	// 创建工作池
	for i := 0; i < numWorkers; i++ {
		workers[i] = NewWorker(i)
		workers[i].Start(&wg)
	}
	
	// 分发任务
	for i := 0; i < numTasks; i++ {
		workerID := i % numWorkers
		task := Task{
			ID:   i,
			Data: fmt.Sprintf("data-%d", i),
		}
		workers[workerID].TaskChannel <- task
	}
	
	// 停止所有worker
	for _, worker := range workers {
		worker.Stop()
	}
	
	wg.Wait()
	fmt.Println("所有任务处理完成")
}
```

## 关键实现点

1. **每个Actor/Worker拥有自己的邮箱(通道)** - 这是Actor模型的核心，各个Actor独立处理自己的消息

2. **避免共享状态** - 通过消息传递而非共享内存实现通信

3. **合理的调度策略** - 示例中使用轮询调度策略，也可以根据需要实现更复杂的调度

4. **正确的资源回收** - 需要正确关闭通道和goroutine

## 注意事项

1. **通道容量设计** - 根据业务场景设置合理的通道缓冲大小

2. **错误处理** - 为每个Worker/Actor添加错误处理机制

3. **监控** - 可以添加监控功能来跟踪任务处理情况

4. **性能考虑** - 对于极高并发的场景，可以考虑批量处理消息

5. **负载均衡** - 更高级的实现可以动态分配任务给负载较低的Worker

这种模式非常适合需要处理大量独立任务且需要高度并发的场景，如区块链中的交易处理、网络请求处理等。

# 二、golang使用actor模型处理100个并发任务



在 Go 语言中，虽然没有直接的 Actor 模型库（如 Erlang 的 `gen_server`），但可以通过 **goroutine + channel** 的组合，模拟 Actor 模型的并发行为。每个 Actor 是一个独立的 goroutine，通过 channel 接收消息（任务），并独立处理，避免共享内存，实现安全的并发。

以下是一个使用 Actor 模型处理 100 个并发任务的示例：

---

### 1. 定义 Actor 结构体
每个 Actor 是一个独立的 goroutine，拥有自己的任务 channel 和状态：

```go
type Worker struct {
    id      int
    taskCh  chan Task
    quitCh  chan struct{}
}

type Task struct {
    ID   int
    Data string
}
```

---

### 2. 启动 Actor（Worker）
每个 Worker 在启动后会持续监听自己的 `taskCh`，处理任务：

```go
func (w *Worker) Start() {
    go func() {
        for {
            select {
            case task := <-w.taskCh:
                // 处理任务
                fmt.Printf("Worker %d processing task: %s\n", w.id, task.Data)
                // 模拟任务耗时
                time.Sleep(100 * time.Millisecond)
            case <-w.quitCh:
                fmt.Printf("Worker %d stopping.\n", w.id)
                return
            }
        }
    }()
}
```

---

### 3. 创建任务分发器（Dispatcher）
调度器负责将任务分发到不同的 Worker 的 channel：

```go
type Dispatcher struct {
    workers []*Worker
    taskCh  chan Task
}

func NewDispatcher(numWorkers int) *Dispatcher {
    workers := make([]*Worker, numWorkers)
    for i := 0; i < numWorkers; i++ {
        workers[i] = &Worker{
            id:     i + 1,
            taskCh: make(chan Task, 100), // 缓冲 channel
            quitCh: make(chan struct{}),
        }
        workers[i].Start()
    }

    return &Dispatcher{
        workers: workers,
        taskCh:  make(chan Task, 100),
    }
}

func (d *Dispatcher) DispatchTasks(numTasks int) {
    // 轮询分发任务
    for i := 0; i < numTasks; i++ {
        task := Task{
            ID:   i + 1,
            Data: fmt.Sprintf("Task-%d", i+1),
        }
        worker := d.workers[i%len(d.workers)] // 轮询分配
        worker.taskCh <- task
    }
}

func (d *Dispatcher) Stop() {
    for _, worker := range d.workers {
        close(worker.quitCh)
    }
    close(d.taskCh)
}
```

---

### 4. 主函数启动任务
创建 Dispatcher 并发送 100 个任务：

```go
func main() {
    numWorkers := 10  // 可根据 CPU 核心数调整
    dispatcher := NewDispatcher(numWorkers)
    defer dispatcher.Stop()

    // 发送 100 个任务
    dispatcher.DispatchTasks(100)

    // 防止 main 函数提前退出
    fmt.Println("All tasks dispatched. Press Ctrl+C to exit.")
    select {}
}
```

---

### 5. 输出示例
```
Worker 1 processing task: Task-1
Worker 2 processing task: Task-2
...
Worker 10 processing task: Task-10
Worker 1 processing task: Task-11
...
```

---

### 6. 关键点说明
- **Actor 模型特性**：每个 Worker 是独立的 goroutine，通过 channel 接收任务，不共享状态。
- **并发控制**：通过 `numWorkers` 控制并发数（例如 CPU 核心数），避免资源耗尽。
- **任务分发**：使用轮询（`i%len(workers)`）将任务均匀分配到各个 Worker。
- **优雅关闭**：通过 `quitCh` 通知 Worker 停止，避免 goroutine 泄漏。

---

### 7. 优化建议
- **动态负载均衡**：根据 Worker 的任务队列长度动态分配任务。
- **任务优先级**：为 channel 增加优先级处理逻辑。
- **错误处理**：在 Worker 中捕获 panic，确保异常不会导致整个系统崩溃。

通过这种方式，你可以在 Go 中实现一个简单的 Actor 模型，高效处理并发任务。
