
# 一、使用golang和solidity编写代码完成Chainlink CCIP 的跨链操作


以下是一个基于 **Chainlink CCIP（Cross-Chain Interoperability Protocol）** 的完整跨链操作示例，包含 **Golang（后端交互）** 和 **Solidity（智能合约）** 代码，实现从以太坊到 Polygon 的 Token 跨链转移。

---

## **1. 整体架构**
![Chainlink CCIP 流程图](https://chain.link/assets/images/ccip/ccip-flow-diagram.png)
1. **源链（Ethereum）**: 用户调用合约发送跨链消息。
2. **Chainlink CCIP**: 路由消息并验证目标链状态。
3. **目标链（Polygon）**: 接收消息并执行操作。

---

## **2. Solidity 合约代码**
### **(1) 源链（Sender 合约）**
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import "@chainlink/contracts/src/v0.8/ccip/interfaces/IRouterClient.sol";
import "@chainlink/contracts/src/v0.8/ccip/libraries/Client.sol";

contract CCIPSender {
    IRouterClient public router;
    address public linkToken;
    uint64 public destinationChainId; // Polygon = 109

    constructor(address _router, address _linkToken, uint64 _destChainId) {
        router = IRouterClient(_router);
        linkToken = _linkToken;
        destinationChainId = _destChainId;
    }

    function sendMessage(
        address _receiver, 
        string memory _text,
        uint256 _amount
    ) external payable {
        // 构造跨链消息
        Client.EVM2AnyMessage memory message = Client.EVM2AnyMessage({
            receiver: abi.encode(_receiver),
            data: abi.encode(_text, _amount),
            tokenAmounts: new Client.EVMTokenAmount[](0), // 如果要传 Token 需额外配置
            feeToken: linkToken, // 使用 LINK 支付手续费
            extraArgs: ""
        });

        // 发送消息并支付手续费
        uint256 fee = router.getFee(destinationChainId, message);
        require(msg.value >= fee, "Insufficient fee");
        router.ccipSend{value: fee}(destinationChainId, message);
    }
}
```

### **(2) 目标链（Receiver 合约）**
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import "@chainlink/contracts/src/v0.8/ccip/interfaces/IAny2EVMMessageReceiver.sol";

contract CCIReceiver is IAny2EVMMessageReceiver {
    event MessageReceived(
        address indexed sender,
        string text,
        uint256 amount
    );

    function ccipReceive(
        Client.Any2EVMMessage calldata message
    ) external override {
        (string memory text, uint256 amount) = abi.decode(message.data, (string, uint256));
        emit MessageReceived(message.sender, text, amount);
    }
}
```

---

## **3. Golang 后端交互代码**
### **(1) 部署合约（依赖 ethclient）**
```go
package main

import (
	"context"
	"fmt"
	"log"
	"math/big"

	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/ethclient"
)

func main() {
	client, err := ethclient.Dial("https://eth-mainnet.g.alchemy.com/v2/YOUR_KEY")
	if err != nil {
		log.Fatal(err)
	}

	privateKey := "YOUR_PRIVATE_KEY"
	chainID := big.NewInt(1) // Ethereum Mainnet
	auth := bind.NewKeyedTransactor(privateKey, chainID)

	// 部署 Sender 合约
	routerAddress := common.HexToAddress("0xRouterAddress...")
	linkTokenAddress := common.HexToAddress("0x514910771AF9Ca656af840dff83E8264EcF986CA")
	destChainID := uint64(109) // Polygon 的 Chain ID

	senderAddr, tx, _, err := DeployCCIPSender(
		auth,
		client,
		routerAddress,
		linkTokenAddress,
		destChainID,
	)
	if err != nil {
		log.Fatal("Deploy failed:", err)
	}
	fmt.Println("Sender deployed at:", senderAddr.Hex())
}
```

### **(2) 调用跨链发送**
```go
func sendCrossChainMessage(
	senderContractAddr common.Address,
	receiverAddr common.Address,
	text string,
	amount *big.Int,
) {
	instance, err := NewCCIPSender(senderContractAddr, client)
	if err != nil {
		log.Fatal(err)
	}

	tx, err := instance.SendMessage(&bind.TransactOpts{
		From:    auth.From,
		Value:   big.NewInt(1e17), // 0.1 ETH 作为手续费
		Context: context.Background(),
	}, receiverAddr, text, amount)
	if err != nil {
		log.Fatal("SendMessage failed:", err)
	}
	fmt.Println("Transaction sent:", tx.Hash().Hex())
}
```

---

## **4. 关键配置**
| 参数                | 值（示例）                          |
|---------------------|-----------------------------------|
| **Ethereum Router** | `0xRouterAddress...` (查看 [Chainlink 文档](https://docs.chain.link/ccip)) |
| **Polygon Chain ID** | `109` (测试网可能是 `10109`)        |
| **LINK Token**      | `0x514910771AF9Ca656af840dff83E8264EcF986CA` |

---

## **5. 操作流程**
1. **部署合约**  
   - 在以太坊上部署 `CCIPSender`。
   - 在 Polygon 上部署 `CCReceiver`。

2. **发送跨链消息**  
   ```go
   sendCrossChainMessage(
       senderAddr,
       common.HexToAddress("PolygonReceiverAddress"),
       "Hello Polygon!",
       big.NewInt(100),
   )
   ```

3. **监听目标链事件**  
   ```go
   // 使用 ethclient 监听 CCIReceiver 的 MessageReceived 事件
   ```

---

## **6. 注意事项**
1. **手续费支付**：CCIP 需用 LINK 或原生代币支付手续费。
2. **Gas 限制**：跨链消息的 Gas 需足够覆盖目标链操作。
3. **安全验证**：目标链合约需校验消息来源（`msg.sender` 应为 Chainlink Router）。

---

通过以上代码，你可以快速实现基于 **Chainlink CCIP** 的跨链通信。如果需要进一步优化（如 Token 跨链），可扩展 `EVMTokenAmount` 字段。


# 二、来自学习文档

## Chainlink CCIP 跨链发送 ERC20 Token 示例
CCIP官方文档地址：https://docs.chain.link/ccip

```go
以下是一个完整的示例，展示如何使用 Chainlink 的跨链互操作性协议 (CCIP) 在不同的区块链网络之间发送 ERC20 Token。

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import "@chainlink/contracts-ccip/src/v0.8/ccip/applications/CCIPSender.sol";
import "@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

contract CrossChainTokenTransferSender is CCIPSender {
    using SafeERC20 for IERC20;
    
    // 事件记录
    event TokensSent(
        bytes32 indexed messageId,
        uint64 indexed destinationChainSelector,
        address receiver,
        address token,
        uint256 tokenAmount,
        address feeToken,
        uint256 fees
    );

    constructor(address router) CCIPSender(router) {}
    
    /**
     * 发送ERC20 Token到目标链
     * @param destinationChainSelector 目标链的ChainSelector
     * @param receiver 目标链上的接收合约地址
     * @param token ERC20 Token地址
     * @param amount 发送数量
     */
    function sendToken(
        uint64 destinationChainSelector,
        address receiver,
        address token,
        uint256 amount
    ) external returns (bytes32 messageId) {
        // 转移Token到本合约
        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);
        
        // 授权给路由器使用Token
        IERC20(token).safeApprove(address(i_router), amount);
        
        // 构造CCIP消息
        Client.EVMTokenAmount[] memory tokenAmounts = new Client.EVMTokenAmount[](1);
        tokenAmounts[0] = Client.EVMTokenAmount({
            token: token,
            amount: amount
        });
        
        Client.EVM2AnyMessage memory message = Client.EVM2AnyMessage({
            receiver: abi.encode(receiver),
            data: "",
            tokenAmounts: tokenAmounts,
            extraArgs: "",
            feeToken: address(0) // 使用原生代币支付费用
        });
        
        // 获取费用估算
        uint256 fee = i_router.getFee(destinationChainSelector, message);
        
        // 发送跨链消息
        messageId = i_router.ccipSend(destinationChainSelector, message);
        
        emit TokensSent(
            messageId,
            destinationChainSelector,
            receiver,
            token,
            amount,
            address(0),
            fee
        );
    }
}
```
```go
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import "@chainlink/contracts-ccip/src/v0.8/ccip/applications/CCIPReceiver.sol";
import "@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

contract CrossChainTokenTransferReceiver is CCIPReceiver {
    using SafeERC20 for IERC20;
    
    // 事件记录
    event TokensReceived(
        bytes32 indexed messageId,
        uint64 indexed sourceChainSelector,
        address sender,
        address token,
        uint256 tokenAmount
    );

    constructor(address router) CCIPReceiver(router) {}
    
    /**
     * 接收来自源链的Token
     */
    function _ccipReceive(
        Client.Any2EVMMessage memory message
    ) internal override {
        // 解析消息
        address sender = abi.decode(message.sender, (address));
        uint64 sourceChainSelector = message.sourceChainSelector;
        
        // 处理接收到的Token
        for (uint256 i = 0; i < message.tokenAmounts.length; i++) {
            Client.EVMTokenAmount memory tokenAmount = message.tokenAmounts[i];
            
            // 将Token转给消息发送者指定的接收者
            IERC20(tokenAmount.token).safeTransfer(
                abi.decode(message.receiver, (address)),
                tokenAmount.amount
            );
            
            emit TokensReceived(
                message.messageId,
                sourceChainSelector,
                sender,
                tokenAmount.token,
                tokenAmount.amount
            );
        }
    }
}
```
    部署步骤
    在源链和目标链上分别部署上述合约
    需要传入Chainlink CCIP路由器的地址（不同链的地址不同）
    关键参数说明
    参数	说明
    destinationChainSelector	目标链的唯一标识符，例如:
    - Ethereum Mainnet: 5009297550715157269
    - Polygon: 4051577828743386545
    i_router	Chainlink CCIP路由器地址，不同链不同:
    - Ethereum: 0xE1053aE1857476f36A3C62580FF9b016E8EE8F6f
    - Polygon: 0x70499c328e1E2a3c41108bd3730F6670a44595D1
    feeToken	支付费用的代币，address(0)表示使用原生代币
##  注意事项    注意事项
###     费用估算:
    每次发送前需要调用getFee()估算费用
    费用会随网络状况波动
###     Token支持:
    确保Token在两个链上都存在
    可能需要使用Chainlink的Token池服务
###     Gas设置:
    跨链交易需要足够的Gas
    建议使用Gas估算工具
###     安全考虑:
    只信任官方Chainlink路由器
    验证接收方的合约地址
###     测试网:
    先在测试网(如Sepolia、Mumbai)测试
    测试网路由器地址与主网不同
    上面的例子是一个发送ERC20 Token的例子，其实我们可以发现他都是通过调用合约来完成的，我们可以通过写一个不同的更加复杂的合约来完成一些更加有趣的功能，而不仅仅是token传输。
