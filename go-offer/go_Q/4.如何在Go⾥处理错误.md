参考链接：https://cloud.tencent.com/developer/article/2311646

    ## 关键要点总结
    
    1. **总是检查错误**：不要忽略错误返回值
    2. **提供上下文**：使用 `fmt.Errorf` 和 `%w` 包装错误
    3. **定义清晰的错误类型**：使用自定义错误类型和哨兵错误
    4. **错误处理要具体**：使用 `errors.Is` 和 `errors.As` 进行精确的错误处理
    5. **考虑用户体验**：向用户返回友好的错误信息，但记录详细错误日志
    6. **错误应该可追溯**：保持错误链的完整性
    
    这种显式的错误处理方式虽然需要更多代码，但使得错误流程非常清晰，便于调试和维护。


在 Go 语言中，错误处理是一种核心的编程范式。Go 采用了显式错误返回的方式，而不是异常机制。以下是 Go 中错误处理的全面指南：

## 1. 基础错误处理

### 基本模式
```go
package main

import (
    "errors"
    "fmt"
    "os"
)

// 基本错误返回
func divide(a, b float64) (float64, error) {
    if b == 0 {
        return 0, errors.New("division by zero")
    }
    return a / b, nil
}

func main() {
    result, err := divide(10, 0)
    if err != nil {
        fmt.Println("Error:", err)
        return
    }
    fmt.Println("Result:", result)
}
```

### 文件操作示例
```go
func readFile(filename string) error {
    data, err := os.ReadFile(filename)
    if err != nil {
        return fmt.Errorf("failed to read file %s: %w", filename, err)
    }
    
    fmt.Println("File content:", string(data))
    return nil
}

func main() {
    if err := readFile("test.txt"); err != nil {
        fmt.Println("Error:", err)
        os.Exit(1)
    }
}
```

## 2. 创建自定义错误

### 使用 errors.New
```go
var (
    ErrNotFound     = errors.New("resource not found")
    ErrInvalidInput = errors.New("invalid input")
    ErrTimeout      = errors.New("operation timeout")
)

func findUser(id int) (string, error) {
    if id <= 0 {
        return "", ErrInvalidInput
    }
    if id > 100 {
        return "", ErrNotFound
    }
    return fmt.Sprintf("user-%d", id), nil
}
```

### 自定义错误类型
```go
type APIError struct {
    Code    int    `json:"code"`
    Message string `json:"message"`
    Details string `json:"details,omitempty"`
}

// 实现 error 接口
func (e *APIError) Error() string {
    return fmt.Sprintf("API Error %d: %s", e.Code, e.Message)
}

func NewAPIError(code int, message, details string) *APIError {
    return &APIError{
        Code:    code,
        Message: message,
        Details: details,
    }
}

func processRequest() error {
    // 模拟错误
    return NewAPIError(404, "User not found", "The requested user does not exist")
}
```

## 3. 错误包装和展开

### 错误包装（Error Wrapping）
```go
import (
    "errors"
    "fmt"
)

func processData(data string) error {
    if err := validate(data); err != nil {
        // 使用 %w 包装原始错误
        return fmt.Errorf("processing failed: %w", err)
    }
    return nil
}

func validate(data string) error {
    if len(data) == 0 {
        return errors.New("data cannot be empty")
    }
    return nil
}

func main() {
    err := processData("")
    if err != nil {
        fmt.Println("Error:", err)
        
        // 检查特定的错误
        if errors.Is(err, errors.New("data cannot be empty")) {
            fmt.Println("It's a validation error")
        }
    }
}
```

### errors.Is 和 errors.As
```go
func handleError() {
    err := processRequest()
    
    // 检查错误链中是否包含特定错误
    if errors.Is(err, ErrNotFound) {
        fmt.Println("Handle not found error")
        return
    }
    
    // 提取特定类型的错误
    var apiErr *APIError
    if errors.As(err, &apiErr) {
        fmt.Printf("API Error - Code: %d, Message: %s\n", apiErr.Code, apiErr.Message)
        return
    }
    
    // 通用错误处理
    if err != nil {
        fmt.Println("Generic error:", err)
    }
}
```

## 4. 实践中的错误处理模式

### 方法 1：及早返回
```go
func processUser(userID string, data []byte) error {
    // 验证输入
    if userID == "" {
        return errors.New("userID cannot be empty")
    }
    if len(data) == 0 {
        return errors.New("data cannot be empty")
    }
    
    // 业务逻辑
    user, err := getUser(userID)
    if err != nil {
        return fmt.Errorf("get user failed: %w", err)
    }
    
    err = saveUserData(user, data)
    if err != nil {
        return fmt.Errorf("save data failed: %w", err)
    }
    
    return nil
}
```

### 方法 2：错误聚合
```go
type MultiError struct {
    Errors []error
}

func (m *MultiError) Error() string {
    var msgs []string
    for _, err := range m.Errors {
        msgs = append(msgs, err.Error())
    }
    return strings.Join(msgs, "; ")
}

func (m *MultiError) Add(err error) {
    if err != nil {
        m.Errors = append(m.Errors, err)
    }
}

func (m *MultiError) HasError() bool {
    return len(m.Errors) > 0
}

func validateUser(user User) error {
    var errs MultiError
    
    if user.Name == "" {
        errs.Add(errors.New("name is required"))
    }
    if user.Email == "" {
        errs.Add(errors.New("email is required"))
    }
    if user.Age < 0 {
        errs.Add(errors.New("age cannot be negative"))
    }
    
    if errs.HasError() {
        return &errs
    }
    return nil
}
```

## 5. 中间件模式错误处理

### HTTP 错误处理中间件
```go
func ErrorHandler(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        defer func() {
            if err := recover(); err != nil {
                log.Printf("Panic recovered: %v", err)
                http.Error(w, "Internal Server Error", http.StatusInternalServerError)
            }
        }()
        
        next.ServeHTTP(w, r)
    })
}

type AppError struct {
    Status  int    `json:"status"`
    Message string `json:"message"`
}

func (e AppError) Error() string {
    return e.Message
}

func JSONError(w http.ResponseWriter, err error) {
    var appErr AppError
    if errors.As(err, &appErr) {
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(appErr.Status)
        json.NewEncoder(w).Encode(appErr)
    } else {
        http.Error(w, "Internal Server Error", http.StatusInternalServerError)
    }
}
```

## 6. 最佳实践和模式

### 1. 定义可导出的错误变量
```go
// 在包级别定义错误，便于测试和比较
var (
    ErrUserNotFound    = errors.New("user not found")
    ErrInvalidPassword = errors.New("invalid password")
    ErrEmailTaken      = errors.New("email already taken")
)
```

### 2. 使用哨兵错误（Sentinel Errors）
```go
func authenticate(email, password string) error {
    user, err := findUserByEmail(email)
    if err != nil {
        if errors.Is(err, ErrUserNotFound) {
            return ErrInvalidCredentials // 不暴露用户是否存在
        }
        return err
    }
    
    if !checkPassword(user, password) {
        return ErrInvalidCredentials
    }
    
    return nil
}

var ErrInvalidCredentials = errors.New("invalid credentials")
```

### 3. 上下文错误信息
```go
type ContextualError struct {
    Operation string
    Context   map[string]interface{}
    Cause     error
}

func (c *ContextualError) Error() string {
    return fmt.Sprintf("%s: %v (context: %v)", c.Operation, c.Cause, c.Context)
}

func WithContext(op string, ctx map[string]interface{}, err error) error {
    return &ContextualError{
        Operation: op,
        Context:   ctx,
        Cause:     err,
    }
}
```

## 7. 实际项目示例

```go
package main

import (
    "database/sql"
    "encoding/json"
    "errors"
    "fmt"
    "log"
    "net/http"
    "time"
    
    _ "github.com/lib/pq"
)

type UserService struct {
    db *sql.DB
}

func (s *UserService) GetUserProfile(userID string) (*UserProfile, error) {
    // 输入验证
    if userID == "" {
        return nil, &AppError{
            Status:  http.StatusBadRequest,
            Message: "userID is required",
            Code:    "INVALID_INPUT",
        }
    }
    
    // 数据库操作
    var profile UserProfile
    err := s.db.QueryRow(`
        SELECT id, name, email, created_at 
        FROM users WHERE id = $1
    `, userID).Scan(&profile.ID, &profile.Name, &profile.Email, &profile.CreatedAt)
    
    if err != nil {
        if errors.Is(err, sql.ErrNoRows) {
            return nil, &AppError{
                Status:  http.StatusNotFound,
                Message: "user not found",
                Code:    "USER_NOT_FOUND",
            }
        }
        // 包装数据库错误，不暴露底层细节
        return nil, fmt.Errorf("database query failed: %w", err)
    }
    
    return &profile, nil
}

func main() {
    service := &UserService{db: getDB()}
    
    http.HandleFunc("/users/", func(w http.ResponseWriter, r *http.Request) {
        userID := r.URL.Path[len("/users/"):]
        
        profile, err := service.GetUserProfile(userID)
        if err != nil {
            handleHTTPError(w, err)
            return
        }
        
        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(profile)
    })
    
    log.Println("Server starting on :8080")
    log.Fatal(http.ListenAndServe(":8080", nil))
}

func handleHTTPError(w http.ResponseWriter, err error) {
    var appErr *AppError
    if errors.As(err, &appErr) {
        w.WriteHeader(appErr.Status)
        json.NewEncoder(w).Encode(appErr)
        return
    }
    
    // 未知错误，记录但不暴露细节
    log.Printf("Internal server error: %v", err)
    http.Error(w, "Internal Server Error", http.StatusInternalServerError)
}
```

## 关键要点总结

1. **总是检查错误**：不要忽略错误返回值
2. **提供上下文**：使用 `fmt.Errorf` 和 `%w` 包装错误
3. **定义清晰的错误类型**：使用自定义错误类型和哨兵错误
4. **错误处理要具体**：使用 `errors.Is` 和 `errors.As` 进行精确的错误处理
5. **考虑用户体验**：向用户返回友好的错误信息，但记录详细错误日志
6. **错误应该可追溯**：保持错误链的完整性

这种显式的错误处理方式虽然需要更多代码，但使得错误流程非常清晰，便于调试和维护。
