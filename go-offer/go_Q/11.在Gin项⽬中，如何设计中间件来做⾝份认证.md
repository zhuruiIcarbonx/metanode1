# ä¸€ã€ä¸‰ç§æ–¹æ³•
åœ¨Ginæ¡†æ¶ä¸­ï¼Œè®¾è®¡èº«ä»½è®¤è¯ä¸­é—´ä»¶ä¸»è¦èƒ½é€šè¿‡ **HTTPåŸºç¡€è®¤è¯**ã€**JWTä»¤ç‰Œ** å’Œ **Sessionä¼šè¯** ç­‰æ–¹å¼å®ç°ã€‚é€‰æ‹©æ—¶ï¼Œå…³é”®éœ€è€ƒè™‘ **åº”ç”¨çš„å®‰å…¨è¦æ±‚**ã€**æ‰©å±•æ€§éœ€æ±‚** å’Œ **ç”¨æˆ·ä½“éªŒ**ã€‚é€šå¸¸ï¼š
- å¯¹äºç®€å•çš„å†…éƒ¨å·¥å…·æˆ–APIï¼Œå¯è€ƒè™‘HTTPåŸºç¡€è®¤è¯ã€‚
- å¯¹äºéœ€è¦æ‰©å±•æ€§å’Œæ— çŠ¶æ€è®¤è¯çš„åˆ†å¸ƒå¼åº”ç”¨ï¼ŒJWTæ˜¯ä¸é”™çš„é€‰æ‹©ã€‚
- è‹¥åº”ç”¨åŸºäºä¼ ç»Ÿçš„æµè§ˆå™¨ä¼šè¯ï¼Œåˆ™å¯è€ƒè™‘Sessionè®¤è¯ã€‚

ä¸‹é¢è¿™ä¸ªè¡¨æ ¼èƒ½å¸®ä½ å¿«é€Ÿäº†è§£å‡ ç§ä¸»è¦è®¤è¯æ–¹å¼çš„ç‰¹ç‚¹ï¼š

| è®¤è¯æ–¹å¼ | å®ç°éš¾åº¦ | å®‰å…¨æ€§ | æ‰©å±•æ€§ | æœ€ä½³é€‚ç”¨åœºæ™¯ |
| :--- | :--- | :--- | :--- | :--- |
| **HTTPåŸºç¡€è®¤è¯** | ä½ | ä¸­ï¼ˆéœ€æ­é…HTTPSï¼‰ | ä½ | å†…éƒ¨å·¥å…·ã€ç®€å•çš„APIä¿æŠ¤ |
| **JWTè®¤è¯** | ä¸­ | é«˜ï¼ˆä½¿ç”¨ç­¾åï¼Œå¯åŠ å¯†è½½è·ï¼‰ | é«˜ | åˆ†å¸ƒå¼ç³»ç»Ÿã€æ— çŠ¶æ€APIã€å•ç‚¹ç™»å½• |
| **Sessionè®¤è¯** | ä¸­ | é«˜ï¼ˆæœåŠ¡ç«¯å­˜å‚¨çŠ¶æ€ï¼‰ | ä¸­ | ä¼ ç»ŸWebåº”ç”¨ã€éœ€è¦æœåŠ¡ç«¯ä¼šè¯ç®¡ç†çš„åœºæ™¯ |

### ğŸ” è®¤è¯æ–¹å¼è¯¦è§£ä¸å®ç°

#### HTTPåŸºç¡€è®¤è¯
è¿™ç§æ–¹å¼éå¸¸ç®€å•ï¼Œé€‚åˆå¯¹å®‰å…¨æ€§è¦æ±‚ä¸é«˜çš„å†…éƒ¨åœºæ™¯ã€‚

- **å·¥ä½œåŸç†**ï¼šå®¢æˆ·ç«¯åœ¨è¯·æ±‚å¤´ä¸­æºå¸¦`Authorization: Basic <base64ç¼–ç çš„ç”¨æˆ·å:å¯†ç >`ã€‚æœåŠ¡å™¨è§£ç åéªŒè¯å‡­æ®ã€‚
- **Ginå®ç°**ï¼šGinæ¡†æ¶å†…ç½®äº†`gin.BasicAuth`ä¸­é—´ä»¶ã€‚
    ```go
    // ç¤ºä¾‹ï¼šä½¿ç”¨gin.BasicAuthä¸­é—´ä»¶
    router := gin.Default()
    // é…ç½®æˆæƒçš„è´¦æˆ·
    accounts := gin.Accounts{
        "admin": "secretpassword",
        "user":  "123456",
    }
    // åº”ç”¨ä¸­é—´ä»¶
    authMiddleware := gin.BasicAuth(accounts)
    router.Use(authMiddleware)
    
    // å—ä¿æŠ¤çš„è·¯ç”±
    router.GET("/protected", func(c *gin.Context) {
        user := c.MustGet(gin.AuthUserKey).(string) // è·å–è®¤è¯ç”¨æˆ·å
        c.JSON(200, gin.H{"message": "Hello " + user})
    })
    router.Run(":8080")
    ```
- **æ³¨æ„**ï¼šHTTPåŸºç¡€è®¤è¯**åŠ¡å¿…ä¸HTTPSé…åˆä½¿ç”¨**ï¼Œå¦åˆ™å‡­æ®å®¹æ˜“è¢«çªƒå¬ã€‚

#### JWTï¼ˆJSON Web Tokenï¼‰è®¤è¯
JWTé€‚ç”¨äºéœ€è¦æ‰©å±•æ€§å’Œæ— çŠ¶æ€è®¤è¯çš„åˆ†å¸ƒå¼åº”ç”¨ã€‚

- **å·¥ä½œåŸç†**ï¼šæœåŠ¡å™¨åœ¨ç”¨æˆ·ç™»å½•åç”Ÿæˆä¸€ä¸ªç­¾åçš„Tokenè¿”å›ç»™å®¢æˆ·ç«¯ã€‚å®¢æˆ·ç«¯åœ¨åç»­è¯·æ±‚çš„`Authorization: Bearer <token>`å¤´ä¸­æºå¸¦æ­¤Tokenã€‚æœåŠ¡å™¨éªŒè¯Tokençš„ç­¾åå’Œæœ‰æ•ˆæ€§ã€‚
- **Ginå®ç°**ï¼šé€šå¸¸éœ€è¦è‡ªå®šä¹‰ä¸­é—´ä»¶æˆ–ä½¿ç”¨ç¬¬ä¸‰æ–¹åº“ï¼ˆå¦‚`gin-jwt`ï¼‰ã€‚
    ```go
    // ç¤ºä¾‹ï¼šè‡ªå®šä¹‰JWTè®¤è¯ä¸­é—´ä»¶ï¼ˆéœ€å¼•å…¥github.com/dgrijalva/jwt-goç­‰åº“ï¼‰
    func JWTAuthMiddleware() gin.HandlerFunc {
        return func(c *gin.Context) {
            // 1. ä»è¯·æ±‚å¤´è·å–Token
            tokenString := c.GetHeader("Authorization")
            if tokenString == "" || !strings.HasPrefix(tokenString, "Bearer ") {
                c.JSON(401, gin.H{"error": "æœªæä¾›æœ‰æ•ˆçš„Token"})
                c.Abort()
                return
            }
            tokenString = tokenString[7:] // å»æ‰"Bearer "å‰ç¼€

            // 2. è§£æå¹¶éªŒè¯Token
            token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {
                // éªŒè¯ç­¾åç®—æ³•å¹¶è¿”å›å¯†é’¥
                if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
                    return nil, fmt.Errorf("æ„å¤–çš„ç­¾åæ–¹æ³•: %v", token.Header["alg"])
                }
                return []byte("your-secret-key"), nil // è¿™é‡Œæ›¿æ¢ä¸ºä½ çš„å¯†é’¥
            })

            if err != nil || !token.Valid {
                c.JSON(401, gin.H{"error": "æ— æ•ˆçš„Token"})
                c.Abort()
                return
            }

            // 3. ä»Tokenå£°æ˜ä¸­æå–ä¿¡æ¯å¹¶å­˜å…¥ä¸Šä¸‹æ–‡
            if claims, ok := token.Claims.(jwt.MapClaims); ok {
                c.Set("userID", claims["userID"])
                c.Set("userName", claims["userName"])
            } else {
                c.JSON(401, gin.H{"error": "æ— æ³•è§£æTokenå£°æ˜"})
                c.Abort()
                return
            }

            c.Next()
        }
    }
    
    // ä½¿ç”¨ä¸­é—´ä»¶
    router := gin.Default()
    router.GET("/api/profile", JWTAuthMiddleware(), func(c *gin.Context) {
        // ä»ä¸Šä¸‹æ–‡ä¸­è·å–ç”¨æˆ·ä¿¡æ¯
        userID := c.GetString("userID")
        userName := c.GetString("userName")
        c.JSON(200, gin.H{"userID": userID, "userName": userName})
    })
    ```
- **å…³é”®æ­¥éª¤**ï¼š
    1. **ç™»å½•æ¥å£ç­¾å‘Token**ï¼šç”¨æˆ·ç™»å½•éªŒè¯æˆåŠŸåï¼ŒæœåŠ¡å™¨ä½¿ç”¨å¯†é’¥ç”ŸæˆJWTå¹¶è¿”å›ã€‚
    2. **ä¸­é—´ä»¶éªŒè¯Token**ï¼šåœ¨éœ€è¦è®¤è¯çš„è·¯ç”±ä¸Šæ·»åŠ JWTä¸­é—´ä»¶ï¼ŒéªŒè¯è¯·æ±‚å¤´ä¸­çš„Tokenã€‚
    3. **å¤„ç†Tokenè¿‡æœŸ**ï¼šJWTé€šå¸¸åŒ…å«è¿‡æœŸæ—¶é—´ï¼Œä¸­é—´ä»¶ä¼šè‡ªåŠ¨éªŒè¯ã€‚

#### Sessionè®¤è¯
è¿™ç§æ–¹å¼ä¾èµ–æœåŠ¡ç«¯å­˜å‚¨ä¼šè¯çŠ¶æ€ï¼Œé€‚ç”¨äºä¼ ç»Ÿçš„Webåº”ç”¨ã€‚

- **å·¥ä½œåŸç†**ï¼šç”¨æˆ·ç™»å½•åï¼ŒæœåŠ¡å™¨åˆ›å»ºSessionå¹¶å°†ä¼šè¯IDé€šè¿‡Cookieè¿”å›ç»™æµè§ˆå™¨ã€‚æµè§ˆå™¨åç»­è¯·æ±‚è‡ªåŠ¨æºå¸¦æ­¤Cookieï¼ŒæœåŠ¡å™¨æ ¹æ®ä¼šè¯IDéªŒè¯ç”¨æˆ·çŠ¶æ€ã€‚
- **Ginå®ç°**ï¼šå¯ä½¿ç”¨`gin-contrib/sessions`ä¸­é—´ä»¶ã€‚
    ```go
    // ç¤ºä¾‹ï¼šä½¿ç”¨Sessionä¸­é—´ä»¶ (éœ€å®‰è£… github.com/gin-contrib/sessions)
    import (
        "github.com/gin-contrib/sessions"
        "github.com/gin-contrib/sessions/cookie"
        "github.com/gin-gonic/gin"
    )
    
    func main() {
        router := gin.Default()
        // åˆå§‹åŒ–Sessionå­˜å‚¨ï¼ˆä½¿ç”¨Cookieå­˜å‚¨ï¼Œç”Ÿäº§ç¯å¢ƒå¯è€ƒè™‘Redisï¼‰
        store := cookie.NewStore([]byte("secret")) // æ›¿æ¢ä¸€ä¸ªå¤æ‚çš„å¯†é’¥
        router.Use(sessions.Sessions("mysession", store))
        
        // ç™»å½•å¤„ç†
        router.POST("/login", func(c *gin.Context) {
            // ... éªŒè¯ç”¨æˆ·åå¯†ç  ...
            session := sessions.Default(c)
            session.Set("authenticated", true)
            session.Set("userID", "123456") // å­˜å‚¨ç”¨æˆ·ä¿¡æ¯
            session.Save()
            c.JSON(200, gin.H{"message": "ç™»å½•æˆåŠŸ"})
        })
        
        // è‡ªå®šä¹‰Sessionè®¤è¯ä¸­é—´ä»¶
        authSessionMiddleware := func(c *gin.Context) {
            session := sessions.Default(c)
            auth := session.Get("authenticated")
            if auth == nil || auth.(bool) != true {
                c.JSON(401, gin.H{"error": "æœªæˆæƒ"})
                c.Abort()
                return
            }
            // ç”¨æˆ·å·²è®¤è¯ï¼Œç»§ç»­
            c.Next()
        }
        
        // å—ä¿æŠ¤çš„è·¯ç”±
        router.GET("/protected", authSessionMiddleware, func(c *gin.Context) {
            session := sessions.Default(c)
            userID := session.Get("userID")
            c.JSON(200, gin.H{"message": "è®¿é—®å—ä¿æŠ¤èµ„æº", "userID": userID})
        })
    }
    ```

### ğŸ’¡ è®¾è®¡è®¤è¯ä¸­é—´ä»¶çš„å…³é”®è¦ç‚¹

1.  **å–„ç”¨ç™½åå•**ï¼šå¯¹äºç™»å½•ã€æ³¨å†Œç­‰å…¬å¼€æ¥å£ï¼Œåº”åœ¨è®¤è¯ä¸­é—´ä»¶ä¸­è®¾ç½®**ç™½åå•**ï¼Œé¿å…è¿™äº›è¯·æ±‚è¢«æ‹¦æˆªã€‚å¯ä»¥åœ¨ä¸­é—´ä»¶å¼€å¤´æ£€æŸ¥å½“å‰è¯·æ±‚è·¯å¾„æ˜¯å¦åœ¨ç™½åå•å†…ï¼Œå¦‚æœæ˜¯åˆ™ç›´æ¥æ”¾è¡Œ (`c.Next()`)ã€‚
2.  **åˆ©ç”¨ä¸Šä¸‹æ–‡ä¼ é€’æ•°æ®**ï¼šè®¤è¯é€šè¿‡åï¼Œä¸­é—´ä»¶åº”é€šè¿‡`c.Set("key", value)`å°†ç”¨æˆ·IDã€è§’è‰²ç­‰ä¿¡æ¯å­˜å…¥Ginçš„ä¸Šä¸‹æ–‡ï¼Œä¾¿äºåç»­å¤„ç†å‡½æ•°ä½¿ç”¨ã€‚
3.  **å®‰å…¨çš„å¯†ç å¤„ç†**ï¼šæ— è®ºä½¿ç”¨å“ªç§æ–¹å¼ï¼ŒæœåŠ¡ç«¯éƒ½**ä¸åº”æ˜æ–‡å­˜å‚¨å¯†ç **ã€‚åº”ä½¿ç”¨**bcrypt**ç­‰å®‰å…¨å“ˆå¸Œç®—æ³•å¤„ç†å¯†ç ã€‚
4.  **è€ƒè™‘ç»“åˆHTTPS**ï¼šæ‰€æœ‰è®¤è¯æ–¹å¼çš„å®‰å…¨æ€§åœ¨HTTPSåŠ å¯†é€šé“ä¸‹ä¼šæ›´æœ‰ä¿éšœï¼Œèƒ½æœ‰æ•ˆé˜²æ­¢ä¸­é—´äººæ”»å‡»ã€‚

### ğŸ¤” å¦‚ä½•é€‰æ‹©é€‚åˆçš„è®¤è¯æ–¹å¼

é€‰æ‹©æ—¶ï¼Œä¸»è¦è€ƒè™‘ä»¥ä¸‹å‡ ç‚¹ï¼š
- **åº”ç”¨åœºæ™¯**ï¼šæ˜¯æ— çŠ¶æ€çš„APIæœåŠ¡ï¼Œè¿˜æ˜¯æœ‰çŠ¶æ€çš„Webåº”ç”¨ï¼Ÿ
- **å®‰å…¨éœ€æ±‚**ï¼šéœ€è¦å¤šé«˜çš„å®‰å…¨çº§åˆ«ï¼Ÿ
- **æ‰©å±•æ€§è¦æ±‚**ï¼šæ˜¯å¦éœ€è¦æ”¯æŒåˆ†å¸ƒå¼éƒ¨ç½²ï¼Ÿ
- **å¼€å‘ä¸ç»´æŠ¤æˆæœ¬**ï¼šå›¢é˜Ÿå¯¹å“ªç§æŠ€æœ¯æ›´ç†Ÿæ‚‰ï¼Ÿ

å¸Œæœ›è¿™äº›ä¿¡æ¯èƒ½å¸®åŠ©ä½ è®¾è®¡å‡ºé€‚åˆä½ Giné¡¹ç›®çš„èº«ä»½è®¤è¯ä¸­é—´ä»¶ã€‚æ ¹æ®ä½ çš„å…·ä½“åœºæ™¯ï¼Œå¦‚æœæŸç§æ–¹å¼æ›´å¸å¼•ä½ ï¼Œæˆ‘å¯ä»¥æä¾›æ›´æ·±å…¥çš„ä¾‹å­ã€‚





# äºŒã€jwtç»“åˆredis

åœ¨Ginæ¡†æ¶ä¸­ï¼Œç»“åˆRediså®ç°èº«ä»½è®¤è¯æ˜¯ä¸€ä¸ªæ—¢å®ç”¨åˆé«˜æ•ˆçš„æ–¹æ¡ˆã€‚ä¸‹é¢æˆ‘å°†ä¸ºä½ è¯¦ç»†ä»‹ç»å¦‚ä½•è®¾è®¡ä¸­é—´ä»¶ï¼Œå¹¶åˆ©ç”¨Redisè¿›è¡Œèº«ä»½è®¤è¯ã€‚

## ğŸ”‘ ä¸­é—´ä»¶åŸºç¡€ä¸è®¤è¯æµç¨‹

### ä¸­é—´ä»¶æ ¸å¿ƒæ¦‚å¿µ
åœ¨Ginæ¡†æ¶ä¸­ï¼Œä¸­é—´ä»¶æœ¬è´¨ä¸Šæ˜¯`gin.HandlerFunc`ç±»å‹ï¼Œå®ƒå…è®¸ä½ åœ¨è¯·æ±‚åˆ°è¾¾å¤„ç†ç¨‹åºå‰åæ‰§è¡Œç‰¹å®šé€»è¾‘ã€‚Giné€šè¿‡**æ´‹è‘±æ¨¡å‹**å¤„ç†ä¸­é—´ä»¶ï¼Œå³è¯·æ±‚å…ˆé€å±‚ç©¿è¿‡ä¸­é—´ä»¶ï¼Œåˆ°è¾¾å¤„ç†å‡½æ•°åå†é€†åºè¿”å›ã€‚

### èº«ä»½è®¤è¯æµç¨‹è®¾è®¡
1. **ç”¨æˆ·ç™»å½•**ï¼šå®¢æˆ·ç«¯æäº¤å‡­è¯ï¼ŒæœåŠ¡ç«¯éªŒè¯é€šè¿‡åç”ŸæˆTokenå¹¶å­˜å…¥Redis
2. **Tokenä¼ é€’**ï¼šå®¢æˆ·ç«¯åœ¨åç»­è¯·æ±‚çš„`Authorization`å¤´ä¸­æºå¸¦Token
3. **TokenéªŒè¯**ï¼šä¸­é—´ä»¶æ ¡éªŒTokenæœ‰æ•ˆæ€§å¹¶ä»Redisè·å–ç”¨æˆ·ä¿¡æ¯
4. **è¯·æ±‚å¤„ç†**ï¼šéªŒè¯é€šè¿‡åï¼Œå°†ç”¨æˆ·ä¿¡æ¯å­˜å…¥ä¸Šä¸‹æ–‡ï¼Œç»§ç»­å¤„ç†è¯·æ±‚

## ğŸ› ï¸ Redisé…ç½®ä¸å·¥å…·ç±»

é¦–å…ˆé…ç½®Redisè¿æ¥ï¼Œè¿™æ˜¯å­˜å‚¨Tokençš„åŸºç¡€ï¼š

```go
package main

import (
    "encoding/json"
    "fmt"
    "time"
    
    "github.com/gin-gonic/gin"
    "github.com/go-redis/redis/v8"
    "golang.org/x/net/context"
)

var redisClient *redis.Client

func initRedis() {
    redisClient = redis.NewClient(&redis.Options{
        Addr:     "localhost:6379", // RedisæœåŠ¡å™¨åœ°å€
        Password: "",               // å¯†ç ï¼Œæ²¡æœ‰åˆ™ä¸ºç©º
        DB:       0,                // ä½¿ç”¨é»˜è®¤DB
    })
    
    // æµ‹è¯•è¿æ¥
    ctx := context.Background()
    if err := redisClient.Ping(ctx).Err(); err != nil {
        panic(fmt.Sprintf("Redisè¿æ¥å¤±è´¥: %v", err))
    }
}

// Redisæ“ä½œå·¥å…·å‡½æ•°
func setRedis(key string, value interface{}, expiration time.Duration) error {
    ctx := context.Background()
    data, err := json.Marshal(value)
    if err != nil {
        return err
    }
    return redisClient.Set(ctx, key, data, expiration).Err()
}

func getRedis(key string) (string, error) {
    ctx := context.Background()
    return redisClient.Get(ctx, key).String()
}

func expireRedis(key string, expiration time.Duration) error {
    ctx := context.Background()
    return redisClient.Expire(ctx, key, expiration).Err()
}

func delRedis(key string) error {
    ctx := context.Background()
    return redisClient.Del(ctx, key).Err()
}
```

## ğŸ” ç™»å½•æ¥å£ä¸Tokenç”Ÿæˆ

å®ç°ç™»å½•æ¥å£ï¼Œç”ŸæˆTokenå¹¶å­˜å‚¨åˆ°Redisï¼š

```go
package main

import (
    "crypto/rand"
    "fmt"
    "net/http"
    "time"
)

type User struct {
    ID       uint   `json:"id"`
    Username string `json:"username"`
    Password string `json:"password"` // å®é™…ç”Ÿäº§ä¸­åº”å­˜å‚¨å“ˆå¸Œå€¼
}

type LoginRequest struct {
    Username string `json:"username" binding:"required"`
    Password string `json:"password" binding:"required"`
}

type LoginResponse struct {
    Token    string `json:"token"`
    UserInfo User   `json:"userinfo"`
}

// ç”ŸæˆéšæœºToken
func generateToken(length int) string {
    str := "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
    bytes := []byte(str)
    result := make([]byte, length)
    
    buffer := make([]byte, length)
    rand.Read(buffer) // ä½¿ç”¨crypto/randå¢å¼ºå®‰å…¨æ€§
    
    for i := 0; i < length; i++ {
        result[i] = bytes[int(buffer[i])%len(bytes)]
    }
    return string(result)
}

// ç™»å½•å¤„ç†å‡½æ•°
func LoginHandler(c *gin.Context) {
    var req LoginRequest
    if err := c.BindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": "è¯·æ±‚å‚æ•°é”™è¯¯"})
        return
    }
    
    // å®é™…é¡¹ç›®ä¸­åº”ä»æ•°æ®åº“éªŒè¯ç”¨æˆ·
    // è¿™é‡Œç®€åŒ–ä¸ºç›´æ¥éªŒè¯
    if req.Username != "admin" || req.Password != "123456" {
        c.JSON(http.StatusUnauthorized, gin.H{"error": "ç”¨æˆ·åæˆ–å¯†ç é”™è¯¯"})
        return
    }
    
    // ç”ŸæˆToken
    token := generateToken(32)
    
    // æ„å»ºç”¨æˆ·ä¿¡æ¯ï¼ˆå®é™…é¡¹ç›®ä¸­åº”ä»æ•°æ®åº“è·å–ï¼‰
    user := User{
        ID:       1,
        Username: req.Username,
    }
    
    // å°†ç”¨æˆ·ä¿¡æ¯å­˜å…¥Redisï¼Œæœ‰æ•ˆæœŸ10åˆ†é’Ÿ
    if err := setRedis(token, user, 10*time.Minute); err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": "æœåŠ¡å™¨å†…éƒ¨é”™è¯¯"})
        return
    }
    
    c.JSON(http.StatusOK, LoginResponse{
        Token:    token,
        UserInfo: user,
    })
}
```

## ğŸš¦ è®¤è¯ä¸­é—´ä»¶å®ç°

æ ¸å¿ƒçš„è®¤è¯ä¸­é—´ä»¶ï¼ŒéªŒè¯Tokenå¹¶ä»Redisè·å–ç”¨æˆ·ä¿¡æ¯ï¼š

```go
package main

import (
    "errors"
    "net/http"
    
    "github.com/gin-gonic/gin"
)

// ä»Redisè·å–ç”¨æˆ·ä¿¡æ¯
func GetCurrentUserInfo(c *gin.Context) (User, error) {
    var user User
    token := c.GetHeader("Authorization")
    
    if token == "" {
        return user, errors.New("æœªæä¾›è®¤è¯Token")
    }
    
    userInfo, err := getRedis(token)
    if err != nil || userInfo == "" {
        return user, errors.New("Tokenæ— æ•ˆæˆ–å·²è¿‡æœŸ")
    }
    
    // è§£æç”¨æˆ·ä¿¡æ¯
    if err := json.Unmarshal([]byte(userInfo), &user); err != nil {
        return user, errors.New("ç”¨æˆ·ä¿¡æ¯è§£æå¤±è´¥")
    }
    
    // åˆ·æ–°Tokenæœ‰æ•ˆæœŸï¼ˆå¯é€‰ï¼‰
    expireRedis(token, 10*time.Minute)
    
    return user, nil
}

// è®¤è¯ä¸­é—´ä»¶
func AuthMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        user, err := GetCurrentUserInfo(c)
        if err != nil {
            c.JSON(http.StatusUnauthorized, gin.H{
                "error": "è®¤è¯å¤±è´¥",
                "msg":   err.Error(),
            })
            c.Abort() // é˜»æ­¢åç»­å¤„ç†å‡½æ•°æ‰§è¡Œ
            return
        }
        
        // å°†ç”¨æˆ·ä¿¡æ¯å­˜å‚¨åˆ°ä¸Šä¸‹æ–‡ï¼Œåç»­å¤„ç†å‡½æ•°å¯ä»¥ä½¿ç”¨
        c.Set("user", user)
        c.Set("userID", user.ID)
        
        c.Next() // ç»§ç»­æ‰§è¡Œåç»­ä¸­é—´ä»¶æˆ–å¤„ç†ç¨‹åº
    }
}

// å¯é€‰ï¼šç®¡ç†å‘˜æƒé™æ£€æŸ¥ä¸­é—´ä»¶
func AdminAuthMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        user, exists := c.Get("user")
        if !exists {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "æœªè®¤è¯"})
            c.Abort()
            return
        }
        
        // è¿™é‡Œå¯ä»¥æ·»åŠ è§’è‰²æ£€æŸ¥é€»è¾‘
        // ä¾‹å¦‚ï¼šif user.(User).Role != "admin" { ... }
        
        c.Next()
    }
}
```

## ğŸ¯ è·¯ç”±é…ç½®ä¸ä½¿ç”¨

é…ç½®è·¯ç”±ï¼Œåº”ç”¨è®¤è¯ä¸­é—´ä»¶ï¼š

```go
package main

import "github.com/gin-gonic/gin"

func main() {
    // åˆå§‹åŒ–Redis
    initRedis()
    
    r := gin.Default()
    
    // å…¬å…±è·¯ç”± - æ— éœ€è®¤è¯
    r.POST("/login", LoginHandler)
    r.GET("/public", func(c *gin.Context) {
        c.JSON(http.StatusOK, gin.H{"message": "è¿™æ˜¯å…¬å¼€æ¥å£"})
    })
    
    // éœ€è¦è®¤è¯çš„è·¯ç”±ç»„
    authGroup := r.Group("/api")
    authGroup.Use(AuthMiddleware()) // åº”ç”¨è®¤è¯ä¸­é—´ä»¶
    {
        authGroup.GET("/profile", func(c *gin.Context) {
            user, _ := c.Get("user")
            c.JSON(http.StatusOK, gin.H{
                "message": "è·å–ç”¨æˆ·èµ„æ–™",
                "user":    user,
            })
        })
        
        authGroup.GET("/dashboard", func(c *gin.Context) {
            c.JSON(http.StatusOK, gin.H{"message": "ä»ªè¡¨ç›˜æ•°æ®"})
        })
    }
    
    // éœ€è¦ç®¡ç†å‘˜æƒé™çš„è·¯ç”±ç»„
    adminGroup := r.Group("/admin")
    adminGroup.Use(AuthMiddleware(), AdminAuthMiddleware()) // é“¾å¼ä¸­é—´ä»¶
    {
        adminGroup.GET("/users", func(c *gin.Context) {
            c.JSON(http.StatusOK, gin.H{"message": "ç”¨æˆ·ç®¡ç†"})
        })
    }
    
    r.Run(":8080")
}
```

## âš¡ è¿›é˜¶ç‰¹æ€§ä¸ä¼˜åŒ–å»ºè®®

### 1. ä½¿ç”¨JWTæ›¿ä»£éšæœºTokenï¼ˆå¯é€‰ï¼‰
å¦‚æœéœ€è¦æ— çŠ¶æ€è®¤è¯ï¼Œå¯ä»¥ç»“åˆJWTï¼š

```go
import "github.com/dgrijalva/jwt-go"

func GenerateJWT(user User) (string, error) {
    token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
        "user_id":  user.ID,
        "username": user.Username,
        "exp":      time.Now().Add(24 * time.Hour).Unix(),
    })
    
    return token.SignedString([]byte("your-secret-key"))
}

func JWTAuthMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        tokenString := c.GetHeader("Authorization")
        if tokenString == "" {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "æœªæä¾›Token"})
            c.Abort()
            return
        }
        
        token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {
            if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
                return nil, fmt.Errorf("æ„å¤–çš„ç­¾åæ–¹æ³•: %v", token.Header["alg"])
            }
            return []byte("your-secret-key"), nil
        })
        
        if err != nil || !token.Valid {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "Tokenæ— æ•ˆ"})
            c.Abort()
            return
        }
        
        // TokenéªŒè¯æˆåŠŸï¼Œç»§ç»­å¤„ç†
        c.Next()
    }
}
```

### 2. æ€§èƒ½ä¼˜åŒ–å»ºè®®
- **è¿æ¥æ± **ï¼šé…ç½®Redisè¿æ¥æ± æé«˜æ€§èƒ½
- **ç¼“å­˜ç­–ç•¥**ï¼šå¯¹é¢‘ç¹è®¿é—®çš„ç”¨æˆ·ä¿¡æ¯è¿›è¡Œé€‚å½“ç¼“å­˜
- **Tokené»‘åå•**ï¼šå®ç°ç™»å‡ºåŠŸèƒ½æ—¶å°†æœªè¿‡æœŸçš„TokenåŠ å…¥é»‘åå•

### 3. å®‰å…¨å¢å¼º
- ä½¿ç”¨HTTPSä¼ è¾“
- Tokenè®¾ç½®åˆç†çš„è¿‡æœŸæ—¶é—´
- å®ç°Tokenåˆ·æ–°æœºåˆ¶
- è®°å½•è®¤è¯æ—¥å¿—ç”¨äºå®¡è®¡

## ğŸ“ éƒ¨ç½²ä¸æµ‹è¯•

éƒ¨ç½²æ—¶æ³¨æ„ï¼š
1. **RedisæŒä¹…åŒ–**ï¼šæ ¹æ®éœ€æ±‚é…ç½®RDBæˆ–AOFæŒä¹…åŒ–
2. **é«˜å¯ç”¨**ï¼šç”Ÿäº§ç¯å¢ƒè€ƒè™‘Redisé›†ç¾¤æ–¹æ¡ˆ
3. **ç¯å¢ƒé…ç½®**ï¼šé€šè¿‡ç¯å¢ƒå˜é‡ç®¡ç†æ•æ„Ÿä¿¡æ¯

æµ‹è¯•æ—¶å¯ä»¥ä½¿ç”¨curlå‘½ä»¤ï¼š
```bash
# ç™»å½•è·å–Token
curl -X POST http://localhost:8080/login -d '{"username":"admin","password":"123456"}'

# ä½¿ç”¨Tokenè®¿é—®å—ä¿æŠ¤æ¥å£
curl -H "Authorization: YOUR_TOKEN_HERE" http://localhost:8080/api/profile
```

è¿™ä¸ªæ–¹æ¡ˆç»“åˆäº†Ginä¸­é—´ä»¶çš„çµæ´»æ€§å’ŒRedisçš„é«˜æ€§èƒ½ï¼Œæä¾›äº†ä¸€ä¸ªå¯æ‰©å±•çš„èº«ä»½è®¤è¯åŸºç¡€æ¶æ„ã€‚ä½ å¯ä»¥æ ¹æ®å…·ä½“ä¸šåŠ¡éœ€æ±‚è¿›è¡Œè°ƒæ•´å’Œæ‰©å±•ã€‚
