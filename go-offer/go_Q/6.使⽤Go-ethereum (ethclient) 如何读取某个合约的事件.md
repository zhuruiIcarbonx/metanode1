
## 主要步骤总结：

1. **连接节点**：使用 `ethclient.Dial()` 连接到以太坊节点
2. **定义 ABI**：准备合约 ABI 用于解析事件
3. **创建查询**：使用 `FilterQuery` 设置查询参数
4. **获取日志**：使用 `FilterLogs()` 或 `SubscribeFilterLogs()` 获取事件日志
5. **解析事件**：使用 ABI 解析日志数据
6. **处理数据**：提取并处理事件参数

使用生成的合约绑定代码是最佳实践，因为它提供了类型安全的方法和更好的开发体验。




使用 Go-ethereum 的 ethclient 读取智能合约事件主要涉及以下几个步骤：
    1. 基础设置和连接
    2A.1 定义合约 ABI 和事件结构 --client.FilterLogs
    2A.2 实时监听新事件          --client.SubscribeFilterLogs()
    2B.1 使用生成的合约绑定（推荐）--&bind.WatchOpts; --contract.WatchTransfer
    2B.2 过滤特定事件（同A一样）  --client.FilterLogs

## 1. 基础设置和连接

```go
package main

import (
    "context"
    "fmt"
    "log"
    "math/big"
    "strings"

    "github.com/ethereum/go-ethereum"
    "github.com/ethereum/go-ethereum/accounts/abi"
    "github.com/ethereum/go-ethereum/common"
    "github.com/ethereum/go-ethereum/ethclient"
)

func main() {
    // 连接以太坊节点
    client, err := ethclient.Dial("https://mainnet.infura.io/v3/YOUR_PROJECT_ID")
    if err != nil {
        log.Fatal(err)
    }
    defer client.Close()

    // 合约地址和ABI
    contractAddress := common.HexToAddress("0xContractAddressHere")
    
    // 读取合约事件
    readContractEvents(client, contractAddress)
}
```

## 2. 定义合约 ABI 和事件结构

```go
// 假设我们有一个 ERC20 转账事件
const erc20ABI = `[
    {
        "anonymous": false,
        "inputs": [
            {"indexed": true, "name": "from", "type": "address"},
            {"indexed": true, "name": "to", "type": "address"},
            {"indexed": false, "name": "value", "type": "uint256"}
        ],
        "name": "Transfer",
        "type": "event"
    }
]`

// 事件数据结构
type TransferEvent struct {
    From  common.Address
    To    common.Address
    Value *big.Int
}

func readContractEvents(client *ethclient.Client, contractAddress common.Address) {
    // 解析 ABI
    contractABI, err := abi.JSON(strings.NewReader(erc20ABI))
    if err != nil {
        log.Fatal(err)
    }

    // 获取最新区块号
    header, err := client.HeaderByNumber(context.Background(), nil)
    if err != nil {
        log.Fatal(err)
    }

    // 设置查询范围（最近 1000 个区块）
    endBlock := header.Number
    startBlock := new(big.Int).Sub(endBlock, big.NewInt(1000))

    // 创建查询过滤器
    query := ethereum.FilterQuery{
        FromBlock: startBlock,
        ToBlock:   endBlock,
        Addresses: []common.Address{contractAddress},
        Topics:    [][]common.Hash{},
    }

    // 查询日志
    logs, err := client.FilterLogs(context.Background(), query)
    if err != nil {
        log.Fatal(err)
    }

    // 解析日志
    for _, vLog := range logs {
        // 检查是否是 Transfer 事件
        if len(vLog.Topics) > 0 && vLog.Topics[0] == contractABI.Events["Transfer"].ID {
            var transferEvent TransferEvent
            
            // 解析事件数据
            err := contractABI.UnpackIntoInterface(&transferEvent, "Transfer", vLog.Data)
            if err != nil {
                log.Printf("Error unpacking event: %v", err)
                continue
            }

            // 获取 indexed 参数
            transferEvent.From = common.BytesToAddress(vLog.Topics[1].Bytes())
            transferEvent.To = common.BytesToAddress(vLog.Topics[2].Bytes())

            fmt.Printf("Transfer: from %s to %s value %s\n", 
                transferEvent.From.Hex(), 
                transferEvent.To.Hex(), 
                transferEvent.Value.String())
        }
    }
}
```

## 3. 实时监听新事件

```go
func watchContractEvents(client *ethclient.Client, contractAddress common.Address) {
    contractABI, err := abi.JSON(strings.NewReader(erc20ABI))
    if err != nil {
        log.Fatal(err)
    }

    // 创建订阅查询
    query := ethereum.FilterQuery{
        Addresses: []common.Address{contractAddress},
    }

    // 创建日志通道
    logs := make(chan types.Log)
    
    // 订阅新事件
    sub, err := client.SubscribeFilterLogs(context.Background(), query, logs)
    if err != nil {
        log.Fatal(err)
    }

    fmt.Println("开始监听合约事件...")

    for {
        select {
        case err := <-sub.Err():
            log.Fatal(err)
        case vLog := <-logs:
            // 处理 Transfer 事件
            if len(vLog.Topics) > 0 && vLog.Topics[0] == contractABI.Events["Transfer"].ID {
                var transferEvent TransferEvent
                
                err := contractABI.UnpackIntoInterface(&transferEvent, "Transfer", vLog.Data)
                if err != nil {
                    log.Printf("Error unpacking event: %v", err)
                    continue
                }

                transferEvent.From = common.BytesToAddress(vLog.Topics[1].Bytes())
                transferEvent.To = common.BytesToAddress(vLog.Topics[2].Bytes())

                fmt.Printf("新区块事件 - Transfer: from %s to %s value %s\n", 
                    transferEvent.From.Hex(), 
                    transferEvent.To.Hex(), 
                    transferEvent.Value.String())
            }
        }
    }
}
```

## 4. 使用生成的合约绑定（推荐）

首先使用 abigen 生成合约绑定：

```bash
abigen --abi=contract.abi --pkg=main --type=MyContract --out=contract.go
```

然后使用生成的代码：

```go
package main

import (
    "context"
    "fmt"
    "log"
    "math/big"

    "github.com/ethereum/go-ethereum/common"
    "github.com/ethereum/go-ethereum/ethclient"
)

func main() {
    client, err := ethclient.Dial("https://mainnet.infura.io/v3/YOUR_PROJECT_ID")
    if err != nil {
        log.Fatal(err)
    }
    defer client.Close()

    contractAddress := common.HexToAddress("0xContractAddressHere")
    contract, err := NewMyContract(contractAddress, client)
    if err != nil {
        log.Fatal(err)
    }

    // 使用生成的合约方法监听事件
    watchWithGeneratedBindings(contract)
}

func watchWithGeneratedBindings(contract *MyContract) {
    // 创建事件通道
    transferEvents := make(chan *MyContractTransfer)
    
    // 订阅事件
    opts := &bind.WatchOpts{Context: context.Background(), Start: nil}
    
    sub, err := contract.WatchTransfer(opts, transferEvents, nil, nil)
    if err != nil {
        log.Fatal(err)
    }
    defer sub.Unsubscribe()

    fmt.Println("开始监听 Transfer 事件...")

    for {
        select {
        case err := <-sub.Err():
            log.Printf("订阅错误: %v", err)
        case event := <-transferEvents:
            fmt.Printf("Transfer 事件 - From: %s, To: %s, Value: %s\n",
                event.From.Hex(),
                event.To.Hex(),
                event.Value.String())
        }
    }
}
```

## 5. 过滤特定事件

```go
func filterSpecificEvents(client *ethclient.Client, contractAddress common.Address) {
    contractABI, err := abi.JSON(strings.NewReader(erc20ABI))
    if err != nil {
        log.Fatal(err)
    }

    // 创建特定过滤条件（例如只监控特定地址的转账）
    specificAddress := common.HexToAddress("0xSpecificAddress")
    
    // 创建主题过滤器
    topic := contractABI.Events["Transfer"].ID
    fromTopic := common.BytesToHash(common.LeftPadBytes(specificAddress.Bytes(), 32))

    query := ethereum.FilterQuery{
        FromBlock: big.NewInt(18000000), // 指定起始区块
        ToBlock:   nil,                  // 最新区块
        Addresses: []common.Address{contractAddress},
        Topics: [][]common.Hash{
            {topic},        // 事件签名
            {fromTopic},    // from 地址
            {},             // to 地址（不过滤）
        },
    }

    logs, err := client.FilterLogs(context.Background(), query)
    if err != nil {
        log.Fatal(err)
    }

    for _, vLog := range logs {
        var transferEvent TransferEvent
        err := contractABI.UnpackIntoInterface(&transferEvent, "Transfer", vLog.Data)
        if err == nil {
            transferEvent.From = common.BytesToAddress(vLog.Topics[1].Bytes())
            transferEvent.To = common.BytesToAddress(vLog.Topics[2].Bytes())
            
            fmt.Printf("过滤结果 - From: %s, To: %s, Value: %s, TxHash: %s\n",
                transferEvent.From.Hex(),
                transferEvent.To.Hex(),
                transferEvent.Value.String(),
                vLog.TxHash.Hex())
        }
    }
}
```

## 主要步骤总结：

1. **连接节点**：使用 `ethclient.Dial()` 连接到以太坊节点
2. **定义 ABI**：准备合约 ABI 用于解析事件
3. **创建查询**：使用 `FilterQuery` 设置查询参数
4. **获取日志**：使用 `FilterLogs()` 或 `SubscribeFilterLogs()` 获取事件日志
5. **解析事件**：使用 ABI 解析日志数据
6. **处理数据**：提取并处理事件参数

使用生成的合约绑定代码是最佳实践，因为它提供了类型安全的方法和更好的开发体验。
