
# 一、XXXXX

在 Go 语言中，并发编程主要依赖于 **Goroutine** 和 **Channel**，但 Go 标准库提供了多个包来辅助并发编程，常见的包括：

---

### 一、Golang 并发编程常用包

| 包名 | 作用 |
|------|------|
| **`sync`** | 提供同步原语（如 `Mutex`、`WaitGroup`、`Once` 等），用于控制多个 Goroutine 的协作。 |
| **`sync/atomic`** | 提供原子操作（如 `AddInt64`、`LoadPointer` 等），用于无锁的并发安全操作。 |
| **`context`** | 提供上下文管理（如取消、超时、传递请求范围的数据），常用于控制 Goroutine 的生命周期。 |
| **`channel`** | 语言内建的通信机制，用于 Goroutine 间安全传递数据。 |
| **`runtime`** | 提供底层运行时控制（如 `GOMAXPROCS` 设置 CPU 核心数）。 |
| **`errgroup`** | 提供 `Group` 类型，用于管理一组 Goroutine 并聚合错误。 |

---

### 二、`sync.Group` 的作用

`sync.Group` 是 Go 1.21 新增的并发工具（位于 `golang.org/x/sync` 模块），用于管理一组 Goroutine，**等待所有 Goroutine 完成并聚合错误**。它比 `sync.WaitGroup` 更高级，适用于需要集中管理任务组的场景。

#### 1. 核心功能

- **启动 Goroutine**：通过 `Go(func() error)` 启动一个任务。
- **等待完成**：通过 `Wait()` 等待所有任务完成。
- **错误聚合**：返回第一个非 `nil` 的错误。

#### 2. 结构定义

```go
type Group struct {
    // 内部使用
}

func (g *Group) Go(f func() error)
func (g *Group) Wait() error
```

#### 3. 使用示例

```go
package main

import (
    "fmt"
    "golang.org/x/sync/errgroup"
    "time"
)

func main() {
    var g errgroup.Group

    // 启动多个任务
    for i := 0; i < 3; i++ {
        i := i
        g.Go(func() error {
            time.Sleep(time.Second)
            if i == 1 {
                return fmt.Errorf("task %d failed", i)
            }
            fmt.Printf("Task %d done\n", i)
            return nil
        })
    }

    // 等待所有任务完成
    if err := g.Wait(); err != nil {
        fmt.Println("Error:", err)
    }
}
```

**输出结果**：
```
Task 0 done
Task 2 done
Error: task 1 failed
```

---

### 三、`sync.Group` 与 `sync.WaitGroup` 的区别

| 特性 | `sync.WaitGroup` | `sync.Group` |
|------|------------------|--------------|
| **任务管理** | 手动调用 `Add`/`Done` | 自动管理任务计数 |
| **错误处理** | 无错误聚合功能 | 返回第一个非 `nil` 错误 |
| **适用场景** | 简单的 Goroutine 同步 | 需要错误聚合的任务组管理 |
| **是否阻塞** | `Wait()` 阻塞直到所有任务完成 | `Wait()` 阻塞直到所有任务完成或第一个错误 |

---

### 四、`sync.Group` 的适用场景

1. **批量任务管理**：如并行处理多个数据源、分布式任务分发。
2. **错误集中处理**：当任意一个任务失败时，立即终止整个任务组并返回错误。
3. **服务启动依赖**：多个服务组件并行启动，等待全部就绪后继续执行。
4. **资源清理**：确保所有子任务完成后再释放共享资源。

---

### 五、注意事项

1. **不可重用**：`sync.Group` 是一次性使用的，任务完成后不能再调用 `Go`。
2. **不支持取消**：若需取消任务，需结合 `context.Context` 实现。
3. **Panics 处理**：`Go` 函数内的 `panic` 不会自动捕获，需在函数内部处理。

---

### 六、总结

- **并发编程核心包**：`sync`、`context`、`errgroup` 是管理并发的三大核心工具。
- **`sync.Group` 的优势**：简化任务组管理，自动聚合错误，避免手动维护 `WaitGroup`。
- **推荐场景**：需要并行执行多个任务并集中处理错误的场景（如微服务初始化、批量数据处理）。

通过 `sync.Group`，可以更高效地编写健壮的并发程序，减少样板代码并提升可读性。



# 二、XXXXX

# Golang 并发编程常用包及 sync.WaitGroup 作用

## 一、Golang 并发编程常用包

### 1. 核心并发包

1. **`sync` 包** - 提供基本同步原语：
   - `Mutex` (互斥锁)
   - `RWMutex` (读写锁)
   - `WaitGroup` (等待组)
   - `Cond` (条件变量)
   - `Once` (一次性执行)
   - `Pool` (对象池)

2. **`channel`** - Go 的核心并发原语：
   - 用于 goroutine 间通信和同步

3. **`atomic` 包** - 提供原子操作：
   - 对基本类型进行原子性操作

### 2. 高级并发工具

4. **`context` 包** - 控制并发流程：
   - 管理 goroutine 的生命周期
   - 传递取消信号和截止时间

5. **`errgroup` 包** (golang.org/x/sync/errgroup)：
   - 扩展 WaitGroup，支持错误传播

6. **`semaphore`** (golang.org/x/sync/semaphore)：
   - 加权信号量实现

7. **`singleflight`** (golang.org/x/sync/singleflight)：
   - 抑制重复函数调用

## 二、sync.WaitGroup 详解

### 1. 作用

`sync.WaitGroup` 用于等待一组 goroutine 完成执行，是协调多个 goroutine 同步的简单有效方式。

### 2. 主要方法

```go
type WaitGroup struct {
    // 包含未导出字段
}

func (wg *WaitGroup) Add(delta int)  // 增加等待的计数
func (wg *WaitGroup) Done()          // 减少计数(等价于Add(-1))
func (wg *WaitGroup) Wait()          // 阻塞直到计数变为0
```

### 3. 使用示例

```go
package main

import (
	"fmt"
	"sync"
	"time"
)

func worker(id int, wg *sync.WaitGroup) {
	defer wg.Done() // 完成后通知WaitGroup
	
	fmt.Printf("Worker %d starting\n", id)
	time.Sleep(time.Second) // 模拟工作
	fmt.Printf("Worker %d done\n", id)
}

func main() {
	var wg sync.WaitGroup
	
	for i := 1; i <= 5; i++ {
		wg.Add(1) // 每启动一个goroutine就增加计数
		go worker(i, &wg)
	}
	
	wg.Wait() // 等待所有goroutine完成
	fmt.Println("All workers completed")
}
```

### 4. 特点与最佳实践

1. **计数顺序**：
   - 必须在启动 goroutine 前调用 `Add`
   - 不能在 `Wait` 开始后再调用 `Add`

2. **典型模式**：
   ```go
   wg.Add(N)   // 预先设置总计数
   for i:=0; i<N; i++ {
       go func() {
           defer wg.Done()
           // 工作代码
       }()
   }
   wg.Wait()
   ```

3. **错误处理**：
   - WaitGroup 本身不处理错误
   - 如需错误处理可结合 channel 或 errgroup

4. **重用**：
   - WaitGroup 完成任务后可重用
   - 但必须等待前一次 Wait 完成后才能重用

5. **指针传递**：
   - 必须传递指针给 goroutine，否则会导致副本问题

### 5. 实际应用场景

1. **批量任务处理**：等待多个并行的数据处理任务完成
2. **服务启动**：等待所有后台服务 goroutine 就绪
3. **测试同步**：在测试中等待并发测试用例完成
4. **资源清理**：确保所有 goroutine 退出后再释放资源

## 三、WaitGroup 与其他同步方式的对比

| 特性          | WaitGroup               | Channel           | Context           |
|---------------|-------------------------|-------------------|-------------------|
| 用途          | 等待任务组完成          | 通信/同步         | 控制生命周期      |
| 复杂度        | 简单                    | 中等              | 中等              |
| 错误传播      | 不支持                  | 支持              | 支持              |
| 典型场景      | 并行任务同步            | 数据流控制        | 取消/超时控制     |

## 四、常见错误及避免方法

1. **Add 调用过晚**：
   ```go
   go func() {
       wg.Add(1) // 错误！可能在Wait之后才调用
       defer wg.Done()
       // ...
   }()
   ```

2. **未使用指针**：
   ```go
   var wg sync.WaitGroup
   go func(wg sync.WaitGroup) { // 错误！传递了副本
       defer wg.Done()
       // ...
   }(wg)
   ```

3. **Done 调用次数不足**：
   ```go
   wg.Add(2)
   go func() { defer wg.Done(); /*...*/ }() // 少调用一次Done
   wg.Wait() // 会永久阻塞
   ```
