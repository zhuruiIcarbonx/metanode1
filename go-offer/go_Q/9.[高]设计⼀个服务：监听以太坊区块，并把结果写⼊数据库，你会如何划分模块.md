
我们设计一个监听以太坊区块并将数据写入数据库的Golang服务。我们将按照功能模块进行划分，确保代码结构清晰、可维护和可扩展。

模块划分：

    1.配置模块（Config）
    读取配置文件或环境变量，包括以太坊节点URL、数据库连接信息、监听起始区块等。
    
    2.以太坊客户端模块（Ethereum Client）
    负责连接以太坊节点，提供区块订阅和区块查询的功能。
    
    3.区块监听模块（Block Listener）
    监听新区块，并获取区块中的交易、日志等详细信息。
    
    4.数据处理模块（Data Processor）
    对获取的区块数据进行处理，提取需要的信息，并转换成适合存储的格式。
    
    5.数据存储模块（Data Storage）
    定义数据库操作接口，实现将处理后的数据写入数据库（例如MySQL、PostgreSQL等）。
    
    6.服务主模块（Main）
    初始化各模块，协调模块之间的工作，处理优雅退出等。
    
    7.监控和日志模块（Monitoring & Logging）
    记录服务运行状态、错误日志，并可以集成指标收集（如Prometheus）等。

下面我们详细描述每个模块的设计：

    1.配置模块（Config）
    使用结构体来存储配置项，可以通过Viper库来从配置文件或环境变量中读取配置。
    
    配置项包括：
    	以太坊节点URL
    	数据库连接字符串
    	起始区块号（从哪个区块开始监听，如果是0则从最新区块开始）
    	是否从最新区块开始监听
    	日志级别
    	数据库类型（如MySQL、PostgreSQL等）
    
	
    2.以太坊客户端模块（Ethereum Client）
    
    使用go-ethereum的ethclient包连接以太坊节点。
    提供以下功能：
    订阅新区块（使用ethclient的SubscribeNewHead）
    根据区块号获取区块详情（包括交易、日志等）
    注意：由于以太坊节点可能不稳定，需要实现重连机制。
    
	
	
    3.区块监听模块（Block Listener）
    使用以太坊客户端模块订阅新区块。
    当收到新区块时，根据配置决定是否处理（例如，如果配置了从特定区块开始，可能会需要回溯之前的区块）。
    对于每个需要处理的区块，调用数据处理模块进行处理。
    
	
    4.数据处理模块（Data Processor）
    对区块数据进行解析，提取我们关心的信息，例如：
    区块头信息（区块号、哈希、时间戳、矿工等）
    交易信息（交易哈希、发送者、接收者、金额、输入数据等）
    日志事件（例如ERC20转账等）
    将提取的数据转换为存储模块期望的数据结构。
    
	
	
    5.数据存储模块（Data Storage）
    定义存储接口，以便于支持不同的数据库（例如，使用接口来定义存储区块、交易等方法）。
    实现具体的存储接口，例如MySQL存储、PostgreSQL存储等。
    负责数据库的迁移（创建表等）和连接管理。
    
	
	
    6.服务主模块（Main）
    初始化顺序：配置 -> 日志 -> 以太坊客户端 -> 数据存储 -> 区块监听 -> 启动服务。
    监听系统信号（如SIGINT、SIGTERM）以实现优雅退出。
    协调各模块的启动和关闭。
    
	
	
    7.监控和日志模块（Monitoring & Logging）
    使用标准的日志库（如logrus或zap）来记录日志。
    可以集成Prometheus来暴露指标，例如已处理的区块数、错误次数等。
	


我会设计一个模块化、可扩展的以太坊区块监听服务，以下是完整的模块划分和架构设计：

## 1. 整体架构设计

```
ethereum-block-listener/
├── cmd/
│   └── server/
│       └── main.go
├── internal/
│   ├── config/
│   ├── ethclient/
│   ├── listener/
│   ├── processor/
│   ├── storage/
│   ├── models/
│   └── service/
├── pkg/
│   ├── logger/
│   └── utils/
└── deployments/
    ├── docker-compose.yml
    └── kubernetes/
```

## 2. 核心模块划分

### 模块1: 配置管理 (config)
```go
// internal/config/config.go
package config

import (
    "fmt"
    "time"
)

type Config struct {
    // Ethereum 配置
    Ethereum struct {
        RPCURLs          []string      `yaml:"rpc_urls"`
        StartBlock       uint64        `yaml:"start_block"`
        MaxBlocksPerStep uint64        `yaml:"max_blocks_per_step"`
        Confirmation     uint64        `yaml:"confirmation_blocks"`
    } `yaml:"ethereum"`
    
    // 数据库配置
    Database struct {
        Driver   string `yaml:"driver"`
        DSN      string `yaml:"dsn"`
        MaxConns int    `yaml:"max_conns"`
    } `yaml:"database"`
    
    // 服务配置
    Server struct {
        HTTPPort         int           `yaml:"http_port"`
        MetricsPort      int           `yaml:"metrics_port"`
        ShutdownTimeout  time.Duration `yaml:"shutdown_timeout"`
    } `yaml:"server"`
    
    // 监控配置
    Monitoring struct {
        EnableMetrics bool   `yaml:"enable_metrics"`
        LogLevel      string `yaml:"log_level"`
    } `yaml:"monitoring"`
}

func Load(configPath string) (*Config, error) {
    // 从文件、环境变量等加载配置
    // ...
}
```

### 模块2: 以太坊客户端管理 (ethclient)
```go
// internal/ethclient/pool.go
package ethclient

import (
    "context"
    "sync"
    "time"

    "github.com/ethereum/go-ethereum/ethclient"
)

type ClientPool struct {
    clients []*WeightedClient
    mu      sync.RWMutex
    healthy map[int]bool
}

type WeightedClient struct {
    Client *ethclient.Client
    URL    string
    Weight int
    Name   string
}

func NewPool(urls []string) (*ClientPool, error) {
    pool := &ClientPool{
        clients: make([]*WeightedClient, len(urls)),
        healthy: make(map[int]bool),
    }
    
    for i, url := range urls {
        client, err := ethclient.Dial(url)
        if err != nil {
            return nil, fmt.Errorf("failed to connect to %s: %w", url, err)
        }
        
        pool.clients[i] = &WeightedClient{
            Client: client,
            URL:    url,
            Weight: 1,
            Name:   fmt.Sprintf("node-%d", i),
        }
        pool.healthy[i] = true
    }
    
    go pool.startHealthCheck()
    return pool, nil
}

func (p *ClientPool) GetBestClient() (*ethclient.Client, error) {
    p.mu.RLock()
    defer p.mu.RUnlock()
    
    // 实现加权轮询或选择最佳客户端
    for i, client := range p.clients {
        if p.healthy[i] {
            return client.Client, nil
        }
    }
    return nil, fmt.Errorf("no healthy clients available")
}

func (p *ClientPool) startHealthCheck() {
    ticker := time.NewTicker(30 * time.Second)
    for range ticker.C {
        p.checkHealth()
    }
}

func (p *ClientPool) checkHealth() {
    p.mu.Lock()
    defer p.mu.Unlock()
    
    for i, client := range p.clients {
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        _, err := client.Client.BlockNumber(ctx)
        cancel()
        
        p.healthy[i] = (err == nil)
    }
}
```

### 模块3: 区块监听器 (listener)
```go
// internal/listener/block_listener.go
package listener

import (
    "context"
    "fmt"
    "log"
    "math/big"
    "time"

    "github.com/ethereum/go-ethereum/core/types"
)

type BlockListener struct {
    clientPool   *ethclient.ClientPool
    blockHandler BlockHandler
    lastBlock    uint64
    config       *config.Config
    stopChan     chan struct{}
}

type BlockHandler interface {
    HandleBlock(ctx context.Context, block *types.Block) error
    HandleBlockWithRetry(ctx context.Context, block *types.Block) error
}

func NewBlockListener(pool *ethclient.ClientPool, handler BlockHandler, cfg *config.Config) *BlockListener {
    return &BlockListener{
        clientPool:   pool,
        blockHandler: handler,
        config:       cfg,
        stopChan:     make(chan struct{}),
    }
}

func (l *BlockListener) Start(ctx context.Context) error {
    // 从最后处理的区块开始，或从配置的起始区块开始
    startBlock, err := l.getStartBlock(ctx)
    if err != nil {
        return err
    }
    
    l.lastBlock = startBlock
    log.Printf("Starting block listener from block %d", startBlock)
    
    go l.catchupHistoricalBlocks(ctx)
    go l.listenNewBlocks(ctx)
    
    return nil
}

func (l *BlockListener) getStartBlock(ctx context.Context) (uint64, error) {
    // 可以从数据库获取最后处理的区块
    // 或者使用配置的起始区块
    if l.config.Ethereum.StartBlock > 0 {
        return l.config.Ethereum.StartBlock, nil
    }
    
    // 或者从最新区块减去确认数开始
    client, err := l.clientPool.GetBestClient()
    if err != nil {
        return 0, err
    }
    
    latest, err := client.BlockNumber(ctx)
    if err != nil {
        return 0, err
    }
    
    // 从最近的几个区块开始，避免处理太旧的区块
    start := latest - l.config.Ethereum.Confirmation
    if start < 0 {
        start = 0
    }
    
    return start, nil
}

func (l *BlockListener) catchupHistoricalBlocks(ctx context.Context) {
    ticker := time.NewTicker(1 * time.Second)
    defer ticker.Stop()
    
    for {
        select {
        case <-ctx.Done():
            return
        case <-ticker.C:
            l.processCatchup(ctx)
        case <-l.stopChan:
            return
        }
    }
}

func (l *BlockListener) processCatchup(ctx context.Context) {
    client, err := l.clientPool.GetBestClient()
    if err != nil {
        log.Printf("Failed to get client for catchup: %v", err)
        return
    }
    
    latest, err := client.BlockNumber(ctx)
    if err != nil {
        log.Printf("Failed to get latest block: %v", err)
        return
    }
    
    // 处理落后的区块
    if l.lastBlock < latest-l.config.Ethereum.Confirmation {
        endBlock := l.lastBlock + l.config.Ethereum.MaxBlocksPerStep
        if endBlock > latest-l.config.Ethereum.Confirmation {
            endBlock = latest - l.config.Ethereum.Confirmation
        }
        
        log.Printf("Catching up blocks from %d to %d", l.lastBlock, endBlock)
        
        for blockNum := l.lastBlock + 1; blockNum <= endBlock; blockNum++ {
            block, err := client.BlockByNumber(ctx, big.NewInt(int64(blockNum)))
            if err != nil {
                log.Printf("Failed to get block %d: %v", blockNum, err)
                continue
            }
            
            if err := l.blockHandler.HandleBlockWithRetry(ctx, block); err != nil {
                log.Printf("Failed to handle block %d: %v", blockNum, err)
                break
            }
            
            l.lastBlock = blockNum
        }
    }
}

func (l *BlockListener) listenNewBlocks(ctx context.Context) {
    for {
        select {
        case <-ctx.Done():
            return
        case <-l.stopChan:
            return
        default:
            l.subscribeToNewBlocks(ctx)
            time.Sleep(5 * time.Second) // 等待重连
        }
    }
}

func (l *BlockListener) subscribeToNewBlocks(ctx context.Context) {
    client, err := l.clientPool.GetBestClient()
    if err != nil {
        log.Printf("Failed to get client for subscription: %v", err)
        return
    }
    
    headers := make(chan *types.Header)
    sub, err := client.SubscribeNewHead(ctx, headers)
    if err != nil {
        log.Printf("Failed to subscribe to new headers: %v", err)
        return
    }
    defer sub.Unsubscribe()
    
    for {
        select {
        case <-ctx.Done():
            return
        case err := <-sub.Err():
            log.Printf("Subscription error: %v", err)
            return
        case header := <-headers:
            l.handleNewHeader(ctx, header)
        }
    }
}

func (l *BlockListener) handleNewHeader(ctx context.Context, header *types.Header) {
    blockNumber := header.Number.Uint64()
    
    // 等待足够的确认
    if blockNumber <= l.lastBlock+l.config.Ethereum.Confirmation {
        return
    }
    
    client, err := l.clientPool.GetBestClient()
    if err != nil {
        log.Printf("Failed to get client for block: %v", err)
        return
    }
    
    block, err := client.BlockByHash(ctx, header.Hash())
    if err != nil {
        log.Printf("Failed to get block by hash: %v", err)
        return
    }
    
    if err := l.blockHandler.HandleBlockWithRetry(ctx, block); err != nil {
        log.Printf("Failed to handle new block %d: %v", blockNumber, err)
        return
    }
    
    l.lastBlock = blockNumber
    log.Printf("Successfully processed block %d", blockNumber)
}

func (l *BlockListener) Stop() {
    close(l.stopChan)
}
```

### 模块4: 区块处理器 (processor)
```go
// internal/processor/block_processor.go
package processor

import (
    "context"
    "fmt"
    "time"

    "github.com/ethereum/go-ethereum/core/types"
    "your-project/internal/models"
    "your-project/internal/storage"
)

type BlockProcessor struct {
    storage storage.Storage
    retryConfig *RetryConfig
}

type RetryConfig struct {
    MaxRetries int
    BaseDelay  time.Duration
    MaxDelay   time.Duration
}

func NewBlockProcessor(storage storage.Storage) *BlockProcessor {
    return &BlockProcessor{
        storage: storage,
        retryConfig: &RetryConfig{
            MaxRetries: 3,
            BaseDelay:  1 * time.Second,
            MaxDelay:   10 * time.Second,
        },
    }
}

func (p *BlockProcessor) HandleBlock(ctx context.Context, block *types.Block) error {
    blockData := p.transformBlock(block)
    transactions := p.transformTransactions(block)
    
    // 在事务中保存区块和交易
    return p.storage.SaveBlockWithTransactions(ctx, blockData, transactions)
}

func (p *BlockProcessor) HandleBlockWithRetry(ctx context.Context, block *types.Block) error {
    var lastErr error
    
    for attempt := 0; attempt <= p.retryConfig.MaxRetries; attempt++ {
        if err := p.HandleBlock(ctx, block); err != nil {
            lastErr = err
            
            if attempt == p.retryConfig.MaxRetries {
                return fmt.Errorf("failed after %d retries: %w", p.retryConfig.MaxRetries, err)
            }
            
            delay := p.calculateBackoff(attempt)
            select {
            case <-time.After(delay):
                // 继续重试
            case <-ctx.Done():
                return ctx.Err()
            }
        } else {
            return nil // 成功
        }
    }
    
    return lastErr
}

func (p *BlockProcessor) transformBlock(block *types.Block) *models.Block {
    return &models.Block{
        Number:        block.Number().Uint64(),
        Hash:          block.Hash().Hex(),
        ParentHash:    block.ParentHash().Hex(),
        Timestamp:     time.Unix(int64(block.Time()), 0),
        Miner:         block.Coinbase().Hex(),
        Difficulty:    block.Difficulty().Uint64(),
        GasLimit:      block.GasLimit(),
        GasUsed:       block.GasUsed(),
        BaseFee:       p.getBaseFee(block),
        Transactions:  len(block.Transactions()),
    }
}

func (p *BlockProcessor) transformTransactions(block *types.Block) []*models.Transaction {
    var transactions []*models.Transaction
    
    for i, tx := range block.Transactions() {
        from, _ := types.Sender(types.LatestSignerForChainID(tx.ChainId()), tx)
        
        transaction := &models.Transaction{
            BlockNumber: block.Number().Uint64(),
            BlockHash:   block.Hash().Hex(),
            TxHash:      tx.Hash().Hex(),
            From:        from.Hex(),
            Nonce:       tx.Nonce(),
            GasPrice:    tx.GasPrice().Uint64(),
            Gas:         tx.Gas(),
            Value:       tx.Value().String(),
            Input:       fmt.Sprintf("0x%x", tx.Data()),
        }
        
        if tx.To() != nil {
            transaction.To = tx.To().Hex()
        }
        
        transactions = append(transactions, transaction)
    }
    
    return transactions
}

func (p *BlockProcessor) getBaseFee(block *types.Block) uint64 {
    if block.BaseFee() != nil {
        return block.BaseFee().Uint64()
    }
    return 0
}

func (p *BlockProcessor) calculateBackoff(attempt int) time.Duration {
    delay := p.retryConfig.BaseDelay * time.Duration(1<<attempt)
    if delay > p.retryConfig.MaxDelay {
        return p.retryConfig.MaxDelay
    }
    return delay
}
```

### 模块5: 数据存储 (storage)
```go
// internal/storage/storage.go
package storage

import (
    "context"
    "database/sql"
    "fmt"
    "time"

    "your-project/internal/models"
)

type Storage interface {
    SaveBlock(ctx context.Context, block *models.Block) error
    SaveTransaction(ctx context.Context, tx *models.Transaction) error
    SaveBlockWithTransactions(ctx context.Context, block *models.Block, txs []*models.Transaction) error
    GetLastProcessedBlock(ctx context.Context) (uint64, error)
    HealthCheck(ctx context.Context) error
    Close() error
}

type PostgreSQLStorage struct {
    db *sql.DB
}

func NewPostgreSQLStorage(dsn string, maxConns int) (*PostgreSQLStorage, error) {
    db, err := sql.Open("postgres", dsn)
    if err != nil {
        return nil, err
    }
    
    db.SetMaxOpenConns(maxConns)
    db.SetMaxIdleConns(maxConns / 2)
    db.SetConnMaxLifetime(30 * time.Minute)
    
    if err := db.Ping(); err != nil {
        return nil, err
    }
    
    return &PostgreSQLStorage{db: db}, nil
}

func (s *PostgreSQLStorage) SaveBlockWithTransactions(ctx context.Context, block *models.Block, txs []*models.Transaction) error {
    tx, err := s.db.BeginTx(ctx, nil)
    if err != nil {
        return err
    }
    defer tx.Rollback()
    
    // 保存区块
    blockQuery := `INSERT INTO blocks (number, hash, parent_hash, timestamp, miner, difficulty, gas_limit, gas_used, base_fee, transaction_count) 
                   VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
                   ON CONFLICT (number) DO UPDATE SET 
                   hash = EXCLUDED.hash, parent_hash = EXCLUDED.parent_hash, timestamp = EXCLUDED.timestamp`
    
    _, err = tx.ExecContext(ctx, blockQuery,
        block.Number, block.Hash, block.ParentHash, block.Timestamp, block.Miner,
        block.Difficulty, block.GasLimit, block.GasUsed, block.BaseFee, block.Transactions)
    if err != nil {
        return fmt.Errorf("failed to save block: %w", err)
    }
    
    // 保存交易
    txQuery := `INSERT INTO transactions (block_number, block_hash, tx_hash, "from", "to", nonce, gas_price, gas, value, input)
                VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
                ON CONFLICT (tx_hash) DO NOTHING`
    
    for _, transaction := range txs {
        _, err := tx.ExecContext(ctx, txQuery,
            transaction.BlockNumber, transaction.BlockHash, transaction.TxHash,
            transaction.From, transaction.To, transaction.Nonce, transaction.GasPrice,
            transaction.Gas, transaction.Value, transaction.Input)
        if err != nil {
            return fmt.Errorf("failed to save transaction: %w", err)
        }
    }
    
    return tx.Commit()
}

func (s *PostgreSQLStorage) GetLastProcessedBlock(ctx context.Context) (uint64, error) {
    var lastBlock uint64
    err := s.db.QueryRowContext(ctx, "SELECT COALESCE(MAX(number), 0) FROM blocks").Scan(&lastBlock)
    if err != nil {
        return 0, err
    }
    return lastBlock, nil
}

func (s *PostgreSQLStorage) HealthCheck(ctx context.Context) error {
    return s.db.PingContext(ctx)
}

func (s *PostgreSQLStorage) Close() error {
    return s.db.Close()
}
```

### 模块6: 数据模型 (models)
```go
// internal/models/block.go
package models

import "time"

type Block struct {
    Number         uint64    `json:"number" db:"number"`
    Hash           string    `json:"hash" db:"hash"`
    ParentHash     string    `json:"parent_hash" db:"parent_hash"`
    Timestamp      time.Time `json:"timestamp" db:"timestamp"`
    Miner          string    `json:"miner" db:"miner"`
    Difficulty     uint64    `json:"difficulty" db:"difficulty"`
    GasLimit       uint64    `json:"gas_limit" db:"gas_limit"`
    GasUsed        uint64    `json:"gas_used" db:"gas_used"`
    BaseFee        uint64    `json:"base_fee" db:"base_fee"`
    Transactions   int       `json:"transactions" db:"transaction_count"`
}

type Transaction struct {
    BlockNumber uint64 `json:"block_number" db:"block_number"`
    BlockHash   string `json:"block_hash" db:"block_hash"`
    TxHash      string `json:"tx_hash" db:"tx_hash"`
    From        string `json:"from" db:"from"`
    To          string `json:"to" db:"to"`
    Nonce       uint64 `json:"nonce" db:"nonce"`
    GasPrice    uint64 `json:"gas_price" db:"gas_price"`
    Gas         uint64 `json:"gas" db:"gas"`
    Value       string `json:"value" db:"value"`
    Input       string `json:"input" db:"input"`
}
```

### 模块7: 主服务 (service)
```go
// internal/service/service.go
package service

import (
    "context"
    "log"
    "net/http"
    "os"
    "os/signal"
    "syscall"
    "time"

    "your-project/internal/config"
    "your-project/internal/ethclient"
    "your-project/internal/listener"
    "your-project/internal/processor"
    "your-project/internal/storage"
)

type Service struct {
    config      *config.Config
    storage     storage.Storage
    clientPool  *ethclient.ClientPool
    processor   *processor.BlockProcessor
    listener    *listener.BlockListener
    httpServer  *http.Server
}

func NewService(cfg *config.Config) (*Service, error) {
    // 初始化存储
    store, err := storage.NewPostgreSQLStorage(cfg.Database.DSN, cfg.Database.MaxConns)
    if err != nil {
        return nil, err
    }
    
    // 初始化以太坊客户端池
    clientPool, err := ethclient.NewPool(cfg.Ethereum.RPCURLs)
    if err != nil {
        return nil, err
    }
    
    // 初始化处理器
    blockProcessor := processor.NewBlockProcessor(store)
    
    // 初始化监听器
    blockListener := listener.NewBlockListener(clientPool, blockProcessor, cfg)
    
    return &Service{
        config:     cfg,
        storage:    store,
        clientPool: clientPool,
        processor:  blockProcessor,
        listener:   blockListener,
    }, nil
}

func (s *Service) Start() error {
    ctx := context.Background()
    
    // 启动健康检查端点
    if s.config.Server.HTTPPort > 0 {
        s.startHTTPServer()
    }
    
    // 启动区块监听
    if err := s.listener.Start(ctx); err != nil {
        return err
    }
    
    log.Println("Service started successfully")
    return nil
}

func (s *Service) startHTTPServer() {
    mux := http.NewServeMux()
    mux.HandleFunc("/health", s.healthHandler)
    mux.HandleFunc("/metrics", s.metricsHandler)
    
    s.httpServer = &http.Server{
        Addr:    fmt.Sprintf(":%d", s.config.Server.HTTPPort),
        Handler: mux,
    }
    
    go func() {
        log.Printf("HTTP server starting on port %d", s.config.Server.HTTPPort)
        if err := s.httpServer.ListenAndServe(); err != nil && err != http.ErrServerClosed {
            log.Printf("HTTP server error: %v", err)
        }
    }()
}

func (s *Service) healthHandler(w http.ResponseWriter, r *http.Request) {
    ctx, cancel := context.WithTimeout(r.Context(), 5*time.Second)
    defer cancel()
    
    if err := s.storage.HealthCheck(ctx); err != nil {
        http.Error(w, "Storage unhealthy", http.StatusServiceUnavailable)
        return
    }
    
    w.WriteHeader(http.StatusOK)
    w.Write([]byte(`{"status": "healthy"}`))
}

func (s *Service) Stop() error {
    log.Println("Shutting down service...")
    
    ctx, cancel := context.WithTimeout(context.Background(), s.config.Server.ShutdownTimeout)
    defer cancel()
    
    // 停止监听器
    s.listener.Stop()
    
    // 关闭 HTTP 服务器
    if s.httpServer != nil {
        s.httpServer.Shutdown(ctx)
    }
    
    // 关闭存储连接
    if err := s.storage.Close(); err != nil {
        log.Printf("Error closing storage: %v", err)
    }
    
    log.Println("Service stopped successfully")
    return nil
}

func (s *Service) WaitForShutdown() {
    quit := make(chan os.Signal, 1)
    signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
    <-quit
    
    s.Stop()
}
```

### 模块8: 主程序入口
```go
// cmd/server/main.go
package main

import (
    "log"
    "os"

    "your-project/internal/config"
    "your-project/internal/service"
)

func main() {
    // 加载配置
    cfg, err := config.Load("config.yaml")
    if err != nil {
        log.Fatalf("Failed to load config: %v", err)
    }
    
    // 创建服务
    svc, err := service.NewService(cfg)
    if err != nil {
        log.Fatalf("Failed to create service: %v", err)
    }
    
    // 启动服务
    if err := svc.Start(); err != nil {
        log.Fatalf("Failed to start service: %v", err)
    }
    
    // 等待关闭信号
    svc.WaitForShutdown()
}
```

## 3. 数据库表结构

```sql
-- blocks 表
CREATE TABLE blocks (
    number BIGINT PRIMARY KEY,
    hash VARCHAR(66) UNIQUE NOT NULL,
    parent_hash VARCHAR(66) NOT NULL,
    timestamp TIMESTAMP NOT NULL,
    miner VARCHAR(42) NOT NULL,
    difficulty NUMERIC(50,0),
    gas_limit BIGINT NOT NULL,
    gas_used BIGINT NOT NULL,
    base_fee BIGINT,
    transaction_count INTEGER NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- transactions 表  
CREATE TABLE transactions (
    id BIGSERIAL PRIMARY KEY,
    block_number BIGINT NOT NULL REFERENCES blocks(number),
    block_hash VARCHAR(66) NOT NULL,
    tx_hash VARCHAR(66) UNIQUE NOT NULL,
    "from" VARCHAR(42) NOT NULL,
    "to" VARCHAR(42),
    nonce BIGINT NOT NULL,
    gas_price BIGINT NOT NULL,
    gas BIGINT NOT NULL,
    value NUMERIC(50,0) NOT NULL,
    input TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 创建索引
CREATE INDEX idx_blocks_timestamp ON blocks(timestamp);
CREATE INDEX idx_blocks_miner ON blocks(miner);
CREATE INDEX idx_txs_block_number ON transactions(block_number);
CREATE INDEX idx_txs_from ON transactions("from");
CREATE INDEX idx_txs_to ON transactions("to");
CREATE INDEX idx_txs_hash ON transactions(tx_hash);
```

## 4. 关键特性

### 容错和恢复
- **多节点故障转移**：支持多个以太坊 RPC 端点
- **重试机制**：指数退避重试失败的区块处理
- **断点续传**：记录最后处理的区块，服务重启后继续
- **健康检查**：定期检查组件健康状态

### 性能优化
- **批量处理**：在事务中批量保存区块和交易
- **连接池**：数据库和以太坊客户端连接池
- **异步处理**：非阻塞的区块处理流程

### 可观测性
- **指标收集**：处理区块数、延迟、错误率等
- **健康端点**：提供服务健康状态检查
- **结构化日志**：详细的运行日志

### 扩展性
- **模块化设计**：易于替换或扩展组件
- **接口抽象**：存储、处理器等关键组件接口化
- **配置驱动**：通过配置调整行为，无需代码修改

这种设计确保了服务的高可用性、可维护性和可扩展性，能够稳定地监听以太坊区块并将数据可靠地存储到数据库中。
