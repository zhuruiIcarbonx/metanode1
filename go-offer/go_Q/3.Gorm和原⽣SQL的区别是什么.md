Gorm 和原生 SQL 是 Go 语言中操作数据库的两种不同方式，它们有各自的优缺点和适用场景。

## 核心区别对比

| 方面 | Gorm (ORM) | 原生 SQL |
|------|------------|----------|
| **抽象级别** | 高级抽象，面向对象 | 低级抽象，直接操作数据库 |
| **开发效率** | ⭐⭐⭐⭐⭐ 高 | ⭐⭐⭐ 中等 |
| **性能控制** | ⭐⭐⭐ 中等 | ⭐⭐⭐⭐⭐ 高 |
| **学习曲线** | ⭐⭐⭐ 中等 | ⭐⭐ 低（需要 SQL 知识） |
| **类型安全** | ⭐⭐⭐⭐⭐ 高 | ⭐⭐ 低 |
| **灵活性** | ⭐⭐⭐ 中等 | ⭐⭐⭐⭐⭐ 高 |
| **数据库迁移** | ⭐⭐⭐⭐⭐ 内置支持 | ❌ 需要手动处理 |

---

## 具体区别详解

### 1. 代码编写方式

**Gorm 示例：**
```go
// 定义模型
type User struct {
    ID   uint   `gorm:"primaryKey"`
    Name string `gorm:"size:100"`
    Age  int
}

// 查询操作
var user User
result := db.Where("name = ?", "John").First(&user)

// 创建操作
newUser := User{Name: "Alice", Age: 25}
db.Create(&newUser)

// 更新操作
db.Model(&user).Update("Age", 26)
```

**原生 SQL 示例：**
```go
// 查询操作
var user User
err := db.QueryRow("SELECT id, name, age FROM users WHERE name = ?", "John").Scan(&user.ID, &user.Name, &user.Age)

// 创建操作
result, err := db.Exec("INSERT INTO users (name, age) VALUES (?, ?)", "Alice", 25)

// 更新操作
_, err := db.Exec("UPDATE users SET age = ? WHERE id = ?", 26, user.ID)
```

### 2. 类型安全

**Gorm（类型安全）：**
```go
// 编译时就能发现字段名错误
db.Where("nam = ?", "John").First(&user) // 拼写错误，但编译不会报错
// 运行时才会发现错误
```

**原生 SQL（无类型安全）：**
```go
// 字段名拼写错误只能在运行时发现
err := db.QueryRow("SELECT id, nam FROM users WHERE id = ?", 1).Scan(&user.ID, &user.Name)
// 运行时错误：column "nam" not found
```

### 3. 复杂查询对比

**Gorm 复杂查询：**
```go
// 多表关联查询
var users []User
db.Joins("LEFT JOIN profiles ON profiles.user_id = users.id").
   Where("users.age > ?", 18).
   Preload("Profile").
   Find(&users)
```

**原生 SQL 复杂查询：**
```go
query := `
    SELECT u.*, p.bio 
    FROM users u 
    LEFT JOIN profiles p ON p.user_id = u.id 
    WHERE u.age > ?`
rows, err := db.Query(query, 18)
// 需要手动处理结果集映射
```

### 4. 性能方面

**Gorm 的性能考虑：**
- 有反射开销
- 可能生成非最优的 SQL
- N+1 查询问题需要注意

**原生 SQL 的性能优势：**
- 直接执行，无额外开销
- 可以手动优化 SQL
- 更好的控制查询计划

---

## 实际项目中的混合使用

在实际项目中，通常会根据场景混合使用：

```go
package main

import (
    "database/sql"
    "fmt"
    "gorm.io/driver/mysql"
    "gorm.io/gorm"
)

type User struct {
    ID   uint
    Name string
    Age  int
}

func main() {
    // 使用 Gorm 进行常规 CRUD
    dsn := "user:pass@tcp(127.0.0.1:3306)/dbname?charset=utf8mb4&parseTime=True&loc=Local"
    gormDB, err := gorm.Open(mysql.Open(dsn), &gorm.Config{})
    if err != nil {
        panic(err)
    }

    // 获取底层 sql.DB 用于原生 SQL
    sqlDB, err := gormDB.DB()
    if err != nil {
        panic(err)
    }

    // 场景1：使用 Gorm 进行简单操作
    var user User
    gormDB.First(&user, 1)
    
    // 场景2：使用原生 SQL 进行复杂查询或性能优化
    var avgAge float64
    sqlDB.QueryRow("SELECT AVG(age) FROM users WHERE age > ?", 20).Scan(&avgAge)
    
    // 场景3：在 Gorm 中使用原生 SQL
    gormDB.Raw("SELECT * FROM users WHERE age > ? ORDER BY created_at DESC", 25).Scan(&users)
    
    // 场景4：复杂报表查询（更适合原生 SQL）
    rows, err := sqlDB.Query(`
        SELECT 
            u.name,
            COUNT(o.id) as order_count,
            SUM(o.amount) as total_amount
        FROM users u
        LEFT JOIN orders o ON u.id = o.user_id
        WHERE u.created_at > ?
        GROUP BY u.id
        HAVING total_amount > ?
    `, "2023-01-01", 1000)
}
```

---

## 选择建议

### 使用 Gorm 的场景：
- ✅ 快速开发原型
- ✅ 简单的 CRUD 操作
- ✅ 需要数据库迁移
- ✅ 团队对 SQL 不熟悉
- ✅ 项目需要支持多种数据库

### 使用原生 SQL 的场景：
- ✅ 复杂查询和报表
- ✅ 性能关键的应用
- ✅ 需要精细控制 SQL
- ✅ 使用数据库特定功能
- ✅ 团队有丰富的 SQL 经验

### 推荐策略：
1. **80% 使用 Gorm**：处理日常的 CRUD 操作
2. **20% 使用原生 SQL**：处理复杂查询、报表、性能优化
3. **重要业务逻辑**：使用原生 SQL 确保性能和正确性

## 总结

Gorm 和原生 SQL 不是互斥的选择，而是互补的工具。**Gorm 提高了开发效率，原生 SQL 保证了灵活性和性能**。在实际项目中，根据具体需求合理搭配使用两者，才能达到最佳的开发效果和运行性能。
