# 以太坊中的 Calldata

## 1. Calldata 的基本概念

**Calldata** 是以太坊中一个特殊的**只读、非持久化**的数据区域，专门用于存储**函数调用参数**和**外部交易数据**。

```solidity
contract CalldataExample {
    // calldata 主要用于函数参数
    function processData(bytes calldata data) external {
        // data 参数存储在 calldata 区域
    }
}
```

## 2. Calldata 的特点

### 只读性
```solidity
function readOnlyExample(bytes calldata data) external pure {
    // 可以读取
    uint firstByte = uint8(data[0]);
    
    // 不能修改 - 以下代码会编译错误
    // data[0] = 0x01; // ❌ 错误：calldata 是只读的
}
```

### 临时存储
```solidity
function temporaryExample(bytes calldata input) external {
    // calldata 只在函数执行期间存在
    // 函数结束后数据不持久化
}
```

## 3. 使用 Calldata 的场景

### 场景1：外部函数的引用类型参数
```solidity
contract ExternalFunctionExample {
    // 外部函数的引用类型参数应该使用 calldata
    function processString(string calldata text) external pure returns (uint) {
        return bytes(text).length;
    }
    
    function processArray(uint[] calldata numbers) external pure returns (uint) {
        uint sum = 0;
        for (uint i = 0; i < numbers.length; i++) {
            sum += numbers[i];
        }
        return sum;
    }
    
    function processStruct(bytes calldata data) external pure returns (bytes32) {
        return keccak256(data);
    }
}
```

### 场景2：节省 Gas 成本
```solidity
contract GasOptimization {
    string public storedData;
    
    // 使用 memory - 需要复制数据，消耗更多 Gas
    function updateWithMemory(string memory newData) public {
        storedData = newData; // 数据从 calldata 复制到 memory，再复制到 storage
    }
    
    // 使用 calldata - 更省 Gas
    function updateWithCalldata(string calldata newData) public {
        storedData = newData; // 数据直接从 calldata 复制到 storage
    }
}
```

### 场景3：处理大量数据
```solidity
contract BulkDataProcessor {
    event Processed(uint indexed startIndex, uint count);
    
    // 处理大型数组，使用 calldata 避免内存复制
    function processLargeArray(
        uint[] calldata data,
        uint batchSize
    ) external {
        require(batchSize > 0, "Batch size must be positive");
        
        for (uint i = 0; i < data.length; i += batchSize) {
            uint end = i + batchSize > data.length ? data.length : i + batchSize;
            
            // 直接处理 calldata 中的数据，无需复制到 memory
            for (uint j = i; j < end; j++) {
                // 处理每个元素
                _processSingle(data[j]);
            }
            
            emit Processed(i, end - i);
        }
    }
    
    function _processSingle(uint value) private pure {
        // 处理单个值
    }
}
```

### 场景4：函数选择器和参数解析
```solidity
contract LowLevelCalls {
    // 直接处理原始 calldata
    function getFunctionSelector() external pure returns (bytes4) {
        // msg.data 包含完整的 calldata（函数选择器 + 参数）
        return bytes4(msg.data[:4]);
    }
    
    function getFirstParameter() external pure returns (uint) {
        // 手动解析 calldata 中的参数
        // 前4字节是函数选择器，接下来32字节是第一个参数
        uint param;
        assembly {
            param := calldataload(4) // 从第4字节开始加载32字节数据
        }
        return param;
    }
}
```

## 4. Calldata vs Memory vs Storage

### 完整对比示例
```solidity
contract DataLocationComparison {
    struct User {
        string name;
        uint age;
    }
    
    User[] public users;
    
    function compareLocations() public {
        // 1. Storage 示例
        User storage userRef = users[0]; // 引用，修改会影响原数据
        userRef.age = 25; // 直接修改 storage
        
        // 2. Memory 示例
        User memory userMem = users[0]; // 创建内存副本
        userMem.age = 30; // 只修改副本，不影响原数据
        
        // 3. Calldata 示例 - 只能在函数参数中使用
    }
    
    // 函数参数对比
    function withMemory(User memory user) public {
        // memory 参数：可读可写，但修改不会影响调用方
        user.age = 40; // 只修改内存副本
    }
    
    function withCalldata(User calldata user) public view returns (uint) {
        // calldata 参数：只读，最省 Gas
        // user.age = 50; // ❌ 编译错误：不能修改 calldata
        return user.age; // ✅ 可以读取
    }
}
```

### 特性对比表格

| 特性 | Calldata | Memory | Storage |
|------|----------|---------|----------|
| **持久性** | 临时 | 临时 | 永久 |
| **可修改性** | 只读 | 可读写 | 可读写 |
| **Gas 成本** | 最低 | 中等 | 最高 |
| **使用场景** | 函数参数 | 函数内临时变量 | 状态变量 |
| **数据来源** | 交易数据 | 函数内创建或复制 | 区块链状态 |

## 5. 最佳实践和常见模式

### 模式1：批量操作
```solidity
contract BatchOperations {
    address[] public users;
    
    // 使用 calldata 处理批量地址更新
    function batchAddUsers(address[] calldata newUsers) external {
        for (uint i = 0; i < newUsers.length; i++) {
            users.push(newUsers[i]);
        }
    }
    
    // 使用 calldata 处理批量数值计算
    function calculateSum(uint[] calldata numbers) external pure returns (uint) {
        uint sum = 0;
        for (uint i = 0; i < numbers.length; i++) {
            sum += numbers[i];
        }
        return sum;
    }
}
```

### 模式2：数据验证
```solidity
contract DataValidator {
    // 使用 calldata 进行数据验证，避免不必要的复制
    function validateAndProcess(
        bytes calldata data,
        bytes calldata signature
    ) external view returns (bool) {
        // 验证签名
        address signer = recoverSigner(data, signature);
        require(signer != address(0), "Invalid signature");
        
        // 直接处理 calldata 数据
        return _validateData(data);
    }
    
    function recoverSigner(
        bytes calldata data,
        bytes calldata signature
    ) private pure returns (address) {
        // 签名验证逻辑
        // 直接使用 calldata，避免内存复制
        return address(0); // 简化示例
    }
    
    function _validateData(bytes calldata data) private pure returns (bool) {
        return data.length > 0;
    }
}
```

### 模式3：与 ABI 编码配合使用
```solidity
contract ABIExample {
    // 处理 ABI 编码的数据
    function decodeComplexData(
        bytes calldata encodedData
    ) external pure returns (string memory, uint[] memory) {
        // 直接解码 calldata
        (string memory name, uint[] memory values) = abi.decode(
            encodedData, 
            (string, uint[])
        );
        
        return (name, values);
    }
}
```

## 6. 重要注意事项

### 限制条件
```solidity
contract Limitations {
    // ✅ 正确：外部函数可以使用 calldata
    function externalWithCalldata(bytes calldata data) external {}
    
    // ✅ 正确：公共函数可以使用 calldata
    function publicWithCalldata(bytes calldata data) public {}
    
    // ❌ 错误：内部函数不能使用 calldata 参数
    // function internalWithCalldata(bytes calldata data) internal {}
    
    // ❌ 错误：私有函数不能使用 calldata 参数  
    // function privateWithCalldata(bytes calldata data) private {}
}
```

### 返回值限制
```solidity
contract ReturnLimitations {
    // ❌ 错误：不能返回 calldata 类型
    // function getData() external view returns (bytes calldata) {}
    
    // ✅ 正确：可以返回 memory 类型
    function getData() external view returns (bytes memory) {
        return abi.encode("example");
    }
}
```

## 总结

**使用 calldata 的关键场景：**
1. **外部函数的引用类型参数** - 这是主要用途
2. **Gas 优化** - 避免不必要的数据复制
3. **处理大量数据** - 特别是数组和字节数据
4. **只读访问** - 当只需要读取参数而不修改时

**选择原则：**
- 如果函数参数只需要读取，不需要修改 → 使用 `calldata`
- 如果参数需要修改 → 使用 `memory`  
- 如果是状态变量操作 → 使用 `storage`

正确使用 `calldata` 可以显著降低交易 Gas 成本，特别是在处理大型数据时效果更加明显。
