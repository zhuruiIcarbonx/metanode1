我来详细解释以太坊智能合约中的这些核心概念：

## 1. 合约生命周期

### 创建阶段
```solidity
// 合约部署时执行构造函数
contract MyContract {
    address public owner;
    uint public createdAt;
    
    // 构造函数 - 只在部署时执行一次
    constructor() {
        owner = msg.sender;
        createdAt = block.timestamp;
    }
}
```

### 运行阶段
```solidity
contract MyContract {
    uint public value;
    
    // 普通函数调用 - 改变合约状态
    function setValue(uint _newValue) public {
        value = _newValue; // 修改storage状态
    }
    
    // view函数 - 只读取不修改状态
    function getValue() public view returns (uint) {
        return value; // 不消耗Gas（本地调用）
    }
}
```

### 销毁阶段
```solidity
contract Destructible {
    address payable owner;
    
    constructor() {
        owner = payable(msg.sender);
    }
    
    // 自毁函数，将剩余ETH发送给owner
    function destroy() public {
        require(msg.sender == owner, "Only owner can destroy");
        selfdestruct(owner); // 合约从区块链移除
    }
}
```

## 2. 事件（Events）

```solidity
contract EventExample {
    // 声明事件
    event ValueChanged(address indexed _from, uint _oldValue, uint _newValue);
    event Transfer(address indexed from, address indexed to, uint amount);
    
    uint public value;
    
    function setValue(uint _newValue) public {
        uint oldValue = value;
        value = _newValue;
        
        // 触发事件 - 记录到交易日志中
        emit ValueChanged(msg.sender, oldValue, _newValue);
    }
    
    function transfer(address to, uint amount) public {
        // 执行转账逻辑...
        emit Transfer(msg.sender, to, amount); // 记录转账事件
    }
}
```

**事件特点：**
- 存储在交易日志中（比storage便宜）
- 可被前端DApp监听
- `indexed`参数支持高效过滤
- 不可在合约内访问，仅供外部查询

## 3. Modifier（修饰器）

```solidity
contract ModifierExample {
    address public owner;
    bool public paused = false;
    
    constructor() {
        owner = msg.sender;
    }
    
    // 修饰器定义
    modifier onlyOwner() {
        require(msg.sender == owner, "Only owner can call this");
        _; // 继续执行原函数
    }
    
    modifier whenNotPaused() {
        require(!paused, "Contract is paused");
        _;
    }
    
    modifier validAddress(address _addr) {
        require(_addr != address(0), "Invalid address");
        _;
    }
    
    // 使用多个修饰器
    function changeOwner(address _newOwner) 
        public 
        onlyOwner 
        whenNotPaused 
        validAddress(_newOwner) 
    {
        owner = _newOwner;
    }
    
    function pause() public onlyOwner {
        paused = true;
    }
    
    function unpause() public onlyOwner {
        paused = false;
    }
}
```

## 4. Storage vs Memory

### Storage（存储）
```solidity
contract StorageExample {
    // 状态变量 - 永久存储在区块链上
    uint public storageVar; // 存储在storage
    mapping(address => uint) public balances; // 存储在storage
    
    struct User {
        string name;
        uint balance;
    }
    User[] public users; // 数组存储在storage
    
    function storageOperations() public {
        // 局部变量默认指向storage
        User storage user = users[0]; // 引用类型，修改会影响原数据
        user.balance = 100; // 直接修改storage中的数据
    }
}
```

### Memory（内存）
```solidity
contract MemoryExample {
    uint[] public numbers = [1, 2, 3];
    
    function memoryOperations() public pure returns (uint) {
        // 内存变量 - 临时存在，函数结束时销毁
        uint[] memory localArray = new uint[](3);
        localArray[0] = 1;
        localArray[1] = 2;
        
        return localArray[0] + localArray[1]; // 返回3
    }
    
    function compareStorageMemory() public {
        uint[] storage storageRef = numbers; // 指向storage的引用
        uint[] memory memoryCopy = numbers; // 创建内存副本
        
        storageRef[0] = 100; // 修改会影响原numbers数组
        memoryCopy[0] = 200; // 只修改内存副本，不影响原数组
        
        // numbers[0] 现在是100，不是200
    }
}
```

### 关键区别总结

| 特性 | Storage | Memory |
|------|---------|---------|
| **持久性** | 永久存储 | 临时存储 |
| **Gas成本** | 高 | 低 |
| **数据位置** | 区块链状态 | EVM内存 |
| **赋值行为** | 引用传递 | 值传递 |
| **使用场景** | 状态变量 | 函数参数、局部变量 |

### 实际应用示例
```solidity
contract UserManager {
    struct User {
        string name;
        uint age;
    }
    
    User[] public users; // storage
    
    function addUser(string memory _name, uint _age) public {
        // 参数使用memory
        User memory newUser = User(_name, _age); // 在memory中创建
        users.push(newUser); // 复制到storage
    }
    
    function updateUser(uint index, string memory _name) public {
        // 修改storage中的用户数据
        User storage user = users[index]; // storage引用
        user.name = _name; // 直接修改原数据
    }
    
    function getUserInfo(uint index) public view returns (string memory, uint) {
        // 返回memory类型
        User memory user = users[index]; // 创建内存副本
        return (user.name, user.age);
    }
}
```

这些概念是以太坊智能合约开发的基础，理解它们对于编写高效、安全的合约至关重要。
