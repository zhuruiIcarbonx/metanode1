# 以太坊合约常见安全问题的解决方案

## 1. 重入攻击防护

### 1.1 Checks-Effects-Interactions 模式
```solidity
contract SecureBank {
    mapping(address => uint256) public balances;
    bool private locked;
    
    // 互斥锁修饰器
    modifier noReentrancy() {
        require(!locked, "No reentrancy");
        locked = true;
        _;
        locked = false;
    }
    
    function withdraw(uint256 amount) public noReentrancy {
        // CHECK: 条件检查
        require(balances[msg.sender] >= amount, "Insufficient balance");
        require(amount > 0, "Amount must be positive");
        
        // EFFECTS: 先更新状态
        balances[msg.sender] -= amount;
        
        // INTERACTIONS: 最后进行外部调用
        (bool success, ) = msg.sender.call{value: amount}("");
        require(success, "Transfer failed");
    }
}
```

### 1.2 OpenZeppelin ReentrancyGuard
```solidity
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

contract SecureContract is ReentrancyGuard {
    mapping(address => uint256) public balances;
    
    function safeWithdraw(uint256 amount) public nonReentrant {
        require(balances[msg.sender] >= amount, "Insufficient balance");
        
        balances[msg.sender] -= amount;
        payable(msg.sender).transfer(amount);
    }
    
    // 针对特定函数的重入保护
    function batchWithdraw(address[] calldata recipients, uint256[] calldata amounts) 
        external 
        nonReentrant 
    {
        require(recipients.length == amounts.length, "Arrays length mismatch");
        
        for (uint256 i = 0; i < recipients.length; i++) {
            _safeTransfer(recipients[i], amounts[i]);
        }
    }
    
    function _safeTransfer(address to, uint256 amount) internal {
        require(balances[msg.sender] >= amount, "Insufficient balance");
        balances[msg.sender] -= amount;
        payable(to).transfer(amount);
    }
}
```

### 1.3 提款模式 (Pull over Push)
```solidity
contract PullPayment {
    mapping(address => uint256) public pendingWithdrawals;
    
    function requestWithdraw(uint256 amount) public {
        require(balances[msg.sender] >= amount, "Insufficient balance");
        
        // 更新状态
        balances[msg.sender] -= amount;
        pendingWithdrawals[msg.sender] += amount;
        
        // 不立即转账，让用户自己提取
    }
    
    function withdraw() public {
        uint256 amount = pendingWithdrawals[msg.sender];
        require(amount > 0, "No pending withdrawal");
        
        // 重置状态前转账
        pendingWithdrawals[msg.sender] = 0;
        payable(msg.sender).transfer(amount);
    }
}
```

## 2. 整数溢出防护

### 2.1 Solidity 0.8+ 自动溢出检查
```solidity
contract SafeMathModern {
    // Solidity 0.8+ 自动进行溢出检查
    function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {
        return a + b; // 自动检查溢出
    }
    
    function safeSub(uint256 a, uint256 b) public pure returns (uint256) {
        return a - b; // 自动检查下溢
    }
    
    function safeMul(uint256 a, uint256 b) public pure returns (uint256) {
        return a * b; // 自动检查溢出
    }
    
    // 明确使用 unchecked 当确定不会溢出时
    function uncheckedAdd(uint256 a, uint256 b) public pure returns (uint256) {
        unchecked {
            return a + b; // 不检查溢出，节省 Gas
        }
    }
}
```

### 2.2 SafeMath 库（旧版本兼容）
```solidity
library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");
        return c;
    }
    
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, "SafeMath: subtraction overflow");
        return a - b;
    }
    
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");
        return c;
    }
    
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, "SafeMath: division by zero");
        return a / b;
    }
}

contract SafeMathLegacy {
    using SafeMath for uint256;
    
    function legacyAdd(uint256 a, uint256 b) public pure returns (uint256) {
        return a.add(b);
    }
}
```

### 2.3 边界检查工具函数
```solidity
contract BoundaryChecks {
    // 自定义边界检查
    function boundedAdd(uint256 a, uint256 b, uint256 max) public pure returns (uint256) {
        require(a <= max && b <= max, "Inputs too large");
        uint256 sum = a + b;
        require(sum >= a && sum <= max, "Addition overflow");
        return sum;
    }
    
    function boundedMultiply(uint256 a, uint256 b, uint256 max) public pure returns (uint256) {
        if (a == 0 || b == 0) return 0;
        require(a <= max && b <= max, "Inputs too large");
        
        // 检查乘法溢出
        if (a > type(uint256).max / b) {
            revert("Multiplication overflow");
        }
        uint256 product = a * b;
        require(product <= max, "Product exceeds maximum");
        return product;
    }
    
    // 安全的百分比计算
    function calculatePercentage(uint256 amount, uint256 percentage) public pure returns (uint256) {
        require(percentage <= 10000, "Percentage too large"); // 10000 = 100.00%
        return (amount * percentage) / 10000;
    }
}
```

## 3. 权限控制

### 3.1 基于角色的访问控制 (RBAC)
```solidity
import "@openzeppelin/contracts/access/AccessControl.sol";

contract RBACContract is AccessControl {
    bytes32 public constant ADMIN_ROLE = keccak256("ADMIN_ROLE");
    bytes32 public constant OPERATOR_ROLE = keccak256("OPERATOR_ROLE");
    bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");
    
    constructor() {
        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _grantRole(ADMIN_ROLE, msg.sender);
    }
    
    function sensitiveOperation() public onlyRole(ADMIN_ROLE) {
        // 只有管理员可以执行
    }
    
    function mintTokens(address to, uint256 amount) public onlyRole(MINTER_ROLE) {
        // 只有铸币者可以执行
    }
    
    // 角色管理函数
    function grantOperator(address account) public onlyRole(ADMIN_ROLE) {
        grantRole(OPERATOR_ROLE, account);
    }
    
    function revokeOperator(address account) public onlyRole(ADMIN_ROLE) {
        revokeRole(OPERATOR_ROLE, account);
    }
}
```

### 3.2 多签名权限控制
```solidity
contract MultiSigWallet {
    address[] public owners;
    mapping(address => bool) public isOwner;
    uint256 public required;
    
    struct Transaction {
        address to;
        uint256 value;
        bytes data;
        bool executed;
        uint256 confirmationCount;
    }
    
    mapping(uint256 => Transaction) public transactions;
    mapping(uint256 => mapping(address => bool)) public confirmations;
    uint256 public transactionCount;
    
    modifier onlyOwner() {
        require(isOwner[msg.sender], "Not owner");
        _;
    }
    
    constructor(address[] memory _owners, uint256 _required) {
        require(_owners.length > 0, "Owners required");
        require(_required > 0 && _required <= _owners.length, "Invalid required number");
        
        for (uint256 i = 0; i < _owners.length; i++) {
            address owner = _owners[i];
            require(owner != address(0), "Invalid owner");
            require(!isOwner[owner], "Owner not unique");
            
            isOwner[owner] = true;
            owners.push(owner);
        }
        required = _required;
    }
    
    function submitTransaction(address to, uint256 value, bytes memory data) 
        public 
        onlyOwner 
        returns (uint256) 
    {
        uint256 transactionId = transactionCount++;
        transactions[transactionId] = Transaction({
            to: to,
            value: value,
            data: data,
            executed: false,
            confirmationCount: 0
        });
        confirmTransaction(transactionId);
        return transactionId;
    }
    
    function confirmTransaction(uint256 transactionId) public onlyOwner {
        require(!confirmations[transactionId][msg.sender], "Transaction already confirmed");
        
        confirmations[transactionId][msg.sender] = true;
        transactions[transactionId].confirmationCount += 1;
        
        if (transactions[transactionId].confirmationCount >= required) {
            executeTransaction(transactionId);
        }
    }
    
    function executeTransaction(uint256 transactionId) internal {
        Transaction storage txn = transactions[transactionId];
        require(!txn.executed, "Transaction already executed");
        require(txn.confirmationCount >= required, "Insufficient confirmations");
        
        txn.executed = true;
        (bool success, ) = txn.to.call{value: txn.value}(txn.data);
        require(success, "Transaction execution failed");
    }
}
```

### 3.3 时间锁和权限延迟
```solidity
contract TimelockController {
    mapping(bytes32 => uint256) public timelocks;
    uint256 public constant DELAY = 2 days;
    
    event TimelockSet(bytes32 indexed operationId, uint256 executeAfter);
    event Executed(bytes32 indexed operationId);
    
    function setTimelock(bytes32 operationId) internal {
        timelocks[operationId] = block.timestamp + DELAY;
        emit TimelockSet(operationId, timelocks[operationId]);
    }
    
    function executeWithTimelock(
        bytes32 operationId,
        address target,
        bytes memory data
    ) internal {
        require(timelocks[operationId] > 0, "Timelock not set");
        require(block.timestamp >= timelocks[operationId], "Timelock not expired");
        
        delete timelocks[operationId];
        (bool success, ) = target.call(data);
        require(success, "Execution failed");
        
        emit Executed(operationId);
    }
    
    // 使用示例
    function scheduleUpgrade(address newImplementation) external onlyOwner {
        bytes32 operationId = keccak256(abi.encode("UPGRADE", newImplementation));
        setTimelock(operationId);
    }
    
    function executeUpgrade(address newImplementation) external onlyOwner {
        bytes32 operationId = keccak256(abi.encode("UPGRADE", newImplementation));
        bytes memory data = abi.encodeWithSignature("upgradeTo(address)", newImplementation);
        executeWithTimelock(operationId, address(this), data);
    }
}
```

## 4. 安全的随机数生成

### 4.1 Chainlink VRF（推荐方案）
```solidity
import "@chainlink/contracts/src/v0.8/VRFConsumerBase.sol";

contract SecureRandom is VRFConsumerBase {
    bytes32 internal keyHash;
    uint256 internal fee;
    uint256 public randomResult;
    mapping(bytes32 => address) public requesters;
    mapping(bytes32 => uint256) public requestIds;
    
    event RandomRequested(bytes32 indexed requestId, address indexed requester);
    event RandomFulfilled(bytes32 indexed requestId, uint256 randomNumber);
    
    constructor() 
        VRFConsumerBase(
            0x8C7382F9D8f56b33781fE506E897a4F1e2d17255, // VRF Coordinator
            0x326C977E6efc84E512bB9C30f76E30c160eD06FB  // LINK Token
        )
    {
        keyHash = 0x6e75b569a01ef56d18cab6a8e71e6600d6ce853834d4a5748b720d06f878b3a4;
        fee = 0.0001 * 10 ** 18; // 0.0001 LINK
    }
    
    function getRandomNumber() public returns (bytes32 requestId) {
        require(LINK.balanceOf(address(this)) >= fee, "Not enough LINK");
        requestId = requestRandomness(keyHash, fee);
        requesters[requestId] = msg.sender;
        emit RandomRequested(requestId, msg.sender);
    }
    
    function fulfillRandomness(bytes32 requestId, uint256 randomness) internal override {
        randomResult = randomness;
        emit RandomFulfilled(requestId, randomness);
        
        // 可以在这里触发依赖随机数的逻辑
        address requester = requesters[requestId];
        if (requester != address(0)) {
            // 调用回调函数或其他逻辑
        }
    }
    
    // 使用随机数进行抽奖
    function selectWinner(address[] memory participants) public {
        require(randomResult != 0, "Random number not ready");
        
        uint256 winnerIndex = randomResult % participants.length;
        address winner = participants[winnerIndex];
        
        // 使用后重置随机数，防止重复使用
        randomResult = 0;
        
        // 处理中奖逻辑
        _distributePrize(winner);
    }
    
    function _distributePrize(address winner) internal {
        // 分发奖品逻辑
    }
}
```

### 4.2 多块哈希随机数（相对安全方案）
```solidity
contract MultiBlockRandom {
    struct RandomRequest {
        uint256 blockNumber;
        address requester;
        bool fulfilled;
    }
    
    mapping(bytes32 => RandomRequest) public requests;
    uint256 public constant BLOCK_CONFIRMATIONS = 3;
    
    event RandomRequested(bytes32 requestId, uint256 blockNumber);
    event RandomFulfilled(bytes32 requestId, uint256 randomNumber);
    
    function requestRandom() external returns (bytes32) {
        bytes32 requestId = keccak256(abi.encode(msg.sender, block.number, block.timestamp));
        requests[requestId] = RandomRequest({
            blockNumber: block.number + BLOCK_CONFIRMATIONS,
            requester: msg.sender,
            fulfilled: false
        });
        
        emit RandomRequested(requestId, block.number + BLOCK_CONFIRMATIONS);
        return requestId;
    }
    
    function getRandomNumber(bytes32 requestId) external returns (uint256) {
        RandomRequest storage request = requests[requestId];
        require(request.requester == msg.sender, "Not requester");
        require(block.number >= request.blockNumber, "Blocks not confirmed");
        require(!request.fulfilled, "Already fulfilled");
        
        request.fulfilled = true;
        
        // 使用未来块的哈希生成随机数
        uint256 randomNumber = uint256(
            keccak256(
                abi.encodePacked(
                    blockhash(request.blockNumber),
                    msg.sender,
                    requestId
                )
            )
        );
        
        emit RandomFulfilled(requestId, randomNumber);
        return randomNumber;
    }
}
```

### 4.3 提交-揭示模式
```solidity
contract CommitRevealRandom {
    struct Commit {
        bytes32 commitment;
        uint256 revealBlock;
        bool revealed;
        uint256 randomNumber;
    }
    
    mapping(address => Commit) public commits;
    uint256 public constant REVEAL_DELAY = 5;
    
    event Committed(address indexed user, bytes32 commitment);
    event Revealed(address indexed user, uint256 randomNumber);
    
    function commit(bytes32 hashedValue) external {
        require(commits[msg.sender].commitment == bytes32(0), "Already committed");
        
        commits[msg.sender] = Commit({
            commitment: hashedValue,
            revealBlock: block.number + REVEAL_DELAY,
            revealed: false,
            randomNumber: 0
        });
        
        emit Committed(msg.sender, hashedValue);
    }
    
    function reveal(uint256 secret) external returns (uint256) {
        Commit storage userCommit = commits[msg.sender];
        require(userCommit.commitment != bytes32(0), "No commitment");
        require(block.number >= userCommit.revealBlock, "Reveal too early");
        require(!userCommit.revealed, "Already revealed");
        
        // 验证提交的值
        bytes32 calculatedHash = keccak256(abi.encodePacked(secret, msg.sender));
        require(calculatedHash == userCommit.commitment, "Invalid reveal");
        
        userCommit.revealed = true;
        userCommit.randomNumber = uint256(keccak256(abi.encodePacked(secret, blockhash(userCommit.revealBlock))));
        
        emit Revealed(msg.sender, userCommit.randomNumber);
        return userCommit.randomNumber;
    }
    
    // 批量生成随机数
    function generateBatchRandom(uint256[] calldata secrets) external {
        for (uint256 i = 0; i < secrets.length; i++) {
            reveal(secrets[i]);
        }
    }
}
```

## 5. 综合安全实践

### 5.1 安全基础合约模板
```solidity
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/access/AccessControl.sol";
import "@openzeppelin/contracts/security/Pausable.sol";

contract SecureBase is ReentrancyGuard, AccessControl, Pausable {
    bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");
    bytes32 public constant OPERATOR_ROLE = keccak256("OPERATOR_ROLE");
    
    // 事件记录
    event EmergencyStop(bool stopped, address by, uint256 timestamp);
    event FundsRecovered(address token, uint256 amount, address to);
    
    constructor() {
        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _grantRole(PAUSER_ROLE, msg.sender);
        _grantRole(OPERATOR_ROLE, msg.sender);
    }
    
    // 紧急停止机制
    function emergencyStop() external onlyRole(PAUSER_ROLE) {
        _pause();
        emit EmergencyStop(true, msg.sender, block.timestamp);
    }
    
    function emergencyResume() external onlyRole(PAUSER_ROLE) {
        _unpause();
        emit EmergencyStop(false, msg.sender, block.timestamp);
    }
    
    // 资金恢复功能
    function recoverERC20(address tokenAddress, uint256 amount) external onlyRole(DEFAULT_ADMIN_ROLE) {
        IERC20 token = IERC20(tokenAddress);
        token.transfer(msg.sender, amount);
        emit FundsRecovered(tokenAddress, amount, msg.sender);
    }
    
    function recoverETH(uint256 amount) external onlyRole(DEFAULT_ADMIN_ROLE) {
        payable(msg.sender).transfer(amount);
        emit FundsRecovered(address(0), amount, msg.sender);
    }
    
    // 通用的安全检查修饰器
    modifier validAddress(address addr) {
        require(addr != address(0), "Invalid address");
        _;
    }
    
    modifier validAmount(uint256 amount) {
        require(amount > 0, "Invalid amount");
        _;
    }
    
    // 当合约暂停时阻止关键操作
    modifier whenNotStopped() {
        require(!paused(), "Contract is paused");
        _;
    }
}

// 具体业务合约继承安全基础
contract MySecureContract is SecureBase {
    mapping(address => uint256) public balances;
    
    function deposit() external payable whenNotStopped validAmount(msg.value) {
        balances[msg.sender] += msg.value;
    }
    
    function withdraw(uint256 amount) 
        external 
        nonReentrant 
        whenNotStopped 
        validAmount(amount) 
    {
        require(balances[msg.sender] >= amount, "Insufficient balance");
        
        balances[msg.sender] -= amount;
        payable(msg.sender).transfer(amount);
    }
    
    function sensitiveOperation() external onlyRole(OPERATOR_ROLE) whenNotStopped {
        // 需要操作员权限的敏感操作
    }
}
```

### 5.2 安全检测和监控
```solidity
contract SecurityMonitor {
    event SuspiciousActivity(address indexed from, string reason, bytes data);
    event LargeTransfer(address indexed from, address indexed to, uint256 amount);
    event ContractInteraction(address indexed from, address indexed contractAddress);
    
    uint256 public constant LARGE_TRANSFER_THRESHOLD = 1000 ether;
    mapping(address => bool) public blacklist;
    mapping(address => uint256) public lastOperationTime;
    uint256 public constant TIME_LOCK = 1 hours;
    
    modifier notBlacklisted() {
        require(!blacklist[msg.sender], "Address is blacklisted");
        _;
    }
    
    modifier rateLimited() {
        require(block.timestamp >= lastOperationTime[msg.sender] + TIME_LOCK, "Rate limited");
        lastOperationTime[msg.sender] = block.timestamp;
        _;
    }
    
    function monitorTransfer(address from, address to, uint256 amount) internal {
        // 监控大额转账
        if (amount >= LARGE_TRANSFER_THRESHOLD) {
            emit LargeTransfer(from, to, amount);
        }
        
        // 检查黑名单
        if (blacklist[from] || blacklist[to]) {
            emit SuspiciousActivity(from, "Blacklisted address involved", msg.data);
        }
    }
    
    function monitorContractCall(address contractAddress) internal {
        uint32 size;
        assembly {
            size := extcodesize(contractAddress)
        }
        
        if (size > 0) {
            emit ContractInteraction(msg.sender, contractAddress);
            
            // 可以添加更复杂的合约交互分析
            if (_isSuspiciousContract(contractAddress)) {
                emit SuspiciousActivity(msg.sender, "Interacted with suspicious contract", msg.data);
            }
        }
    }
    
    function _isSuspiciousContract(address contractAddress) internal view returns (bool) {
        // 实现合约分析逻辑
        // 可以检查字节码特征、已知恶意合约地址等
        return false;
    }
    
    function addToBlacklist(address addr) external onlyOwner {
        blacklist[addr] = true;
    }
    
    function removeFromBlacklist(address addr) external onlyOwner {
        blacklist[addr] = false;
    }
}
```

## 6. 部署前安全检查清单

### 代码审查清单：
- [ ] 所有外部调用都有重入保护
- [ ] 数学运算有溢出保护
- [ ] 权限控制完善
- [ ] 随机数生成安全
- [ ] 输入验证充分
- [ ] 错误处理完善
- [ ] 事件日志完整

### 测试清单：
- [ ] 单元测试覆盖所有功能
- [ ] 重入攻击测试
- [ ] 边界条件测试
- [ ] 权限测试
- [ ] Gas 消耗测试
- [ ] 集成测试

### 工具检查：
```bash
# 使用 Slither 进行静态分析
slither . --exclude-informational

# 使用 Mythril 进行符号执行
myth analyze contract.sol

# 使用 Echidna 进行模糊测试
echidna-test contract.sol

# 使用 Foundry 进行测试
forge test --fork-url $RPC_URL
```

通过实施这些安全措施，可以显著提高智能合约的安全性，防止常见的攻击向量。记住，安全是一个持续的过程，需要定期审计和更新。
