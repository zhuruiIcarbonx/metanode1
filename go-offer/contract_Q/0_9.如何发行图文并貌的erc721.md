# 如何发行图文并茂的ERC721 NFT

下面我将详细介绍如何创建支持图文内容的ERC721 NFT，包括完整的代码实现和最佳实践。

## 1. 基础ERC721合约

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Base64.sol";
import "@openzeppelin/contracts/utils/Strings.sol";

contract RichContentNFT is ERC721, ERC721Enumerable, Ownable {
    using Strings for uint256;
    
    // NFT元数据存储
    struct NFTData {
        string title;
        string description;
        string imageUrl;
        string externalUrl;
        string[] attributes;
        string richContent; // 富文本内容（HTML/Markdown）
        string contentType; // 内容类型：html/markdown/text
    }
    
    mapping(uint256 => NFTData) private _tokenData;
    uint256 private _nextTokenId;
    string public baseExtension = ".json";
    
    constructor() ERC721("RichContentNFT", "RCNFT") {}
    
    // 铸造带有多媒体内容的NFT
    function mintNFT(
        address to,
        string memory title,
        string memory description,
        string memory imageUrl,
        string memory externalUrl,
        string[] memory attributes,
        string memory richContent,
        string memory contentType
    ) public onlyOwner returns (uint256) {
        uint256 tokenId = _nextTokenId++;
        _mint(to, tokenId);
        
        _tokenData[tokenId] = NFTData({
            title: title,
            description: description,
            imageUrl: imageUrl,
            externalUrl: externalUrl,
            attributes: attributes,
            richContent: richContent,
            contentType: contentType
        });
        
        return tokenId;
    }
    
    // 生成完整的tokenURI（Base64编码）
    function tokenURI(uint256 tokenId) 
        public 
        view 
        virtual 
        override 
        returns (string memory) 
    {
        require(_exists(tokenId), "Token does not exist");
        
        NFTData memory data = _tokenData[tokenId];
        
        // 构建属性数组
        string memory attributesJson = "";
        for (uint i = 0; i < data.attributes.length; i++) {
            attributesJson = string(abi.encodePacked(
                attributesJson,
                '{"trait_type":"Attribute ',
                (i+1).toString(),
                '","value":"',
                data.attributes[i],
                '"}',
                i < data.attributes.length - 1 ? ',' : ''
            ));
        }
        
        // 构建完整的metadata JSON
        string memory json = Base64.encode(
            bytes(string(abi.encodePacked(
                '{"name": "', data.title, '",',
                '"description": "', data.description, '",',
                '"image": "', data.imageUrl, '",',
                '"external_url": "', data.externalUrl, '",',
                '"attributes": [', attributesJson, '],',
                '"rich_content": "', data.richContent, '",',
                '"content_type": "', data.contentType, '",',
                '"created_by": "Rich Content NFT Collection"',
                '}'
            )))
        );
        
        return string(abi.encodePacked("data:application/json;base64,", json));
    }
    
    // 获取NFT详细数据
    function getNFTData(uint256 tokenId) 
        public 
        view 
        returns (NFTData memory) 
    {
        require(_exists(tokenId), "Token does not exist");
        return _tokenData[tokenId];
    }
    
    // 更新NFT内容（仅限所有者）
    function updateNFTContent(
        uint256 tokenId,
        string memory newRichContent,
        string memory newContentType
    ) public {
        require(ownerOf(tokenId) == msg.sender, "Not token owner");
        _tokenData[tokenId].richContent = newRichContent;
        _tokenData[tokenId].contentType = newContentType;
    }
    
    // 必需的覆盖函数
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 tokenId,
        uint256 batchSize
    ) internal override(ERC721, ERC721Enumerable) {
        super._beforeTokenTransfer(from, to, tokenId, batchSize);
    }
    
    function supportsInterface(bytes4 interfaceId)
        public
        view
        override(ERC721, ERC721Enumerable)
        returns (bool)
    {
        return super.supportsInterface(interfaceId);
    }
}
```

## 2. 高级功能：支持IPFS存储

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "./RichContentNFT.sol";

contract IPFSRichContentNFT is RichContentNFT {
    string public baseTokenURI;
    mapping(uint256 => string) private _ipfsHashes;
    
    constructor(string memory _baseTokenURI) {
        baseTokenURI = _baseTokenURI;
    }
    
    // 使用IPFS哈希铸造NFT
    function mintWithIPFS(
        address to,
        string memory title,
        string memory description,
        string memory imageIpfsHash,
        string memory contentIpfsHash,
        string[] memory attributes,
        string memory contentType
    ) public onlyOwner returns (uint256) {
        uint256 tokenId = _nextTokenId++;
        _mint(to, tokenId);
        
        // 存储IPFS哈希
        _ipfsHashes[tokenId] = contentIpfsHash;
        
        _tokenData[tokenId] = NFTData({
            title: title,
            description: description,
            imageUrl: string(abi.encodePacked("ipfs://", imageIpfsHash)),
            externalUrl: "",
            attributes: attributes,
            richContent: string(abi.encodePacked("ipfs://", contentIpfsHash)),
            contentType: contentType
        });
        
        return tokenId;
    }
    
    // 重写tokenURI使用IPFS
    function tokenURI(uint256 tokenId) 
        public 
        view 
        virtual 
        override 
        returns (string memory) 
    {
        require(_exists(tokenId), "Token does not exist");
        
        // 如果设置了基础URI，使用传统的JSON文件方式
        if (bytes(baseTokenURI).length > 0) {
            return string(abi.encodePacked(baseTokenURI, tokenId.toString(), baseExtension));
        }
        
        // 否则使用on-chain metadata
        return super.tokenURI(tokenId);
    }
    
    // 获取IPFS哈希
    function getIPFSHash(uint256 tokenId) public view returns (string memory) {
        require(_exists(tokenId), "Token does not exist");
        return _ipfsHashes[tokenId];
    }
}
```

## 3. 前端交互代码

```javascript
// NFT铸造前端代码
class NFTMinter {
    constructor(contractAddress, provider) {
        this.contractAddress = contractAddress;
        this.provider = provider;
        this.contract = this.getContract();
    }
    
    async mintRichContentNFT(nftData) {
        try {
            const { ethereum } = window;
            
            if (ethereum) {
                const accounts = await ethereum.request({ 
                    method: 'eth_requestAccounts' 
                });
                
                // 准备交易参数
                const transaction = await this.contract.mintNFT(
                    accounts[0],
                    nftData.title,
                    nftData.description,
                    nftData.imageUrl,
                    nftData.externalUrl || "",
                    nftData.attributes || [],
                    nftData.richContent,
                    nftData.contentType || "html"
                );
                
                return await transaction.wait();
            }
        } catch (error) {
            console.error("Minting failed:", error);
            throw error;
        }
    }
    
    // 上传内容到IPFS
    async uploadToIPFS(content) {
        // 使用Pinata, Web3.Storage或类似服务
        const formData = new FormData();
        const blob = new Blob([content], { type: 'text/html' });
        formData.append('file', blob);
        
        const response = await fetch('https://api.pinata.cloud/pinning/pinFileToIPFS', {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${process.env.PINATA_JWT}`
            },
            body: formData
        });
        
        const data = await response.json();
        return data.IpfsHash;
    }
    
    // 生成预览HTML
    generatePreviewHTML(nftData) {
        return `
            <!DOCTYPE html>
            <html>
            <head>
                <title>${nftData.title}</title>
                <style>
                    body { 
                        font-family: Arial, sans-serif; 
                        max-width: 800px; 
                        margin: 0 auto; 
                        padding: 20px;
                    }
                    .nft-header { 
                        text-align: center; 
                        margin-bottom: 30px;
                    }
                    .nft-image { 
                        max-width: 100%; 
                        height: auto; 
                        border-radius: 10px;
                    }
                    .rich-content { 
                        margin-top: 30px; 
                        line-height: 1.6;
                    }
                </style>
            </head>
            <body>
                <div class="nft-header">
                    <h1>${nftData.title}</h1>
                    <img src="${nftData.imageUrl}" alt="${nftData.title}" class="nft-image">
                    <p>${nftData.description}</p>
                </div>
                <div class="rich-content">
                    ${nftData.richContent}
                </div>
            </body>
            </html>
        `;
    }
}

// 使用示例
const nftData = {
    title: "我的图文NFT",
    description: "这是一个包含丰富图文内容的NFT作品",
    imageUrl: "https://example.com/nft-image.jpg",
    externalUrl: "https://mywebsite.com/nft-details",
    attributes: ["稀有", "限量版", "艺术创作"],
    richContent: `
        <h2>作品介绍</h2>
        <p>这是我创作的数字艺术作品，结合了传统绘画和数字技术。</p>
        <h3>创作理念</h3>
        <p>通过这幅作品，我想表达...</p>
        <ul>
            <li>创新思维</li>
            <li>技术融合</li>
            <li>艺术表达</li>
        </ul>
        <img src="https://example.com/detail-image.jpg" alt="细节图" style="max-width: 100%;">
    `,
    contentType: "html"
};
```

## 4. 部署脚本

```javascript
// deploy.js
const { ethers } = require("hardhat");

async function main() {
    const [deployer] = await ethers.getSigners();
    
    console.log("部署合约的账户:", deployer.address);
    
    // 部署基础合约
    const RichContentNFT = await ethers.getContractFactory("RichContentNFT");
    const nftContract = await RichContentNFT.deploy();
    
    await nftContract.deployed();
    
    console.log("RichContentNFT 部署地址:", nftContract.address);
    
    // 部署IPFS版本
    const IPFSRichContentNFT = await ethers.getContractFactory("IPFSRichContentNFT");
    const ipfsNftContract = await IPFSRichContentNFT.deploy("https://ipfs.io/ipfs/");
    
    await ipfsNftContract.deployed();
    
    console.log("IPFSRichContentNFT 部署地址:", ipfsNftContract.address);
    
    return {
        nftContract: nftContract.address,
        ipfsNftContract: ipfsNftContract.address
    };
}

main()
    .then(() => process.exit(0))
    .catch((error) => {
        console.error(error);
        process.exit(1);
    });
```

## 5. 测试用例

```javascript
// test/NFT.test.js
const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("RichContentNFT", function () {
    let nft;
    let owner;
    let addr1;

    beforeEach(async function () {
        [owner, addr1] = await ethers.getSigners();
        
        const RichContentNFT = await ethers.getContractFactory("RichContentNFT");
        nft = await RichContentNFT.deploy();
        await nft.deployed();
    });

    it("应该正确铸造NFT", async function () {
        const attributes = ["稀有", "艺术"];
        const richContent = "<h1>测试内容</h1><p>这是测试</p>";
        
        await nft.mintNFT(
            owner.address,
            "测试NFT",
            "测试描述",
            "https://example.com/image.jpg",
            "https://example.com",
            attributes,
            richContent,
            "html"
        );

        expect(await nft.ownerOf(0)).to.equal(owner.address);
    });

    it("应该返回正确的tokenURI", async function () {
        const attributes = ["测试属性"];
        const richContent = "测试富文本内容";
        
        await nft.mintNFT(
            owner.address,
            "测试NFT",
            "测试描述",
            "https://example.com/image.jpg",
            "",
            attributes,
            richContent,
            "html"
        );

        const tokenURI = await nft.tokenURI(0);
        expect(tokenURI).to.include("data:application/json;base64");
    });
});
```

## 6. 最佳实践建议

### 存储策略
- **小内容**: 使用on-chain存储（Base64编码）
- **大内容**: 使用IPFS/Arweave等去中心化存储
- **混合方案**: 元数据在链上，媒体文件在链下

### 内容格式
```javascript
// 推荐的NFT数据结构
const recommendedNFTStructure = {
    title: "作品标题",
    description: "作品描述",
    image: "主图URL",
    external_url: "外部链接",
    attributes: [
        { trait_type: "艺术家", value: "作者名" },
        { trait_type: "创作日期", value: "2024-01-01" },
        { trait_type: "稀有度", value: "稀有" }
    ],
    // 富文本内容
    rich_content: {
        type: "html/markdown",
        content: "完整的HTML/Markdown内容",
        version: "1.0"
    },
    // 多媒体资源
    media: [
        { type: "image", url: "图片1", description: "图片描述" },
        { type: "video", url: "视频1", description: "视频描述" }
    ]
}
```

### Gas优化
- 使用字符串压缩
- 批量操作减少交易次数
- 合理使用存储布局

这个完整的解决方案可以让你创建功能丰富的图文NFT，支持各种媒体格式和交互功能。
