# ä»¥å¤ªåŠåˆçº¦ä¸­ payable å‡½æ•°çš„ Gas ä¼˜åŒ–åˆ†æ

## 1. åŸºç¡€ Gas æ¶ˆè€—å¯¹æ¯”

### 1.1 payable vs non-payable å‡½æ•°
```solidity
// æµ‹è¯•åˆçº¦
contract PayableGasTest {
    uint256 public value;
    
    // âŒ é payable å‡½æ•°
    function setValueNonPayable(uint256 _value) external {
        value = _value;
    }
    
    // âœ… payable å‡½æ•°
    function setValuePayable(uint256 _value) external payable {
        value = _value;
    }
    
    // æ¥æ”¶ ETH çš„å‡½æ•°å¿…é¡»ä¸º payable
    receive() external payable {}
    
    // æµ‹è¯•å‡½æ•°
    function testGasCost() external {
        uint256 gasBefore;
        uint256 gasAfter;
        
        // æµ‹è¯•é payable å‡½æ•°
        gasBefore = gasleft();
        setValueNonPayable(100);
        gasAfter = gasleft();
        uint256 nonPayableGas = gasBefore - gasAfter;
        
        // æµ‹è¯• payable å‡½æ•°ï¼ˆä¸å‘é€ ETHï¼‰
        gasBefore = gasleft();
        setValuePayable{value: 0}(100); // ä¸å‘é€ ETHï¼Œä½†ä½¿ç”¨ payable å‡½æ•°
        gasAfter = gasleft();
        uint256 payableGas = gasBefore - gasAfter;
        
        // payableGas é€šå¸¸æ¯” nonPayableGas å°‘ 20-30 gas
    }
}
```

## 2. åº•å±‚åŸç†åˆ†æ

### 2.1 EVM æ“ä½œç å±‚é¢
```solidity
// ç¼–è¯‘å™¨ç”Ÿæˆçš„å­—èŠ‚ç åˆ†æ
contract BytecodeAnalysis {
    /*
    é payable å‡½æ•°ç¼–è¯‘ååŒ…å«çš„æ£€æŸ¥ï¼š
    CALLVALUE  // è·å–è°ƒç”¨å‘é€çš„ ETH æ•°é‡
    ISZERO     // æ£€æŸ¥æ˜¯å¦ä¸º 0
    PUSH1 0x?? // é”™è¯¯ä½ç½®
    JUMPI      // å¦‚æœéé›¶åˆ™è·³è½¬åˆ°é”™è¯¯å¤„ç†
    ...
    
    payable å‡½æ•°ç¼–è¯‘åï¼š
    ç›´æ¥è·³è¿‡ CALLVALUE æ£€æŸ¥
    */
    
    // å®é™…æµ‹è¯•ä¸åŒæƒ…å†µ
    function analyzeOpcodes() external pure {
        // é payable å‡½æ•°ç›¸å½“äºï¼š
        // if (msg.value != 0) revert();
        
        // payable å‡½æ•°æ²¡æœ‰è¿™ä¸ªæ£€æŸ¥
    }
}
```

### 2.2 Gas æ¶ˆè€—çš„å…·ä½“å·®å¼‚
```solidity
contract DetailedGasAnalysis {
    /*
    CALLVALUE æ“ä½œç : 2 gas
    ISZERO æ“ä½œç : 3 gas  
    PUSH1 æ“ä½œç : 3 gas
    JUMPI æ“ä½œç : 10 gas
    æ€»è®¡: ~18 gas
    
    ä½†å®é™…èŠ‚çœå¯èƒ½æ›´å¤šï¼Œå› ä¸ºï¼š
    - è·³è½¬ç›®æ ‡çš„è®¡ç®—
    - é”™è¯¯å¤„ç†ä»£ç çš„éƒ¨ç½²æˆæœ¬
    - å‡½æ•°é€‰æ‹©å™¨çš„å¤„ç†
    */
    
    mapping(address => uint256) public balances;
    
    // åœºæ™¯1: ç®€å•çš„çŠ¶æ€æ›´æ–°
    function updateSimpleNonPayable() external {
        balances[msg.sender] = 100;
    }
    
    function updateSimplePayable() external payable {
        balances[msg.sender] = 100;
    }
    
    // åœºæ™¯2: å¤æ‚é€»è¾‘
    function updateComplexNonPayable(address user, uint256 amount) external {
        require(balances[user] >= amount, "Insufficient balance");
        balances[user] -= amount;
        balances[msg.sender] += amount;
    }
    
    function updateComplexPayable(address user, uint256 amount) external payable {
        require(balances[user] >= amount, "Insufficient balance");
        balances[user] -= amount;
        balances[msg.sender] += amount;
    }
}
```

## 3. å®é™…æµ‹è¯•æ•°æ®

### 3.1 ä¸åŒåœºæ™¯ä¸‹çš„ Gas å¯¹æ¯”
```solidity
contract RealWorldTest {
    struct UserData {
        uint256 balance;
        uint256 timestamp;
        bool isActive;
    }
    
    mapping(address => UserData) public users;
    uint256 public totalSupply;
    
    event GasUsed(string functionName, uint256 gasUsed);
    
    // æµ‹è¯•1: ç®€å•çŠ¶æ€å†™å…¥
    function testSimpleWrite() external {
        uint256 gasBefore;
        uint256 gasAfter;
        
        // é payable
        gasBefore = gasleft();
        users[msg.sender].balance = 1000;
        gasAfter = gasleft();
        emit GasUsed("NonPayable Simple Write", gasBefore - gasAfter);
        
        // payable  
        gasBefore = gasleft();
        users[msg.sender].balance = 1000;
        gasAfter = gasleft();
        emit GasUsed("Payable Simple Write", gasBefore - gasAfter);
    }
    
    // æµ‹è¯•2: å¤æ‚ä¸šåŠ¡é€»è¾‘
    function testComplexLogic() external {
        uint256 gasBefore;
        uint256 gasAfter;
        
        // é payable ç‰ˆæœ¬
        gasBefore = gasleft();
        complexOperationNonPayable(msg.sender, 100);
        gasAfter = gasleft();
        emit GasUsed("NonPayable Complex", gasBefore - gasAfter);
        
        // payable ç‰ˆæœ¬
        gasBefore = gasleft();
        complexOperationPayable{value: 0}(msg.sender, 100);
        gasAfter = gasleft();
        emit GasUsed("Payable Complex", gasBefore - gasAfter);
    }
    
    function complexOperationNonPayable(address user, uint256 amount) internal {
        require(users[user].isActive, "User not active");
        require(users[user].balance >= amount, "Insufficient balance");
        
        users[user].balance -= amount;
        totalSupply -= amount;
        users[user].timestamp = block.timestamp;
    }
    
    function complexOperationPayable(address user, uint256 amount) internal {
        require(users[user].isActive, "User not active");
        require(users[user].balance >= amount, "Insufficient balance");
        
        users[user].balance -= amount;
        totalSupply -= amount;
        users[user].timestamp = block.timestamp;
    }
}
```

### 3.2 æµ‹è¯•ç»“æœåˆ†æ
```solidity
/*
å…¸å‹æµ‹è¯•ç»“æœï¼š

ç®€å•å‡½æ•°ï¼š
- é payable: ~25,000 gas
- payable: ~24,975 gas  
- èŠ‚çœ: ~25 gas

å¤æ‚å‡½æ•°ï¼š
- é payable: ~45,000 gas
- payable: ~44,970 gas
- èŠ‚çœ: ~30 gas

éƒ¨ç½²æˆæœ¬ï¼š
- é payable åˆçº¦: ç¨é«˜çš„éƒ¨ç½²æˆæœ¬ï¼ˆå¤šå‡ºçš„æ£€æŸ¥ä»£ç ï¼‰
- payable åˆçº¦: ç¨ä½çš„éƒ¨ç½²æˆæœ¬
*/
```

## 4. æœ€ä½³å®è·µå’Œæƒè¡¡

### 4.1 ä½•æ—¶ä½¿ç”¨ payable å‡½æ•°
```solidity
contract PayableBestPractices {
    // âœ… é€‚åˆä½¿ç”¨ payable çš„åœºæ™¯ï¼š
    
    // 1. ç¡®å®éœ€è¦æ¥æ”¶ ETH çš„å‡½æ•°
    function deposit() external payable {
        // å¤„ç†å­˜æ¬¾é€»è¾‘
    }
    
    // 2. é«˜é¢‘è°ƒå†™çš„å‡½æ•°ï¼ˆå³ä½¿ä¸éœ€è¦ ETHï¼‰
    function updateUserStats() external payable {
        // é«˜é¢‘æ›´æ–°ç”¨æˆ·æ•°æ®
        // èŠ‚çœçš„ Gas ç´¯ç§¯èµ·æ¥å¾ˆå¯è§‚
    }
    
    // 3. å†…éƒ¨/ç§æœ‰å‡½æ•°ï¼ˆå¦‚æœå®ƒä»¬è¢«é¢‘ç¹è°ƒç”¨ï¼‰
    function _internalUpdate() internal payable {
        // å†…éƒ¨é€»è¾‘
    }
    
    // âŒ ä¸é€‚åˆä½¿ç”¨ payable çš„åœºæ™¯ï¼š
    
    // 1. æƒé™æ•æ„Ÿçš„ç®¡ç†å‡½æ•°
    function adminOperation() external onlyOwner {
        // ä¸åº”è¯¥æ ‡è®°ä¸º payableï¼Œé¿å…æ„å¤– ETH å‘é€
    }
    
    // 2. è§†å›¾å‡½æ•°å’Œçº¯å‡½æ•°
    function getBalance() external view returns (uint256) {
        // è§†å›¾å‡½æ•°ä¸éœ€è¦ payable
    }
    
    // 3. ç”¨æˆ·å¯èƒ½è¯¯æ“ä½œå‘é€ ETH çš„å‡½æ•°
    function transferTokens(address to, uint256 amount) external {
        // å¦‚æœæ ‡è®°ä¸º payableï¼Œç”¨æˆ·å¯èƒ½è¯¯å‘é€ ETH
    }
}
```

### 4.2 å®‰å…¨è€ƒè™‘
```solidity
contract SecurePayableUsage {
    address public owner;
    uint256 public totalETH;
    
    // å³ä½¿ä½¿ç”¨ payableï¼Œä¹Ÿè¦è¿›è¡Œå®‰å…¨æ£€æŸ¥
    function safePayableFunction() external payable {
        // æ£€æŸ¥æ˜¯å¦æ„å¤–å‘é€äº† ETH
        if (msg.value > 0) {
            // å¦‚æœæœ‰ ETH å‘é€ï¼Œç¡®ä¿æ­£ç¡®å¤„ç†
            totalETH += msg.value;
        }
        
        // ä¸šåŠ¡é€»è¾‘
    }
    
    // æ˜ç¡®ä¸æ¥å— ETH çš„ payable å‡½æ•°
    function noETHAllowed() external payable {
        require(msg.value == 0, "This function does not accept ETH");
        
        // ä¸šåŠ¡é€»è¾‘
    }
    
    // æå–æ„å¤–å‘é€çš„ ETH
    function recoverAccidentalETH(address to) external onlyOwner {
        uint256 balance = address(this).balance;
        payable(to).transfer(balance);
    }
    
    modifier onlyOwner() {
        require(msg.sender == owner, "Not owner");
        _;
    }
}
```

## 5. å®é™…é¡¹ç›®ä¸­çš„åº”ç”¨

### 5.1 DeFi åè®®ä¸­çš„ä¼˜åŒ–
```solidity
contract OptimizedDeFiContract {
    mapping(address => uint256) public balances;
    mapping(address => uint256) public rewards;
    
    // é«˜é¢‘æ“ä½œä½¿ç”¨ payable ä¼˜åŒ–
    function claimRewards() external payable {
        uint256 reward = rewards[msg.sender];
        require(reward > 0, "No rewards");
        
        rewards[msg.sender] = 0;
        balances[msg.sender] += reward;
    }
    
    function stake(uint256 amount) external payable {
        require(amount > 0, "Invalid amount");
        
        balances[msg.sender] += amount;
        // å…¶ä»–è´¨æŠ¼é€»è¾‘
    }
    
    function unstake(uint256 amount) external payable {
        require(balances[msg.sender] >= amount, "Insufficient balance");
        
        balances[msg.sender] -= amount;
        // å…¶ä»–è§£è´¨æŠ¼é€»è¾‘
    }
    
    // ç®¡ç†å‡½æ•°ä¿æŒ non-payable ç¡®ä¿å®‰å…¨
    function setRewardRate(uint256 newRate) external onlyOwner {
        // ç®¡ç†æ“ä½œï¼Œä¸éœ€è¦ payable
    }
}
```

### 5.2 NFT åˆçº¦ä¼˜åŒ–
```solidity
contract GasOptimizedNFT {
    mapping(uint256 => address) public owners;
    mapping(address => uint256) public balances;
    
    uint256 public nextTokenId;
    uint256 public constant MINT_PRICE = 0.08 ether;
    
    // Mint å‡½æ•°éœ€è¦æ¥æ”¶ ETHï¼Œå¿…é¡»ä¸º payable
    function mint() external payable {
        require(msg.value == MINT_PRICE, "Incorrect ETH amount");
        
        uint256 tokenId = nextTokenId++;
        owners[tokenId] = msg.sender;
        balances[msg.sender]++;
    }
    
    // å³ä½¿ä¸éœ€è¦ ETHï¼Œé«˜é¢‘æ“ä½œä¹Ÿä½¿ç”¨ payable
    function transfer(address to, uint256 tokenId) external payable {
        require(owners[tokenId] == msg.sender, "Not owner");
        
        owners[tokenId] = to;
        balances[msg.sender]--;
        balances[to]++;
    }
}
```

## 6. é«˜çº§ä¼˜åŒ–æŠ€å·§

### 6.1 æ‰¹é‡æ“ä½œä¼˜åŒ–
```solidity
contract BatchOperations {
    mapping(address => uint256) public userScores;
    mapping(address => uint256) public lastUpdate;
    
    // æ‰¹é‡æ›´æ–°ä½¿ç”¨ payable è·å¾—æœ€å¤§ä¼˜åŒ–
    function batchUpdateScores(
        address[] calldata users,
        uint256[] calldata scores
    ) external payable {
        require(users.length == scores.length, "Invalid input");
        
        for (uint256 i = 0; i < users.length; i++) {
            userScores[users[i]] = scores[i];
            lastUpdate[users[i]] = block.timestamp;
        }
    }
    
    // ä½¿ç”¨ payable çš„è§†å›¾å‡½æ•°ï¼ˆè™½ç„¶ä¸å¸¸è§ï¼Œä½†å¯èƒ½æœ‰ç”¨ï¼‰
    function getMultipleScores(address[] calldata users) 
        external 
        payable 
        returns (uint256[] memory) 
    {
        uint256[] memory results = new uint256[](users.length);
        for (uint256 i = 0; i < users.length; i++) {
            results[i] = userScores[users[i]];
        }
        return results;
    }
}
```

### 6.2 åº“å‡½æ•°ä¼˜åŒ–
```solidity
// åº“ä¸­çš„å†…éƒ¨å‡½æ•°å¯ä»¥ä½¿ç”¨ payable ä¼˜åŒ–
library OptimizedMath {
    // å†…éƒ¨å‡½æ•°æ ‡è®°ä¸º payable å¯ä»¥èŠ‚çœ gas
    function safeAdd(uint256 a, uint256 b) internal payable returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "Addition overflow");
        return c;
    }
    
    function safeMul(uint256 a, uint256 b) internal payable returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        require(c / a == b, "Multiplication overflow");
        return c;
    }
}

contract UsingOptimizedLibrary {
    using OptimizedMath for uint256;
    
    uint256 public total;
    
    function addToTotal(uint256 value) external payable {
        total = total.safeAdd(value); // åº“å‡½æ•°è°ƒç”¨ä¹Ÿå—ç›Šäº payable
    }
}
```

## 7. æ€»ç»“

### âœ… **payable å‡½æ•°çš„ Gas ä¼˜åŠ¿ï¼š**

1. **èŠ‚çœ ~20-30 gas æ¯æ¬¡è°ƒç”¨**
   - é¿å… `CALLVALUE` å’Œç›¸å…³çš„æ£€æŸ¥æ“ä½œç 
   - å‡å°‘éƒ¨ç½²æ—¶çš„åˆçº¦å­—èŠ‚ç å¤§å°

2. **é«˜é¢‘è°ƒç”¨åœºæ™¯ä¸‹ç´¯ç§¯æ•ˆæœæ˜¾è‘—**
   - DeFi åè®®ä¸­çš„äº¤æ˜“å‡½æ•°
   - æ¸¸æˆåˆçº¦ä¸­çš„çŠ¶æ€æ›´æ–°
   - æ‰¹é‡æ“ä½œå‡½æ•°

3. **éƒ¨ç½²æˆæœ¬ä¼˜åŒ–**
   - æ›´å°çš„åˆçº¦å­—èŠ‚ç 
   - æ›´ä½çš„åˆçº¦åˆ›å»ºæˆæœ¬

### âš ï¸ **æ³¨æ„äº‹é¡¹ï¼š**

1. **å®‰å…¨é£é™©**
   - ç”¨æˆ·å¯èƒ½æ„å¤–å‘é€ ETH
   - éœ€è¦é¢å¤–çš„æ£€æŸ¥æ¥å¤„ç†æ„å¤– ETH

2. **ä»£ç å¯è¯»æ€§**
   - å‡½æ•°æ„å›¾å¯èƒ½ä¸å¤Ÿæ˜ç¡®
   - éœ€è¦è‰¯å¥½çš„æ–‡æ¡£è¯´æ˜

3. **é€‚ç”¨åœºæ™¯**
   - é€‚åˆï¼šé«˜é¢‘è°ƒç”¨ã€ç¡®å®éœ€è¦ ETHã€å†…éƒ¨å‡½æ•°
   - ä¸é€‚åˆï¼šç®¡ç†å‡½æ•°ã€è§†å›¾å‡½æ•°ã€å¯èƒ½è¯¯æ“ä½œçš„å‡½æ•°

### ğŸ¯ **æ¨èå®è·µï¼š**

```solidity
// å¥½çš„å®è·µ
function highFrequencyOperation() external payable {
    if (msg.value > 0) {
        // æ˜ç¡®å¤„ç†å‘é€çš„ ETH
        _handleIncomingETH();
    }
    // ä¸šåŠ¡é€»è¾‘
}

// æ˜ç¡®ä¸æ¥å— ETH çš„ payable å‡½æ•°
function noETHFunction() external payable {
    require(msg.value == 0, "ETH not accepted");
    // ä¸šåŠ¡é€»è¾‘
}
```

**ç»“è®ºï¼š** åœ¨ä¸éœ€è¦æ¥æ”¶ ETH çš„é«˜é¢‘è°ƒç”¨å‡½æ•°ä¸­ä½¿ç”¨ `payable` å¯ä»¥èŠ‚çœå°‘é‡ä½†å¯ç´¯ç§¯çš„ Gasï¼Œä½†éœ€è¦æƒè¡¡å®‰å…¨æ€§å’Œä»£ç æ¸…æ™°åº¦ã€‚åœ¨ç¡®å®éœ€è¦æ¥æ”¶ ETH çš„å‡½æ•°ä¸­ï¼Œ`payable` æ˜¯å¿…é¡»çš„ï¼Œå¹¶ä¸” Gas èŠ‚çœæ˜¯é¢å¤–çš„ä¼˜åŠ¿ã€‚
