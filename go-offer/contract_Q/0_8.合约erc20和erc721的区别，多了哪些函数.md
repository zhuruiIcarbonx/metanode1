好的，我们来详细对比ERC20和ERC721，这是以太坊上最重要的两个代币标准。

## 核心概念区别

| 特性 | ERC20 (同质化代币) | ERC721 (非同质化代币/NFT) |
| :--- | :--- | :--- |
| **代币性质** | 可互换的，每个代币完全相同 | 唯一的，每个代币都不同 |
| **代表物** | 货币、股份、积分等 | 收藏品、艺术品、游戏资产等 |
| **单位** | 可分割 (如 1.5 ETH) | 不可分割 (只有 1个) |
| **核心映射** | `balanceOf(owner)` | `ownerOf(tokenId)` |

---

## 函数对比

### ERC20 核心函数

```solidity
// 基础信息
function totalSupply() external view returns (uint256);
function balanceOf(address account) external view returns (uint256);

// 转账
function transfer(address to, uint256 amount) external returns (bool);
function transferFrom(address from, address to, uint256 amount) external returns (bool);

// 授权
function approve(address spender, uint256 amount) external returns (bool);
function allowance(address owner, address spender) external view returns (uint256);
```

### ERC721 新增的核心函数

```solidity
// NFT特有函数
function ownerOf(uint256 tokenId) external view returns (address);
function safeTransferFrom(address from, address to, uint256 tokenId) external;
function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;

// 授权扩展
function getApproved(uint256 tokenId) external view returns (address);
function setApprovalForAll(address operator, bool approved) external;
function isApprovedForAll(address owner, address operator) external view returns (bool);
```

---

## ERC721 特有的重要函数详解

### 1. `ownerOf(uint256 tokenId)`
```solidity
function ownerOf(uint256 tokenId) external view returns (address);
```
- **作用**：查询特定tokenId的所有者
- **为什么需要**：ERC721中每个代币都是唯一的，需要单独追踪所有权

```solidity
// 使用示例
address nftOwner = myNFT.ownerOf(123);
// 返回tokenId为123的NFT当前所有者地址
```

### 2. `safeTransferFrom` (重载函数)
```solidity
// 两个版本
function safeTransferFrom(address from, address to, uint256 tokenId) external;
function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;
```
- **作用**：安全地转移NFT所有权
- **安全特性**：如果接收方是合约，会检查其是否能处理ERC721代币

```solidity
// 使用示例
myNFT.safeTransferFrom(msg.sender, receiver, tokenId);
// 或者带数据
myNFT.safeTransferFrom(msg.sender, receiver, tokenId, "additional data");
```

### 3. 增强的授权系统

#### `setApprovalForAll` 和 `isApprovedForAll`
```solidity
function setApprovalForAll(address operator, bool approved) external;
function isApprovedForAll(address owner, address operator) external view returns (bool);
```
- **作用**：一次性授权某个地址管理你所有的NFT
- **使用场景**：NFT交易市场需要批量上架你的NFT

```solidity
// 授权OpenSea管理我所有的NFT
myNFT.setApprovalForAll(0x1E0049783F008A0085193E00003D00cd54003c71, true);

// 检查是否已授权
bool isApproved = myNFT.isApprovedForAll(myAddress, openSeaAddress);
```

#### `getApproved(uint256 tokenId)`
```solidity
function getApproved(uint256 tokenId) external view returns (address);
```
- **作用**：查询特定tokenId的授权地址
- **区别**：ERC20是额度授权，ERC721是具体代币授权

```solidity
// 检查tokenId 123被授权给了谁
address approvedAddress = myNFT.getApproved(123);
```

---

## 元数据扩展 (ERC721Metadata)

大多数ERC721实现还包含元数据扩展：

```solidity
// 可选但常见的元数据函数
function name() external view returns (string memory);
function symbol() external view returns (string memory);
function tokenURI(uint256 tokenId) external view returns (string memory);
```

**tokenURI** 是NFT的核心：
```solidity
// 返回指向元数据JSON的URL
string memory uri = myNFT.tokenURI(123);
// 可能返回: "https://api.mynft.com/tokens/123"
```

---

## 完整代码对比

### ERC20 最小实现
```solidity
contract MyToken is IERC20 {
    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;
    
    uint256 private _totalSupply;
    string private _name;
    string private _symbol;
    
    function transfer(address to, uint256 amount) public override returns (bool) {
        _balances[msg.sender] -= amount;
        _balances[to] += amount;
        emit Transfer(msg.sender, to, amount);
        return true;
    }
    
    function approve(address spender, uint256 amount) public override returns (bool) {
        _allowances[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }
    
    // ... 其他函数实现
}
```

### ERC721 最小实现
```solidity
contract MyNFT is IERC721 {
    mapping(uint256 => address) private _owners;
    mapping(address => uint256) private _balances;
    mapping(uint256 => address) private _tokenApprovals;
    mapping(address => mapping(address => bool)) private _operatorApprovals;
    
    function ownerOf(uint256 tokenId) public view override returns (address) {
        address owner = _owners[tokenId];
        require(owner != address(0), "Token does not exist");
        return owner;
    }
    
    function transferFrom(address from, address to, uint256 tokenId) public override {
        require(_isApprovedOrOwner(msg.sender, tokenId), "Not approved");
        _transfer(from, to, tokenId);
    }
    
    function safeTransferFrom(address from, address to, uint256 tokenId) public override {
        safeTransferFrom(from, to, tokenId, "");
    }
    
    function approve(address to, uint256 tokenId) public override {
        address owner = ownerOf(tokenId);
        require(to != owner, "Approval to current owner");
        require(msg.sender == owner || isApprovedForAll(owner, msg.sender), "Not authorized");
        _tokenApprovals[tokenId] = to;
        emit Approval(owner, to, tokenId);
    }
    
    function setApprovalForAll(address operator, bool approved) public override {
        _operatorApprovals[msg.sender][operator] = approved;
        emit ApprovalForAll(msg.sender, operator, approved);
    }
    
    // ... 其他函数实现
}
```

---

## 使用场景对比

### ERC20 使用示例
```solidity
// 创建代币
IERC20 token = IERC20(0xTokenAddress);

// 检查余额
uint256 myBalance = token.balanceOf(msg.sender);

// 转账
token.transfer(receiver, 1000);

// 授权DEX使用我的代币
token.approve(uniswapRouter, 500);
```

### ERC721 使用示例
```solidity
// NFT合约
IERC721 nft = IERC721(0xNFTAddress);

// 检查NFT所有者
address nftOwner = nft.ownerOf(123);

// 转移特定NFT
nft.safeTransferFrom(msg.sender, friend, 123);

// 授权市场管理我所有的NFT
nft.setApprovalForAll(opensea, true);

// 检查特定NFT的授权
address approved = nft.getApproved(123);
```

---

## 重要注意事项

### 1. 安全考虑
- **ERC721的`safeTransferFrom`**：应该优先使用，防止NFT丢失到不能处理它的合约中
- **授权风险**：`setApprovalForAll`给了操作者很大权限，要谨慎授权

### 2. Gas成本
- ERC721操作通常更昂贵，因为涉及唯一的tokenId追踪
- 批量操作需要额外设计（如ERC721Enumerable扩展）

### 3. 可枚举性
基础ERC721不提供遍历功能，需要扩展：
```solidity
// ERC721Enumerable 扩展
function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);
function totalSupply() external view returns (uint256);
function tokenByIndex(uint256 index) external view returns (uint256);
```

### 4. 元数据标准
ERC721通常配合ERC721Metadata实现，提供：
- `name()`：集合名称
- `symbol()`：代币符号  
- `tokenURI(tokenId)`：指向元数据的链接

## 总结

**ERC721相比ERC20主要增加了：**
1. **唯一性追踪**：`ownerOf(tokenId)`
2. **安全转账**：`safeTransferFrom`系列函数
3. **增强授权**：单个代币授权 + 全局操作员授权
4. **元数据支持**：`tokenURI`等元数据函数

理解这些区别有助于你根据具体需求选择合适的代币标准：
- **需要货币、积分等可互换资产** → ERC20
- **需要唯一性资产如艺术品、游戏物品** → ERC721
