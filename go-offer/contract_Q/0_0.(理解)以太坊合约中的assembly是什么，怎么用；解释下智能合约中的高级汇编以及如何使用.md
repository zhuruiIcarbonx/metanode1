# 以太坊合约中的 Assembly 和 Yul 高级汇编

## 1. Assembly 基础概念

### 1.1 什么是内联汇编
```solidity
contract BasicAssembly {
    function simpleAssembly(uint x, uint y) public pure returns (uint) {
        uint result;
        
        assembly {
            // 内联汇编代码块
            result := add(x, y)  // 使用EVM操作码直接相加
        }
        
        return result;
    }
}
```

## 2. Yul - 以太坊的高级汇编语言

### 2.1 Yul 基本语法
```solidity
contract YulIntroduction {
    function yulExample(uint a, uint b) public pure returns (uint sum, uint product) {
        assembly {
            // Yul 使用更高级的语法
            sum := add(a, b)
            product := mul(a, b)
        }
    }
}
```

## 3. Assembly 核心操作

### 3.1 内存操作
```solidity
contract MemoryOperations {
    function memoryManipulation() public pure returns (bytes32) {
        bytes32 result;
        
        assembly {
            // 内存分配和操作
            let freeMemoryPointer := mload(0x40)  // 获取空闲内存指针
            
            // 在内存中存储数据
            mstore(freeMemoryPointer, 0x1234567890ABCDEF)
            mstore(add(freeMemoryPointer, 32), 0xFFFFFFFFFFFFFFFF)
            
            // 从内存加载数据
            result := mload(freeMemoryPointer)
            
            // 更新空闲内存指针
            mstore(0x40, add(freeMemoryPointer, 64))
        }
        
        return result;
    }
}
```

### 3.2 存储操作
```solidity
contract StorageOperations {
    uint256 public storedData;
    
    function storageAccess(uint256 newValue) public returns (uint256 oldValue) {
        assembly {
            // 获取存储槽位置
            let slot := storedData.slot
            
            // 读取当前值
            oldValue := sload(slot)
            
            // 写入新值
            sstore(slot, newValue)
        }
    }
    
    // 复杂存储布局
    struct ComplexData {
        uint256 a;
        uint256 b;
    }
    mapping(uint256 => ComplexData) public dataMap;
    
    function updateMapping(uint256 key, uint256 a, uint256 b) public {
        assembly {
            // 计算映射项的存储位置
            mstore(0, key)
            mstore(32, dataMap.slot)
            let dataSlot := keccak256(0, 64)
            
            // 存储结构体成员
            sstore(dataSlot, a)           // dataMap[key].a
            sstore(add(dataSlot, 1), b)   // dataMap[key].b
        }
    }
}
```

### 3.3 Calldata 操作
```solidity
contract CalldataOperations {
    function decodeCalldata() public pure returns (uint256, address) {
        uint256 value;
        address addr;
        
        assembly {
            // 跳过函数选择器（4字节）
            value := calldataload(4)          // 第一个参数（uint256）
            addr := calldataload(36)          // 第二个参数（address）
        }
        
        return (value, addr);
    }
    
    function dynamicArrayDecode(uint256[] calldata arr) public pure returns (uint256) {
        uint256 sum;
        
        assembly {
            let offset := arr.offset
            let length := calldataload(offset)
            
            // 遍历动态数组
            for { let i := 0 } lt(i, length) { i := add(i, 1) } {
                let element := calldataload(add(offset, add(32, mul(i, 32))))
                sum := add(sum, element)
            }
        }
        
        return sum;
    }
}
```

## 4. 高级 Yul 特性

### 4.1 函数定义和调用
```solidity
contract YulFunctions {
    function complexCalculation(uint256 a, uint256 b) public pure returns (uint256) {
        uint256 result;
        
        assembly {
            function power(base, exponent) -> result {
                result := 1
                for { let i := 0 } lt(i, exponent) { i := add(i, 1) } {
                    result := mul(result, base)
                }
            }
            
            function factorial(n) -> result {
                result := 1
                for { let i := 2 } lt(i, add(n, 1)) { i := add(i, 1) } {
                    result := mul(result, i)
                }
            }
            
            let pow := power(a, b)
            let fact := factorial(b)
            result := add(pow, fact)
        }
        
        return result;
    }
}
```

### 4.2 控制结构
```solidity
contract ControlStructures {
    function findMax(uint256[] memory arr) public pure returns (uint256 max) {
        assembly {
            let length := mload(arr)
            if eq(length, 0) {
                max := 0
                leave  // 相当于 return
            }
            
            max := mload(add(arr, 32))  // 第一个元素
            
            for { let i := 1 } lt(i, length) { i := add(i, 1) } {
                let current := mload(add(arr, mul(add(i, 1), 32)))
                if gt(current, max) {
                    max := current
                }
            }
        }
    }
    
    function switchExample(uint256 x) public pure returns (uint256) {
        uint256 result;
        
        assembly {
            switch x
            case 0 {
                result := 100
            }
            case 1 {
                result := 200
            }
            default {
                result := 300
            }
        }
        
        return result;
    }
}
```

## 5. 实际应用场景

### 5.1 Gas 优化 - 批量操作
```solidity
contract GasOptimizedBatch {
    address[] public users;
    mapping(address => uint256) public balances;
    
    function batchTransfer(address[] calldata recipients, uint256[] calldata amounts) 
        external 
    {
        require(recipients.length == amounts.length, "Length mismatch");
        
        assembly {
            let recipientsOffset := recipients.offset
            let amountsOffset := amounts.offset
            let length := calldataload(recipientsOffset)
            
            // 预计算存储槽
            mstore(0, caller())
            mstore(32, balances.slot)
            let senderBalanceSlot := keccak256(0, 64)
            let senderBalance := sload(senderBalanceSlot)
            
            let totalAmount := 0
            
            // 计算总金额并验证
            for { let i := 0 } lt(i, length) { i := add(i, 1) } {
                let amount := calldataload(add(amountsOffset, add(32, mul(i, 32))))
                totalAmount := add(totalAmount, amount)
            }
            
            // 检查余额
            if gt(totalAmount, senderBalance) {
                revert(0, 0)
            }
            
            // 执行批量转账
            for { let i := 0 } lt(i, length) { i := add(i, 1) } {
                let recipient := calldataload(add(recipientsOffset, add(32, mul(i, 32))))
                let amount := calldataload(add(amountsOffset, add(32, mul(i, 32))))
                
                // 更新接收方余额
                mstore(0, recipient)
                mstore(32, balances.slot)
                let recipientBalanceSlot := keccak256(0, 64)
                let recipientBalance := sload(recipientBalanceSlot)
                sstore(recipientBalanceSlot, add(recipientBalance, amount))
            }
            
            // 更新发送方余额
            sstore(senderBalanceSlot, sub(senderBalance, totalAmount))
        }
    }
}
```

### 5.2 自定义错误处理
```solidity
contract CustomErrors {
    error InsufficientBalance(uint256 available, uint256 required);
    error UnauthorizedAccess(address caller);
    
    function optimizedRevert(uint256 amount) public view {
        assembly {
            // 自定义错误选择器
            let availableBalance := sload(0) // 假设余额在slot 0
            if gt(amount, availableBalance) {
                mstore(0, 0x9f6f7d0b00000000000000000000000000000000000000000000000000000000) // 错误选择器
                mstore(4, availableBalance)
                mstore(36, amount)
                revert(0, 68)
            }
        }
    }
}
```

### 5.3 高效哈希计算
```solidity
contract EfficientHashing {
    function computeHash(bytes memory data1, bytes memory data2) 
        public 
        pure 
        returns (bytes32 hash) 
    {
        assembly {
            // 在内存中拼接数据并计算哈希
            let freeMem := mload(0x40)
            
            // 复制第一个数据段
            let length1 := mload(data1)
            mstore(freeMem, length1)
            calldatacopy(add(freeMem, 32), add(data1, 32), length1)
            
            // 复制第二个数据段
            let offset2 := add(freeMem, add(32, length1))
            let length2 := mload(data2)
            mstore(offset2, length2)
            calldatacopy(add(offset2, 32), add(data2, 32), length2)
            
            // 计算哈希
            let totalLength := add(add(32, length1), add(32, length2))
            hash := keccak256(freeMem, totalLength)
            
            // 更新空闲内存指针
            mstore(0x40, add(freeMem, totalLength))
        }
    }
}
```

## 6. 高级内存管理

### 6.1 内存布局管理
```solidity
contract MemoryLayout {
    function complexMemoryOperation() public pure returns (bytes32) {
        bytes32 result;
        
        assembly {
            // 获取当前内存指针
            let memPtr := mload(0x40)
            
            // 预留内存区域
            let arrayPtr := memPtr
            let stringPtr := add(arrayPtr, 128)  // 为数组预留128字节
            let structPtr := add(stringPtr, 64)  // 为字符串预留64字节
            
            // 初始化数组数据
            for { let i := 0 } lt(i, 4) { i := add(i, 1) } {
                mstore(add(arrayPtr, mul(i, 32)), mul(i, 10))
            }
            
            // 存储字符串数据
            mstore(stringPtr, 0x20)  // 字符串长度位置
            mstore(add(stringPtr, 32), 0x48656C6C6F20576F726C64000000000000000000000000000000000000000000) // "Hello World"
            
            // 计算整体哈希
            result := keccak256(arrayPtr, 128)
            
            // 正确更新内存指针
            mstore(0x40, add(structPtr, 64))
        }
        
        return result;
    }
}
```

## 7. 安全注意事项

### 7.1 安全的 Assembly 编程
```solidity
contract SafeAssembly {
    // 不安全的写法
    function unsafeWrite(uint256 slot, uint256 value) public {
        assembly {
            sstore(slot, value)  // 可能写入任意存储位置
        }
    }
    
    // 安全的写法
    function safeWrite(uint256 value) public {
        uint256 privateSlot;
        
        assembly {
            // 只允许写入预定义的存储槽
            let allowedSlot := privateSlot.slot
            sstore(allowedSlot, value)
        }
    }
    
    // 边界检查
    function safeArrayAccess(uint256[] memory arr, uint256 index) 
        public 
        pure 
        returns (uint256) 
    {
        uint256 element;
        
        assembly {
            let length := mload(arr)
            
            // 严格的边界检查
            if or(iszero(length), gt(index, sub(length, 1))) {
                revert(0, 0)
            }
            
            element := mload(add(arr, mul(add(index, 1), 32)))
        }
        
        return element;
    }
}
```

## 8. 调试和测试

### 8.1 Assembly 调试技巧
```solidity
contract DebugAssembly {
    event DebugLog(bytes32 value, string message);
    
    function debugAssembly(uint256 input) public returns (uint256) {
        uint256 result;
        
        assembly {
            // 使用日志调试
            let temp := mul(input, 2)
            
            // 在内存中准备调试信息
            mstore(0, temp)
            log1(0, 32, 0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef)
            
            result := add(temp, 1)
        }
        
        // 使用事件调试
        emit DebugLog(bytes32(result), "Assembly result");
        
        return result;
    }
}
```

## 总结

### 使用 Assembly/Yul 的最佳场景：
1. **Gas 优化** - 关键路径的性能优化
2. **复杂计算** - 需要精细控制EVM操作时
3. **低级操作** - 直接内存/存储操作
4. **协议开发** - 需要极致性能的DeFi协议

### 重要注意事项：
- **安全第一** - Assembly 绕过了 Solidity 的安全检查
- **充分测试** - 必须进行全面的单元测试和模糊测试
- **文档完善** - 复杂的 Assembly 代码需要详细注释
- **渐进采用** - 先在非关键功能中试用，再逐步应用到核心逻辑

Assembly 和 Yul 是以太坊开发的强大工具，但需要谨慎使用。它们提供了对EVM的底层访问能力，可以在关键代码路径上实现显著的Gas优化，但也带来了更高的复杂性和安全风险。
