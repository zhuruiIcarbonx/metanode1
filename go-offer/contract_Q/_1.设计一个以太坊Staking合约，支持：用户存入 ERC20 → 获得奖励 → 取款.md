# 以太坊 Staking 合约设计

## 1. 完整的 Staking 合约实现

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/access/AccessControl.sol";
import "@openzeppelin/contracts/security/Pausable.sol";

/**
 * @title 高级 Staking 合约
 * @dev 支持 ERC20 代币质押、奖励计算、灵活取款
 */
contract AdvancedStaking is ReentrancyGuard, AccessControl, Pausable {
    using SafeERC20 for IERC20;
    
    // 角色定义
    bytes32 public constant ADMIN_ROLE = keccak256("ADMIN_ROLE");
    bytes32 public constant REWARD_MANAGER_ROLE = keccak256("REWARD_MANAGER_ROLE");
    
    // 代币接口
    IERC20 public immutable stakingToken;
    IERC20 public immutable rewardToken;
    
    // 质押数据结构
    struct StakeInfo {
        uint256 amount;             // 质押数量
        uint256 stakeTime;          // 质押时间
        uint256 lastRewardClaimTime; // 最后领取奖励时间
        uint256 pendingRewards;     // 待领取奖励
        uint256 rewardDebt;         // 奖励债务（用于精确计算）
    }
    
    // 用户质押信息映射
    mapping(address => StakeInfo) public userStakes;
    
    // 合约状态变量
    uint256 public totalStaked;                    // 总质押量
    uint256 public totalRewardsDistributed;        // 总分发奖励
    uint256 public rewardRate;                     // 每秒奖励率
    uint256 public lastUpdateTime;                 // 最后更新时间
    uint256 public rewardPerTokenStored;           // 每 token 累计奖励
    uint256 public constant REWARD_DURATION = 30 days; // 奖励周期
    
    // 事件定义
    event Staked(address indexed user, uint256 amount);
    event Withdrawn(address indexed user, uint256 amount);
    event RewardPaid(address indexed user, uint256 reward);
    event RewardRateUpdated(uint256 newRate);
    event EmergencyWithdraw(address indexed user, uint256 amount);
    
    // 错误定义
    error ZeroAmount();
    error InsufficientBalance();
    error NoStakeFound();
    error RewardRateTooHigh();
    
    /**
     * @dev 构造函数
     * @param _stakingToken 质押代币地址
     * @param _rewardToken 奖励代币地址
     * @param _admin 管理员地址
     */
    constructor(
        address _stakingToken,
        address _rewardToken,
        address _admin
    ) {
        if (_stakingToken == address(0) || _rewardToken == address(0)) {
            revert("Invalid token address");
        }
        
        stakingToken = IERC20(_stakingToken);
        rewardToken = IERC20(_rewardToken);
        
        _grantRole(DEFAULT_ADMIN_ROLE, _admin);
        _grantRole(ADMIN_ROLE, _admin);
        _grantRole(REWARD_MANAGER_ROLE, _admin);
        
        lastUpdateTime = block.timestamp;
    }
    
    /**
     * @dev 更新奖励计算
     */
    modifier updateReward(address account) {
        rewardPerTokenStored = rewardPerToken();
        lastUpdateTime = lastTimeRewardApplicable();
        
        if (account != address(0)) {
            userStakes[account].pendingRewards = earned(account);
            userStakes[account].lastRewardClaimTime = block.timestamp;
            userStakes[account].rewardDebt = userStakes[account].amount * rewardPerTokenStored / 1e18;
        }
        _;
    }
    
    /**
     * @dev 质押代币
     * @param amount 质押数量
     */
    function stake(uint256 amount) 
        external 
        nonReentrant 
        whenNotPaused 
        updateReward(msg.sender) 
    {
        if (amount == 0) revert ZeroAmount();
        
        // 检查用户余额
        if (stakingToken.balanceOf(msg.sender) < amount) {
            revert InsufficientBalance();
        }
        
        StakeInfo storage userStake = userStakes[msg.sender];
        
        // 如果是首次质押，初始化质押时间
        if (userStake.amount == 0) {
            userStake.stakeTime = block.timestamp;
        }
        
        // 更新用户质押信息
        userStake.amount += amount;
        totalStaked += amount;
        
        // 转移代币
        stakingToken.safeTransferFrom(msg.sender, address(this), amount);
        
        emit Staked(msg.sender, amount);
    }
    
    /**
     * @dev 取回质押的代币
     * @param amount 取回数量
     */
    function withdraw(uint256 amount) 
        external 
        nonReentrant 
        updateReward(msg.sender) 
    {
        if (amount == 0) revert ZeroAmount();
        
        StakeInfo storage userStake = userStakes[msg.sender];
        
        if (userStake.amount < amount) {
            revert InsufficientBalance();
        }
        
        // 更新用户质押信息
        userStake.amount -= amount;
        totalStaked -= amount;
        
        // 如果全部取回，重置质押时间
        if (userStake.amount == 0) {
            userStake.stakeTime = 0;
        }
        
        // 转移代币
        stakingToken.safeTransfer(msg.sender, amount);
        
        emit Withdrawn(msg.sender, amount);
    }
    
    /**
     * @dev 领取奖励
     */
    function getReward() 
        external 
        nonReentrant 
        updateReward(msg.sender) 
    {
        uint256 reward = userStakes[msg.sender].pendingRewards;
        if (reward == 0) revert NoStakeFound();
        
        // 重置待领取奖励
        userStakes[msg.sender].pendingRewards = 0;
        totalRewardsDistributed += reward;
        
        // 检查合约奖励代币余额
        uint256 contractBalance = rewardToken.balanceOf(address(this));
        if (reward > contractBalance) {
            reward = contractBalance; // 如果余额不足，只支付可用部分
        }
        
        if (reward > 0) {
            rewardToken.safeTransfer(msg.sender, reward);
            emit RewardPaid(msg.sender, reward);
        }
    }
    
    /**
     * @dev 取回所有质押并领取奖励
     */
    function exit() external nonReentrant updateReward(msg.sender) {
        StakeInfo storage userStake = userStakes[msg.sender];
        uint256 amount = userStake.amount;
        
        if (amount == 0) revert NoStakeFound();
        
        // 领取奖励
        uint256 reward = userStake.pendingRewards;
        if (reward > 0) {
            userStake.pendingRewards = 0;
            totalRewardsDistributed += reward;
            
            uint256 contractBalance = rewardToken.balanceOf(address(this));
            if (reward > contractBalance) {
                reward = contractBalance;
            }
            
            if (reward > 0) {
                rewardToken.safeTransfer(msg.sender, reward);
                emit RewardPaid(msg.sender, reward);
            }
        }
        
        // 取回质押
        userStake.amount = 0;
        totalStaked -= amount;
        userStake.stakeTime = 0;
        
        stakingToken.safeTransfer(msg.sender, amount);
        emit Withdrawn(msg.sender, amount);
    }
    
    /**
     * @dev 紧急取回（不领取奖励）
     */
    function emergencyWithdraw() external nonReentrant whenPaused {
        StakeInfo storage userStake = userStakes[msg.sender];
        uint256 amount = userStake.amount;
        
        if (amount == 0) revert NoStakeFound();
        
        // 重置用户质押信息
        userStake.amount = 0;
        userStake.pendingRewards = 0;
        userStake.stakeTime = 0;
        totalStaked -= amount;
        
        stakingToken.safeTransfer(msg.sender, amount);
        emit EmergencyWithdraw(msg.sender, amount);
    }
    
    // ========== 视图函数 ==========
    
    /**
     * @dev 计算用户应得奖励
     * @param account 用户地址
     */
    function earned(address account) public view returns (uint256) {
        StakeInfo memory userStake = userStakes[account];
        uint256 currentRewardPerToken = rewardPerToken();
        uint256 pending = userStake.amount * (currentRewardPerToken - userStake.rewardDebt) / 1e18;
        return userStake.pendingRewards + pending;
    }
    
    /**
     * @dev 计算每 token 累计奖励
     */
    function rewardPerToken() public view returns (uint256) {
        if (totalStaked == 0) {
            return rewardPerTokenStored;
        }
        
        return rewardPerTokenStored + (
            (lastTimeRewardApplicable() - lastUpdateTime) * rewardRate * 1e18 / totalStaked
        );
    }
    
    /**
     * @dev 获取最后可计算奖励的时间
     */
    function lastTimeRewardApplicable() public view returns (uint256) {
        return block.timestamp;
    }
    
    /**
     * @dev 获取用户总信息
     * @param user 用户地址
     */
    function getUserInfo(address user) external view returns (
        uint256 stakedAmount,
        uint256 pendingReward,
        uint256 stakeTime,
        uint256 lastClaimTime
    ) {
        StakeInfo memory userStake = userStakes[user];
        return (
            userStake.amount,
            earned(user),
            userStake.stakeTime,
            userStake.lastRewardClaimTime
        );
    }
    
    /**
     * @dev 获取合约统计信息
     */
    function getContractInfo() external view returns (
        uint256 totalStakedTokens,
        uint256 currentRewardRate,
        uint256 totalRewardsPaid,
        uint256 stakingTokenBalance,
        uint256 rewardTokenBalance
    ) {
        return (
            totalStaked,
            rewardRate,
            totalRewardsDistributed,
            stakingToken.balanceOf(address(this)),
            rewardToken.balanceOf(address(this))
        );
    }
    
    // ========== 管理函数 ==========
    
    /**
     * @dev 设置奖励率
     * @param _rewardRate 新的奖励率（每秒奖励数量）
     */
    function setRewardRate(uint256 _rewardRate) 
        external 
        onlyRole(REWARD_MANAGER_ROLE) 
        updateReward(address(0)) 
    {
        // 安全检查：奖励率不能过高
        if (_rewardRate > 1e18) {
            revert RewardRateTooHigh();
        }
        
        rewardRate = _rewardRate;
        emit RewardRateUpdated(_rewardRate);
    }
    
    /**
     * @dev 添加奖励代币到合约
     * @param amount 奖励代币数量
     */
    function addRewards(uint256 amount) external onlyRole(REWARD_MANAGER_ROLE) {
        if (amount == 0) revert ZeroAmount();
        
        rewardToken.safeTransferFrom(msg.sender, address(this), amount);
    }
    
    /**
     * @dev 紧急情况下提取误转的代币
     * @param token 代币地址
     * @param amount 提取数量
     */
    function recoverERC20(address token, uint256 amount) 
        external 
        onlyRole(ADMIN_ROLE) 
    {
        if (token == address(stakingToken)) {
            uint256 balance = stakingToken.balanceOf(address(this));
            require(balance - amount >= totalStaked, "Cannot recover staked tokens");
        }
        
        IERC20(token).safeTransfer(msg.sender, amount);
    }
    
    /**
     * @dev 暂停合约
     */
    function pause() external onlyRole(ADMIN_ROLE) {
        _pause();
    }
    
    /**
     * @dev 恢复合约
     */
    function unpause() external onlyRole(ADMIN_ROLE) {
        _unpause();
    }
}
```

## 2. 带时间锁的 Staking 合约

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "./AdvancedStaking.sol";

/**
 * @title 带时间锁的 Staking 合约
 * @dev 支持不同锁定期限，期限越长奖励倍数越高
 */
contract TimelockStaking is AdvancedStaking {
    // 锁定期选项
    enum LockPeriod {
        THIRTY_DAYS,
        NINETY_DAYS,
        ONE_EIGHTY_DAYS,
        THREE_SIXTY_DAYS
    }
    
    // 奖励倍数配置
    mapping(LockPeriod => uint256) public rewardMultipliers;
    
    // 用户锁定期信息
    struct TimelockStake {
        uint256 amount;
        uint256 unlockTime;
        LockPeriod lockPeriod;
        uint256 multiplier;
    }
    
    mapping(address => TimelockStake[]) public userTimelockStakes;
    
    event TimelockStaked(
        address indexed user, 
        uint256 amount, 
        LockPeriod lockPeriod,
        uint256 unlockTime
    );
    event TimelockWithdrawn(address indexed user, uint256 amount);
    
    /**
     * @dev 构造函数
     */
    constructor(
        address _stakingToken,
        address _rewardToken,
        address _admin
    ) AdvancedStaking(_stakingToken, _rewardToken, _admin) {
        // 设置奖励倍数
        rewardMultipliers[LockPeriod.THIRTY_DAYS] = 100;      // 1x
        rewardMultipliers[LockPeriod.NINETY_DAYS] = 125;      // 1.25x
        rewardMultipliers[LockPeriod.ONE_EIGHTY_DAYS] = 150;  // 1.5x
        rewardMultipliers[LockPeriod.THREE_SIXTY_DAYS] = 200; // 2x
    }
    
    /**
     * @dev 带锁定期质押
     * @param amount 质押数量
     * @param lockPeriod 锁定期
     */
    function stakeWithLock(uint256 amount, LockPeriod lockPeriod) 
        external 
        nonReentrant 
        whenNotPaused 
    {
        if (amount == 0) revert ZeroAmount();
        
        // 计算解锁时间
        uint256 unlockTime = block.timestamp + getLockDuration(lockPeriod);
        uint256 multiplier = rewardMultipliers[lockPeriod];
        
        // 创建时间锁质押记录
        userTimelockStakes[msg.sender].push(TimelockStake({
            amount: amount,
            unlockTime: unlockTime,
            lockPeriod: lockPeriod,
            multiplier: multiplier
        }));
        
        // 更新总质押量
        totalStaked += amount;
        
        // 转移代币
        stakingToken.safeTransferFrom(msg.sender, address(this), amount);
        
        emit TimelockStaked(msg.sender, amount, lockPeriod, unlockTime);
    }
    
    /**
     * @dev 取回时间锁质押
     * @param stakeIndex 质押记录索引
     */
    function withdrawTimelock(uint256 stakeIndex) external nonReentrant {
        TimelockStake[] storage stakes = userTimelockStakes[msg.sender];
        require(stakeIndex < stakes.length, "Invalid stake index");
        
        TimelockStake memory stake = stakes[stakeIndex];
        require(block.timestamp >= stake.unlockTime, "Stake still locked");
        
        // 移除质押记录
        stakes[stakeIndex] = stakes[stakes.length - 1];
        stakes.pop();
        
        // 更新总质押量
        totalStaked -= stake.amount;
        
        // 转移代币
        stakingToken.safeTransfer(msg.sender, stake.amount);
        
        emit TimelockWithdrawn(msg.sender, stake.amount);
    }
    
    /**
     * @dev 获取锁定期持续时间
     * @param lockPeriod 锁定期类型
     */
    function getLockDuration(LockPeriod lockPeriod) public pure returns (uint256) {
        if (lockPeriod == LockPeriod.THIRTY_DAYS) return 30 days;
        if (lockPeriod == LockPeriod.NINETY_DAYS) return 90 days;
        if (lockPeriod == LockPeriod.ONE_EIGHTY_DAYS) return 180 days;
        if (lockPeriod == LockPeriod.THREE_SIXTY_DAYS) return 360 days;
        return 0;
    }
    
    /**
     * @dev 获取用户时间锁质押信息
     * @param user 用户地址
     */
    function getUserTimelockStakes(address user) 
        external 
        view 
        returns (TimelockStake[] memory) 
    {
        return userTimelockStakes[user];
    }
    
    /**
     * @dev 计算带倍数的奖励
     * @param user 用户地址
     */
    function getEnhancedRewards(address user) external view returns (uint256 totalEnhancedReward) {
        TimelockStake[] memory stakes = userTimelockStakes[user];
        uint256 baseReward = earned(user);
        
        // 计算基础奖励
        totalEnhancedReward = baseReward;
        
        // 为每个时间锁质押添加额外奖励
        for (uint256 i = 0; i < stakes.length; i++) {
            uint256 extraReward = (baseReward * (stakes[i].multiplier - 100)) / 100;
            totalEnhancedReward += extraReward;
        }
        
        return totalEnhancedReward;
    }
}
```

## 3. 部署和测试脚本

```javascript
// deploy.js
const { ethers } = require("hardhat");

async function main() {
    const [deployer] = await ethers.getSigners();
    
    console.log("Deploying contracts with account:", deployer.address);
    console.log("Account balance:", (await deployer.getBalance()).toString());

    // 部署 Staking 合约
    const StakingToken = await ethers.getContractFactory("ERC20Mock");
    const stakingToken = await StakingToken.deploy("Staking Token", "STK", deployer.address, ethers.utils.parseEther("1000000"));
    await stakingToken.deployed();
    console.log("Staking Token deployed to:", stakingToken.address);

    const RewardToken = await ethers.getContractFactory("ERC20Mock");
    const rewardToken = await RewardToken.deploy("Reward Token", "RWD", deployer.address, ethers.utils.parseEther("1000000"));
    await rewardToken.deployed();
    console.log("Reward Token deployed to:", rewardToken.address);

    const AdvancedStaking = await ethers.getContractFactory("AdvancedStaking");
    const staking = await AdvancedStaking.deploy(
        stakingToken.address,
        rewardToken.address,
        deployer.address
    );
    await staking.deployed();
    console.log("Staking Contract deployed to:", staking.address);

    // 授权 Staking 合约使用代币
    await stakingToken.approve(staking.address, ethers.utils.parseEther("1000000"));
    await rewardToken.approve(staking.address, ethers.utils.parseEther("1000000"));

    console.log("Deployment completed!");
}

main().catch((error) => {
    console.error(error);
    process.exitCode = 1;
});
```

```javascript
// test.js
const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("Advanced Staking Contract", function () {
    let staking;
    let stakingToken;
    let rewardToken;
    let owner;
    let user1;
    let user2;

    beforeEach(async function () {
        [owner, user1, user2] = await ethers.getSigners();

        // 部署测试代币
        const ERC20Mock = await ethers.getContractFactory("ERC20Mock");
        stakingToken = await ERC20Mock.deploy("Staking Token", "STK", owner.address, ethers.utils.parseEther("1000000"));
        rewardToken = await ERC20Mock.deploy("Reward Token", "RWD", owner.address, ethers.utils.parseEther("1000000"));

        // 部署 Staking 合约
        const AdvancedStaking = await ethers.getContractFactory("AdvancedStaking");
        staking = await AdvancedStaking.deploy(
            stakingToken.address,
            rewardToken.address,
            owner.address
        );

        // 给用户分配代币
        await stakingToken.transfer(user1.address, ethers.utils.parseEther("1000"));
        await stakingToken.transfer(user2.address, ethers.utils.parseEther("1000"));
        await rewardToken.transfer(staking.address, ethers.utils.parseEther("10000"));

        // 用户授权
        await stakingToken.connect(user1).approve(staking.address, ethers.utils.parseEther("1000"));
        await stakingToken.connect(user2).approve(staking.address, ethers.utils.parseEther("1000"));
    });

    it("应该正确质押代币", async function () {
        const stakeAmount = ethers.utils.parseEther("100");
        
        await staking.connect(user1).stake(stakeAmount);
        
        const userInfo = await staking.getUserInfo(user1.address);
        expect(userInfo.stakedAmount).to.equal(stakeAmount);
        
        const contractInfo = await staking.getContractInfo();
        expect(contractInfo.totalStakedTokens).to.equal(stakeAmount);
    });

    it("应该正确计算奖励", async function () {
        const stakeAmount = ethers.utils.parseEther("100");
        
        await staking.connect(user1).stake(stakeAmount);
        
        // 设置奖励率
        await staking.setRewardRate(ethers.utils.parseEther("0.001"));
        
        // 时间前进
        await ethers.provider.send("evm_increaseTime", [86400]); // 1天
        await ethers.provider.send("evm_mine");
        
        const earned = await staking.earned(user1.address);
        expect(earned).to.be.gt(0);
    });

    it("应该正确取款和领取奖励", async function () {
        const stakeAmount = ethers.utils.parseEther("100");
        
        await staking.connect(user1).stake(stakeAmount);
        await staking.setRewardRate(ethers.utils.parseEther("0.001"));
        
        await ethers.provider.send("evm_increaseTime", [86400]);
        await ethers.provider.send("evm_mine");
        
        const earnedBefore = await staking.earned(user1.address);
        await staking.connect(user1).getReward();
        
        const rewardBalance = await rewardToken.balanceOf(user1.address);
        expect(rewardBalance).to.equal(earnedBefore);
        
        await staking.connect(user1).withdraw(stakeAmount);
        const userInfo = await staking.getUserInfo(user1.address);
        expect(userInfo.stakedAmount).to.equal(0);
    });

    it("应该防止重入攻击", async function () {
        // 测试重入保护
        const MaliciousContract = await ethers.getContractFactory("MaliciousStaker");
        const malicious = await MaliciousContract.deploy(staking.address, stakingToken.address);
        
        await stakingToken.transfer(malicious.address, ethers.utils.parseEther("100"));
        await stakingToken.connect(owner).approve(malicious.address, ethers.utils.parseEther("1000"));
        
        // 应该失败，因为重入保护
        await expect(malicious.attack(ethers.utils.parseEther("100"))).to.be.reverted;
    });
});
```

## 4. 前端集成示例

```javascript
// stakingService.js
import { ethers } from 'ethers';
import StakingABI from './abis/StakingABI.json';

class StakingService {
    constructor(provider, contractAddress) {
        this.provider = provider;
        this.contract = new ethers.Contract(contractAddress, StakingABI, provider.getSigner());
    }

    // 获取用户信息
    async getUserInfo(address) {
        try {
            const [stakedAmount, pendingReward, stakeTime, lastClaimTime] = 
                await this.contract.getUserInfo(address);
            
            return {
                stakedAmount: ethers.utils.formatEther(stakedAmount),
                pendingReward: ethers.utils.formatEther(pendingReward),
                stakeTime: new Date(stakeTime * 1000),
                lastClaimTime: new Date(lastClaimTime * 1000)
            };
        } catch (error) {
            console.error('Error getting user info:', error);
            throw error;
        }
    }

    // 质押代币
    async stake(amount) {
        try {
            const amountWei = ethers.utils.parseEther(amount.toString());
            const tx = await this.contract.stake(amountWei);
            return await tx.wait();
        } catch (error) {
            console.error('Error staking:', error);
            throw error;
        }
    }

    // 取回质押
    async withdraw(amount) {
        try {
            const amountWei = ethers.utils.parseEther(amount.toString());
            const tx = await this.contract.withdraw(amountWei);
            return await tx.wait();
        } catch (error) {
            console.error('Error withdrawing:', error);
            throw error;
        }
    }

    // 领取奖励
    async getReward() {
        try {
            const tx = await this.contract.getReward();
            return await tx.wait();
        } catch (error) {
            console.error('Error getting reward:', error);
            throw error;
        }
    }

    // 退出（取回所有并领取奖励）
    async exit() {
        try {
            const tx = await this.contract.exit();
            return await tx.wait();
        } catch (error) {
            console.error('Error exiting:', error);
            throw error;
        }
    }

    // 获取合约统计
    async getContractInfo() {
        try {
            const [
                totalStakedTokens,
                currentRewardRate,
                totalRewardsPaid,
                stakingTokenBalance,
                rewardTokenBalance
            ] = await this.contract.getContractInfo();
            
            return {
                totalStaked: ethers.utils.formatEther(totalStakedTokens),
                rewardRate: ethers.utils.formatEther(currentRewardRate),
                totalRewardsPaid: ethers.utils.formatEther(totalRewardsPaid),
                stakingTokenBalance: ethers.utils.formatEther(stakingTokenBalance),
                rewardTokenBalance: ethers.utils.formatEther(rewardTokenBalance)
            };
        } catch (error) {
            console.error('Error getting contract info:', error);
            throw error;
        }
    }
}

export default StakingService;
```

## 5. 安全特性总结

### 已实现的安全措施：

1. **重入攻击防护** - 使用 `nonReentrant` 修饰器
2. **整数溢出防护** - Solidity 0.8+ 自动检查
3. **权限控制** - 基于角色的访问控制
4. **输入验证** - 零金额检查、余额检查
5. **紧急停止** - 暂停机制和紧急取回
6. **奖励计算安全** - 使用奖励债务模式防止操纵

### 部署建议：

1. **全面测试** - 在主网部署前进行完整测试
2. **安全审计** - 由专业安全团队审计
3. **渐进部署** - 先在小金额环境下测试
4. **监控告警** - 设置异常交易监控
5. **多重签名** - 管理权限使用多签钱包

这个 Staking 合约提供了完整的功能和强大的安全保护，适合在生产环境中使用。
