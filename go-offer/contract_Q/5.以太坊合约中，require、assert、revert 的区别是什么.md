好的，我们来详细解析以太坊合约中 `require`、`assert` 和 `revert` 的区别，这是编写安全智能合约的关键。

## 核心区别总结

| 特性 | `require` | `assert` | `revert` |
| :--- | :--- | :--- | :--- |
| **使用场景** | 输入验证、前置条件检查 | 内部错误、不变量检查 | 复杂条件回滚 |
| **Gas处理** | 退还所有剩余Gas | **不退还Gas** | 退还所有剩余Gas |
| **错误信息** | 支持自定义消息 | 固定Panic异常 | 支持自定义消息 |
| **错误标识** | `Error(string)` | `Panic(uint256)` | `Error(string)` |
| **推荐使用** | **外部调用验证** | **内部一致性检查** | **复杂逻辑回滚** |

---

## 详细解析

### 1. `require` - 输入验证和前置条件

**主要用于检查外部输入和合约状态的有效性。**

```solidity
contract RequireExample {
    address public owner;
    uint256 public balance;
    
    constructor() {
        owner = msg.sender;
    }
    
    function transfer(address to, uint256 amount) public {
        // ✅ 典型的使用场景：
        
        // 1. 输入验证
        require(to != address(0), "Invalid recipient address");
        
        // 2. 状态验证
        require(amount > 0, "Amount must be positive");
        require(balance >= amount, "Insufficient balance");
        
        // 3. 权限验证
        require(msg.sender == owner, "Only owner can transfer");
        
        // 业务逻辑
        balance -= amount;
        // ... 其他操作
    }
    
    function setBalance(uint256 newBalance) public {
        // 参数验证
        require(newBalance <= 1000000, "Balance too large");
        balance = newBalance;
    }
}
```

### 2. `assert` - 内部一致性和不变量检查

**主要用于检查永远不应该为假的内部条件（合约bug）。**

```solidity
contract AssertExample {
    uint256 public totalSupply;
    mapping(address => uint256) public balances;
    
    function transfer(address to, uint256 amount) public {
        uint256 initialTotal = totalSupply;
        
        // 业务逻辑
        balances[msg.sender] -= amount;
        balances[to] += amount;
        
        // ✅ assert: 检查不变量（应该永远为真）
        assert(balances[msg.sender] + balances[to] == initialTotal);
        // 如果这个失败，说明合约有bug！
    }
    
    function withdraw(uint256 amount) public {
        uint256 initialBalance = balances[msg.sender];
        
        require(amount <= initialBalance, "Insufficient funds");
        
        balances[msg.sender] -= amount;
        // 发送ETH...
        
        // ✅ assert: 检查余额不会出现下溢
        assert(balances[msg.sender] <= initialBalance);
    }
    
    function safeMathOperation(uint256 a, uint256 b) public pure returns (uint256) {
        uint256 result = a + b;
        // ✅ assert: 检查算术运算没有溢出
        assert(result >= a);
        return result;
    }
}
```

### 3. `revert` - 复杂条件回滚

**主要用于在复杂条件分支中回滚交易。**

```solidity
contract RevertExample {
    enum Status { Pending, Active, Inactive }
    
    struct User {
        Status status;
        uint256 balance;
        uint256 lastActivity;
    }
    
    mapping(address => User) public users;
    
    function complexTransfer(address to, uint256 amount) public {
        User storage fromUser = users[msg.sender];
        User storage toUser = users[to];
        
        // ✅ revert: 复杂条件检查
        if (fromUser.status != Status.Active) {
            revert("Sender account is not active");
        }
        
        if (toUser.status == Status.Inactive) {
            revert("Recipient account is inactive");
        }
        
        // 复杂的时间逻辑
        if (block.timestamp - fromUser.lastActivity > 90 days) {
            revert("Account dormant for too long");
        }
        
        // 复杂的金额逻辑
        if (amount > fromUser.balance * 8 / 10) {
            revert("Cannot transfer more than 80% of balance in one transaction");
        }
        
        // 业务逻辑
        fromUser.balance -= amount;
        toUser.balance += amount;
        fromUser.lastActivity = block.timestamp;
    }
    
    function conditionalRevert(uint256 scenario) public pure returns (string memory) {
        // ✅ revert: 在复杂条件分支中使用
        if (scenario == 1) {
            return "Success case 1";
        } else if (scenario == 2) {
            return "Success case 2";
        } else if (scenario == 3) {
            revert("Special error case 3");
        } else {
            revert("Unknown scenario");
        }
    }
}
```

---

## Gas成本分析

### Gas退还机制对比

```solidity
contract GasAnalysis {
    uint256 public value;
    
    function testRequire() public {
        value = 100; // 消耗Gas
        
        require(false, "This will revert");
        // ✅ 回滚，退还剩余Gas（包括value=100消耗的Gas）
    }
    
    function testAssert() public {
        value = 100; // 消耗Gas
        
        assert(false);
        // ❌ 回滚，但**不退还任何Gas**！
    }
    
    function testRevert() public {
        value = 100; // 消耗Gas
        
        revert("This will revert");
        // ✅ 回滚，退还剩余Gas（包括value=100消耗的Gas）
    }
}
```

**关键理解**：
- `require` 和 `revert`：**开发者错误** → 退还Gas
- `assert`：**合约bug** → 惩罚性不退还Gas

---

## 错误类型和编码

### Solidity 0.8.0+ 的错误类型

```solidity
contract ErrorTypes {
    function demonstrateErrors() public pure {
        // 🔵 require/revert 产生 Error(string)
        require(false, "This is an error message"); 
        // Error: 0x08c379a0
        // 后面跟着错误消息
        
        // 🔴 assert 产生 Panic(uint256)
        assert(false);
        // Panic: 0x4e487b71
        // 后面跟着错误代码（如0x01表示assert失败）
    }
}
```

### 自定义错误（Gas高效）

```solidity
contract CustomErrors {
    // ✅ 自定义错误 - 更省Gas
    error InsufficientBalance(uint256 available, uint256 required);
    error Unauthorized();
    error InvalidStatus();
    
    uint256 public balance;
    address public owner;
    
    function withdraw(uint256 amount) public {
        if (msg.sender != owner) {
            revert Unauthorized(); // 比require省Gas
        }
        
        if (amount > balance) {
            revert InsufficientBalance(balance, amount);
        }
        
        balance -= amount;
    }
    
    // 对比传统require
    function withdrawOld(uint256 amount) public {
        require(msg.sender == owner, "Unauthorized"); // 更耗Gas
        require(amount <= balance, "Insufficient balance");
        
        balance -= amount;
    }
}
```

---

## 实际应用场景

### 1. 访问控制和输入验证 → `require`
```solidity
contract AccessControl {
    address public admin;
    
    modifier onlyAdmin() {
        require(msg.sender == admin, "Only admin can call this");
        _;
    }
    
    function changeAdmin(address newAdmin) public onlyAdmin {
        require(newAdmin != address(0), "Invalid address");
        admin = newAdmin;
    }
}
```

### 2. 数学不变量检查 → `assert`
```solidity
contract Token {
    mapping(address => uint256) public balances;
    uint256 public totalSupply;
    
    function mint(address to, uint256 amount) public {
        uint256 oldTotal = totalSupply;
        
        balances[to] += amount;
        totalSupply += amount;
        
        // 检查总供应量不变性
        assert(totalSupply == oldTotal + amount);
    }
    
    function transfer(address from, address to, uint256 amount) public {
        uint256 oldTotal = balances[from] + balances[to];
        
        balances[from] -= amount;
        balances[to] += amount;
        
        // 检查余额总和不变性
        assert(balances[from] + balances[to] == oldTotal);
    }
}
```

### 3. 复杂业务逻辑 → `revert`
```solidity
contract Auction {
    enum State { Open, Closed }
    
    struct Bid {
        address bidder;
        uint256 amount;
        uint256 timestamp;
    }
    
    State public state;
    Bid public highestBid;
    
    function placeBid() public payable {
        // 复杂条件检查
        if (state != State.Open) {
            revert("Auction is closed");
        }
        
        if (msg.value <= highestBid.amount) {
            revert("Bid too low");
        }
        
        if (block.timestamp > auctionEndTime) {
            revert("Auction has ended");
        }
        
        // 业务逻辑
        if (highestBid.bidder != address(0)) {
            // 退还前一个最高出价
            payable(highestBid.bidder).transfer(highestBid.amount);
        }
        
        highestBid = Bid(msg.sender, msg.value, block.timestamp);
    }
}
```

---

## 最佳实践指南

### 1. 选择正确的检查方式
```solidity
contract BestPractices {
    function goodRequireUsage(uint256 amount) public view {
        // ✅ 好的require使用
        require(amount > 0, "Amount must be positive"); // 输入验证
        require(amount < 1000, "Amount too large");     // 业务规则
    }
    
    function goodAssertUsage(uint256 a, uint256 b) public pure {
        uint256 result = a + b;
        // ✅ 好的assert使用
        assert(result >= a); // 算术不变量检查
    }
    
    function goodRevertUsage(Status status) public pure {
        // ✅ 好的revert使用
        if (status == Status.Inactive) {
            revert("Account inactive"); // 复杂条件分支
        }
    }
}
```

### 2. 避免的坏实践
```solidity
contract BadPractices {
    function badRequireUsage() public {
        // ❌ 不要在应该用assert的地方用require
        uint256 result = 100 + 200;
        require(result == 300, "Math error"); // 应该用assert!
    }
    
    function badAssertUsage(address user) public view {
        // ❌ 不要在输入验证中用assert
        assert(user != address(0)); // 应该用require!
    }
    
    function unnecessaryRevert(uint256 x) public pure {
        // ❌ 简单条件不要用revert
        if (x == 0) {
            revert("x is zero"); // 应该用: require(x != 0, "x is zero");
        }
    }
}
```

### 3. 错误消息优化
```solidity
contract ErrorMessages {
    // ✅ 提供有用的错误信息
    function buyTokens(uint256 amount) public payable {
        require(amount > 0, "TokenPurchase: amount must be positive");
        require(
            msg.value >= amount * tokenPrice, 
            "TokenPurchase: insufficient payment"
        );
        require(
            tokenBalance >= amount,
            "TokenPurchase: insufficient token supply"
        );
    }
    
    // ✅ 使用自定义错误节省Gas
    error InsufficientPayment(uint256 paid, uint256 required);
    error ExceedsSupply(uint256 requested, uint256 available);
    
    function buyTokensOptimized(uint256 amount) public payable {
        if (amount == 0) revert("TokenPurchase: amount must be positive");
        if (msg.value < amount * tokenPrice) {
            revert InsufficientPayment(msg.value, amount * tokenPrice);
        }
        if (tokenBalance < amount) {
            revert ExceedsSupply(amount, tokenBalance);
        }
        
        // 业务逻辑
    }
}
```

---

## 总结

**核心选择指南：**

| 检查类型 | 推荐使用 | 原因 |
| :--- | :--- | :--- |
| **输入参数验证** | `require` | 用户错误，应该退还Gas |
| **权限检查** | `require` | 访问控制错误，用户错误 |
| **业务规则** | `require` | 业务逻辑限制，用户错误 |
| **算术不变量** | `assert` | 合约bug，不应该发生 |
| **状态一致性** | `assert` | 内部错误，惩罚性不退还Gas |
| **复杂条件分支** | `revert` | 灵活的条件回滚 |
| **Gas优化错误** | `revert` + 自定义错误 | 节省Gas成本 |

**记住这个简单的规则：**
> - **用户做错了什么** → 用 `require`（退还Gas）
> - **合约有bug** → 用 `assert`（不退还Gas）  
> - **复杂条件需要回滚** → 用 `revert`（退还Gas）

正确使用这三种回滚机制，能让你的合约更安全、更高效、更用户友好！
