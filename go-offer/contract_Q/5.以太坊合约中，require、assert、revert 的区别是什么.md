å¥½çš„ï¼Œæˆ‘ä»¬æ¥è¯¦ç»†è§£æä»¥å¤ªåŠåˆçº¦ä¸­ `require`ã€`assert` å’Œ `revert` çš„åŒºåˆ«ï¼Œè¿™æ˜¯ç¼–å†™å®‰å…¨æ™ºèƒ½åˆçº¦çš„å…³é”®ã€‚

## æ ¸å¿ƒåŒºåˆ«æ€»ç»“

| ç‰¹æ€§ | `require` | `assert` | `revert` |
| :--- | :--- | :--- | :--- |
| **ä½¿ç”¨åœºæ™¯** | è¾“å…¥éªŒè¯ã€å‰ç½®æ¡ä»¶æ£€æŸ¥ | å†…éƒ¨é”™è¯¯ã€ä¸å˜é‡æ£€æŸ¥ | å¤æ‚æ¡ä»¶å›æ»š |
| **Gaså¤„ç†** | é€€è¿˜æ‰€æœ‰å‰©ä½™Gas | **ä¸é€€è¿˜Gas** | é€€è¿˜æ‰€æœ‰å‰©ä½™Gas |
| **é”™è¯¯ä¿¡æ¯** | æ”¯æŒè‡ªå®šä¹‰æ¶ˆæ¯ | å›ºå®šPanicå¼‚å¸¸ | æ”¯æŒè‡ªå®šä¹‰æ¶ˆæ¯ |
| **é”™è¯¯æ ‡è¯†** | `Error(string)` | `Panic(uint256)` | `Error(string)` |
| **æ¨èä½¿ç”¨** | **å¤–éƒ¨è°ƒç”¨éªŒè¯** | **å†…éƒ¨ä¸€è‡´æ€§æ£€æŸ¥** | **å¤æ‚é€»è¾‘å›æ»š** |

---

## è¯¦ç»†è§£æ

### 1. `require` - è¾“å…¥éªŒè¯å’Œå‰ç½®æ¡ä»¶

**ä¸»è¦ç”¨äºæ£€æŸ¥å¤–éƒ¨è¾“å…¥å’Œåˆçº¦çŠ¶æ€çš„æœ‰æ•ˆæ€§ã€‚**

```solidity
contract RequireExample {
    address public owner;
    uint256 public balance;
    
    constructor() {
        owner = msg.sender;
    }
    
    function transfer(address to, uint256 amount) public {
        // âœ… å…¸å‹çš„ä½¿ç”¨åœºæ™¯ï¼š
        
        // 1. è¾“å…¥éªŒè¯
        require(to != address(0), "Invalid recipient address");
        
        // 2. çŠ¶æ€éªŒè¯
        require(amount > 0, "Amount must be positive");
        require(balance >= amount, "Insufficient balance");
        
        // 3. æƒé™éªŒè¯
        require(msg.sender == owner, "Only owner can transfer");
        
        // ä¸šåŠ¡é€»è¾‘
        balance -= amount;
        // ... å…¶ä»–æ“ä½œ
    }
    
    function setBalance(uint256 newBalance) public {
        // å‚æ•°éªŒè¯
        require(newBalance <= 1000000, "Balance too large");
        balance = newBalance;
    }
}
```

### 2. `assert` - å†…éƒ¨ä¸€è‡´æ€§å’Œä¸å˜é‡æ£€æŸ¥

**ä¸»è¦ç”¨äºæ£€æŸ¥æ°¸è¿œä¸åº”è¯¥ä¸ºå‡çš„å†…éƒ¨æ¡ä»¶ï¼ˆåˆçº¦bugï¼‰ã€‚**

```solidity
contract AssertExample {
    uint256 public totalSupply;
    mapping(address => uint256) public balances;
    
    function transfer(address to, uint256 amount) public {
        uint256 initialTotal = totalSupply;
        
        // ä¸šåŠ¡é€»è¾‘
        balances[msg.sender] -= amount;
        balances[to] += amount;
        
        // âœ… assert: æ£€æŸ¥ä¸å˜é‡ï¼ˆåº”è¯¥æ°¸è¿œä¸ºçœŸï¼‰
        assert(balances[msg.sender] + balances[to] == initialTotal);
        // å¦‚æœè¿™ä¸ªå¤±è´¥ï¼Œè¯´æ˜åˆçº¦æœ‰bugï¼
    }
    
    function withdraw(uint256 amount) public {
        uint256 initialBalance = balances[msg.sender];
        
        require(amount <= initialBalance, "Insufficient funds");
        
        balances[msg.sender] -= amount;
        // å‘é€ETH...
        
        // âœ… assert: æ£€æŸ¥ä½™é¢ä¸ä¼šå‡ºç°ä¸‹æº¢
        assert(balances[msg.sender] <= initialBalance);
    }
    
    function safeMathOperation(uint256 a, uint256 b) public pure returns (uint256) {
        uint256 result = a + b;
        // âœ… assert: æ£€æŸ¥ç®—æœ¯è¿ç®—æ²¡æœ‰æº¢å‡º
        assert(result >= a);
        return result;
    }
}
```

### 3. `revert` - å¤æ‚æ¡ä»¶å›æ»š

**ä¸»è¦ç”¨äºåœ¨å¤æ‚æ¡ä»¶åˆ†æ”¯ä¸­å›æ»šäº¤æ˜“ã€‚**

```solidity
contract RevertExample {
    enum Status { Pending, Active, Inactive }
    
    struct User {
        Status status;
        uint256 balance;
        uint256 lastActivity;
    }
    
    mapping(address => User) public users;
    
    function complexTransfer(address to, uint256 amount) public {
        User storage fromUser = users[msg.sender];
        User storage toUser = users[to];
        
        // âœ… revert: å¤æ‚æ¡ä»¶æ£€æŸ¥
        if (fromUser.status != Status.Active) {
            revert("Sender account is not active");
        }
        
        if (toUser.status == Status.Inactive) {
            revert("Recipient account is inactive");
        }
        
        // å¤æ‚çš„æ—¶é—´é€»è¾‘
        if (block.timestamp - fromUser.lastActivity > 90 days) {
            revert("Account dormant for too long");
        }
        
        // å¤æ‚çš„é‡‘é¢é€»è¾‘
        if (amount > fromUser.balance * 8 / 10) {
            revert("Cannot transfer more than 80% of balance in one transaction");
        }
        
        // ä¸šåŠ¡é€»è¾‘
        fromUser.balance -= amount;
        toUser.balance += amount;
        fromUser.lastActivity = block.timestamp;
    }
    
    function conditionalRevert(uint256 scenario) public pure returns (string memory) {
        // âœ… revert: åœ¨å¤æ‚æ¡ä»¶åˆ†æ”¯ä¸­ä½¿ç”¨
        if (scenario == 1) {
            return "Success case 1";
        } else if (scenario == 2) {
            return "Success case 2";
        } else if (scenario == 3) {
            revert("Special error case 3");
        } else {
            revert("Unknown scenario");
        }
    }
}
```

---

## Gasæˆæœ¬åˆ†æ

### Gasé€€è¿˜æœºåˆ¶å¯¹æ¯”

```solidity
contract GasAnalysis {
    uint256 public value;
    
    function testRequire() public {
        value = 100; // æ¶ˆè€—Gas
        
        require(false, "This will revert");
        // âœ… å›æ»šï¼Œé€€è¿˜å‰©ä½™Gasï¼ˆåŒ…æ‹¬value=100æ¶ˆè€—çš„Gasï¼‰
    }
    
    function testAssert() public {
        value = 100; // æ¶ˆè€—Gas
        
        assert(false);
        // âŒ å›æ»šï¼Œä½†**ä¸é€€è¿˜ä»»ä½•Gas**ï¼
    }
    
    function testRevert() public {
        value = 100; // æ¶ˆè€—Gas
        
        revert("This will revert");
        // âœ… å›æ»šï¼Œé€€è¿˜å‰©ä½™Gasï¼ˆåŒ…æ‹¬value=100æ¶ˆè€—çš„Gasï¼‰
    }
}
```

**å…³é”®ç†è§£**ï¼š
- `require` å’Œ `revert`ï¼š**å¼€å‘è€…é”™è¯¯** â†’ é€€è¿˜Gas
- `assert`ï¼š**åˆçº¦bug** â†’ æƒ©ç½šæ€§ä¸é€€è¿˜Gas

---

## é”™è¯¯ç±»å‹å’Œç¼–ç 

### Solidity 0.8.0+ çš„é”™è¯¯ç±»å‹

```solidity
contract ErrorTypes {
    function demonstrateErrors() public pure {
        // ğŸ”µ require/revert äº§ç”Ÿ Error(string)
        require(false, "This is an error message"); 
        // Error: 0x08c379a0
        // åé¢è·Ÿç€é”™è¯¯æ¶ˆæ¯
        
        // ğŸ”´ assert äº§ç”Ÿ Panic(uint256)
        assert(false);
        // Panic: 0x4e487b71
        // åé¢è·Ÿç€é”™è¯¯ä»£ç ï¼ˆå¦‚0x01è¡¨ç¤ºassertå¤±è´¥ï¼‰
    }
}
```

### è‡ªå®šä¹‰é”™è¯¯ï¼ˆGasé«˜æ•ˆï¼‰

```solidity
contract CustomErrors {
    // âœ… è‡ªå®šä¹‰é”™è¯¯ - æ›´çœGas
    error InsufficientBalance(uint256 available, uint256 required);
    error Unauthorized();
    error InvalidStatus();
    
    uint256 public balance;
    address public owner;
    
    function withdraw(uint256 amount) public {
        if (msg.sender != owner) {
            revert Unauthorized(); // æ¯”requireçœGas
        }
        
        if (amount > balance) {
            revert InsufficientBalance(balance, amount);
        }
        
        balance -= amount;
    }
    
    // å¯¹æ¯”ä¼ ç»Ÿrequire
    function withdrawOld(uint256 amount) public {
        require(msg.sender == owner, "Unauthorized"); // æ›´è€—Gas
        require(amount <= balance, "Insufficient balance");
        
        balance -= amount;
    }
}
```

---

## å®é™…åº”ç”¨åœºæ™¯

### 1. è®¿é—®æ§åˆ¶å’Œè¾“å…¥éªŒè¯ â†’ `require`
```solidity
contract AccessControl {
    address public admin;
    
    modifier onlyAdmin() {
        require(msg.sender == admin, "Only admin can call this");
        _;
    }
    
    function changeAdmin(address newAdmin) public onlyAdmin {
        require(newAdmin != address(0), "Invalid address");
        admin = newAdmin;
    }
}
```

### 2. æ•°å­¦ä¸å˜é‡æ£€æŸ¥ â†’ `assert`
```solidity
contract Token {
    mapping(address => uint256) public balances;
    uint256 public totalSupply;
    
    function mint(address to, uint256 amount) public {
        uint256 oldTotal = totalSupply;
        
        balances[to] += amount;
        totalSupply += amount;
        
        // æ£€æŸ¥æ€»ä¾›åº”é‡ä¸å˜æ€§
        assert(totalSupply == oldTotal + amount);
    }
    
    function transfer(address from, address to, uint256 amount) public {
        uint256 oldTotal = balances[from] + balances[to];
        
        balances[from] -= amount;
        balances[to] += amount;
        
        // æ£€æŸ¥ä½™é¢æ€»å’Œä¸å˜æ€§
        assert(balances[from] + balances[to] == oldTotal);
    }
}
```

### 3. å¤æ‚ä¸šåŠ¡é€»è¾‘ â†’ `revert`
```solidity
contract Auction {
    enum State { Open, Closed }
    
    struct Bid {
        address bidder;
        uint256 amount;
        uint256 timestamp;
    }
    
    State public state;
    Bid public highestBid;
    
    function placeBid() public payable {
        // å¤æ‚æ¡ä»¶æ£€æŸ¥
        if (state != State.Open) {
            revert("Auction is closed");
        }
        
        if (msg.value <= highestBid.amount) {
            revert("Bid too low");
        }
        
        if (block.timestamp > auctionEndTime) {
            revert("Auction has ended");
        }
        
        // ä¸šåŠ¡é€»è¾‘
        if (highestBid.bidder != address(0)) {
            // é€€è¿˜å‰ä¸€ä¸ªæœ€é«˜å‡ºä»·
            payable(highestBid.bidder).transfer(highestBid.amount);
        }
        
        highestBid = Bid(msg.sender, msg.value, block.timestamp);
    }
}
```

---

## æœ€ä½³å®è·µæŒ‡å—

### 1. é€‰æ‹©æ­£ç¡®çš„æ£€æŸ¥æ–¹å¼
```solidity
contract BestPractices {
    function goodRequireUsage(uint256 amount) public view {
        // âœ… å¥½çš„requireä½¿ç”¨
        require(amount > 0, "Amount must be positive"); // è¾“å…¥éªŒè¯
        require(amount < 1000, "Amount too large");     // ä¸šåŠ¡è§„åˆ™
    }
    
    function goodAssertUsage(uint256 a, uint256 b) public pure {
        uint256 result = a + b;
        // âœ… å¥½çš„assertä½¿ç”¨
        assert(result >= a); // ç®—æœ¯ä¸å˜é‡æ£€æŸ¥
    }
    
    function goodRevertUsage(Status status) public pure {
        // âœ… å¥½çš„revertä½¿ç”¨
        if (status == Status.Inactive) {
            revert("Account inactive"); // å¤æ‚æ¡ä»¶åˆ†æ”¯
        }
    }
}
```

### 2. é¿å…çš„åå®è·µ
```solidity
contract BadPractices {
    function badRequireUsage() public {
        // âŒ ä¸è¦åœ¨åº”è¯¥ç”¨assertçš„åœ°æ–¹ç”¨require
        uint256 result = 100 + 200;
        require(result == 300, "Math error"); // åº”è¯¥ç”¨assert!
    }
    
    function badAssertUsage(address user) public view {
        // âŒ ä¸è¦åœ¨è¾“å…¥éªŒè¯ä¸­ç”¨assert
        assert(user != address(0)); // åº”è¯¥ç”¨require!
    }
    
    function unnecessaryRevert(uint256 x) public pure {
        // âŒ ç®€å•æ¡ä»¶ä¸è¦ç”¨revert
        if (x == 0) {
            revert("x is zero"); // åº”è¯¥ç”¨: require(x != 0, "x is zero");
        }
    }
}
```

### 3. é”™è¯¯æ¶ˆæ¯ä¼˜åŒ–
```solidity
contract ErrorMessages {
    // âœ… æä¾›æœ‰ç”¨çš„é”™è¯¯ä¿¡æ¯
    function buyTokens(uint256 amount) public payable {
        require(amount > 0, "TokenPurchase: amount must be positive");
        require(
            msg.value >= amount * tokenPrice, 
            "TokenPurchase: insufficient payment"
        );
        require(
            tokenBalance >= amount,
            "TokenPurchase: insufficient token supply"
        );
    }
    
    // âœ… ä½¿ç”¨è‡ªå®šä¹‰é”™è¯¯èŠ‚çœGas
    error InsufficientPayment(uint256 paid, uint256 required);
    error ExceedsSupply(uint256 requested, uint256 available);
    
    function buyTokensOptimized(uint256 amount) public payable {
        if (amount == 0) revert("TokenPurchase: amount must be positive");
        if (msg.value < amount * tokenPrice) {
            revert InsufficientPayment(msg.value, amount * tokenPrice);
        }
        if (tokenBalance < amount) {
            revert ExceedsSupply(amount, tokenBalance);
        }
        
        // ä¸šåŠ¡é€»è¾‘
    }
}
```

---

## æ€»ç»“

**æ ¸å¿ƒé€‰æ‹©æŒ‡å—ï¼š**

| æ£€æŸ¥ç±»å‹ | æ¨èä½¿ç”¨ | åŸå›  |
| :--- | :--- | :--- |
| **è¾“å…¥å‚æ•°éªŒè¯** | `require` | ç”¨æˆ·é”™è¯¯ï¼Œåº”è¯¥é€€è¿˜Gas |
| **æƒé™æ£€æŸ¥** | `require` | è®¿é—®æ§åˆ¶é”™è¯¯ï¼Œç”¨æˆ·é”™è¯¯ |
| **ä¸šåŠ¡è§„åˆ™** | `require` | ä¸šåŠ¡é€»è¾‘é™åˆ¶ï¼Œç”¨æˆ·é”™è¯¯ |
| **ç®—æœ¯ä¸å˜é‡** | `assert` | åˆçº¦bugï¼Œä¸åº”è¯¥å‘ç”Ÿ |
| **çŠ¶æ€ä¸€è‡´æ€§** | `assert` | å†…éƒ¨é”™è¯¯ï¼Œæƒ©ç½šæ€§ä¸é€€è¿˜Gas |
| **å¤æ‚æ¡ä»¶åˆ†æ”¯** | `revert` | çµæ´»çš„æ¡ä»¶å›æ»š |
| **Gasä¼˜åŒ–é”™è¯¯** | `revert` + è‡ªå®šä¹‰é”™è¯¯ | èŠ‚çœGasæˆæœ¬ |

**è®°ä½è¿™ä¸ªç®€å•çš„è§„åˆ™ï¼š**
> - **ç”¨æˆ·åšé”™äº†ä»€ä¹ˆ** â†’ ç”¨ `require`ï¼ˆé€€è¿˜Gasï¼‰
> - **åˆçº¦æœ‰bug** â†’ ç”¨ `assert`ï¼ˆä¸é€€è¿˜Gasï¼‰  
> - **å¤æ‚æ¡ä»¶éœ€è¦å›æ»š** â†’ ç”¨ `revert`ï¼ˆé€€è¿˜Gasï¼‰

æ­£ç¡®ä½¿ç”¨è¿™ä¸‰ç§å›æ»šæœºåˆ¶ï¼Œèƒ½è®©ä½ çš„åˆçº¦æ›´å®‰å…¨ã€æ›´é«˜æ•ˆã€æ›´ç”¨æˆ·å‹å¥½ï¼
