
# 一、XXXXXX

在 Hardhat 或 Foundry 中进行主网分叉（mainnet fork）测试非常有用，尤其是在模拟真实主网环境时。以下是具体方法和一个示例场景：

---

### **1. Hardhat 中的主网分叉**

#### **步骤 1：配置 Hardhat 网络**
在 `hardhat.config.js` 中配置一个分叉网络：
```javascript
require("@nomicfoundation/hardhat-toolbox");

module.exports = {
  solidity: "0.8.19",
  networks: {
    hardhat: {
      // 启用主网分叉
      forking: {
        url: "https://eth-mainnet.g.alchemy.com/v2/YOUR_API_KEY", // 使用 Alchemy 或 Infura 的 RPC
        blockNumber: 17830000, // 可选：指定区块高度（固定测试环境）
      },
    },
  },
};
```

#### **步骤 2：编写测试脚本**
假设你要测试一个依赖主网 Uniswap 的交易逻辑：
```javascript
const { ethers } = require("hardhat");

describe("Mainnet Fork Test", () => {
  it("应该成功查询 Uniswap 上的 DAI 余额", async () => {
    // 获取主网分叉的 Provider
    const provider = ethers.provider;

    // 使用主网上的真实合约地址
    const daiAddress = "0x6B175474E89094C44Da98b954EedeAC495271d0F";
    const daiAbi = ["function balanceOf(address) view returns (uint256)"];
    const daiContract = new ethers.Contract(daiAddress, daiAbi, provider);

    // 测试查询某个地址的 DAI 余额（例如 Vitalik 的地址）
    const vitalikDaiBalance = await daiContract.balanceOf("0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045");
    console.log("Vitalik 的 DAI 余额:", ethers.formatEther(vitalikDaiBalance));
  });
});
```

#### **运行测试**
```bash
npx hardhat test
```

---

### **2. Foundry 中的主网分叉**

#### **步骤 1：启动分叉节点**
使用 `anvil`（Foundry 的本地节点工具）：
```bash
anvil --fork-url https://eth-mainnet.g.alchemy.com/v2/YOUR_API_KEY --fork-block-number 17830000
```
这会启动一个本地分叉节点（默认端口 `8545`）。

#### **步骤 2：编写测试脚本**
假设测试一个闪电贷场景（依赖主网 Aave）：
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

contract AaveForkTest is Test {
    // 主网 Aave 的 LendingPool 地址
    address constant AAVE_LENDING_POOL = 0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9;

    function setUp() public {
        // 连接分叉的本地节点
        vm.createSelectFork("https://eth-mainnet.g.alchemy.com/v2/YOUR_API_KEY", 17830000);
    }

    function testAaveDeposit() public {
        // 模拟用户存款
        address user = makeAddr("alice");
        deal(address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE), user, 1 ether); // 给用户 1 ETH

        vm.startPrank(user);
        (bool success, ) = AAVE_LENDING_POOL.call{value: 1 ether}("");
        require(success, "Deposit failed");
        vm.stopPrank();
    }
}
```

#### **运行测试**
```bash
forge test --fork-url https://eth-mainnet.g.alchemy.com/v2/YOUR_API_KEY -vvv
```

---

### **示例场景：测试闪电贷套利**
**场景描述**：  
你想测试一个合约是否能在分叉的主网环境中通过 Uniswap 和 Sushiswap 的价差实现闪电贷套利。

**步骤**：
1. 分叉主网到某个历史区块（确保价差存在）。
2. 在测试中：
   - 通过 Aave 借出闪电贷。
   - 在 Uniswap 低价买入某代币，在 Sushiswap 高价卖出。
   - 偿还闪电贷并检查利润。

**关键点**：
- 使用 `deal`（Foundry）或 `hardhat_setBalance`（Hardhat）模拟资金。
- 调用真实合约的地址和 ABI。

---

### **注意事项**
1. **API 提供商**：推荐使用 Alchemy 或 Infura（免费层可能有速率限制）。
2. **区块高度**：固定区块号可确保测试可重现。
3. **缓存**：Hardhat 会缓存分叉数据（默认在 `~/.hardhat/networks/`）。
4. **隐私**：不要在代码中暴露 API 密钥，使用环境变量（如 `process.env.ALCHEMY_KEY`）。


# 二、XXXXXX



在 Hardhat 或 Foundry 中进行 **mainnet fork 测试**，可以让你在本地环境中完整复现以太坊主网的某个区块状态，从而安全地测试合约在真实网络中的行为。以下是两种工具的实现方式及一个具体场景示例。

---

### **1. Hardhat 中实现 Mainnet Fork**
#### 步骤：
1. **安装依赖**  
   安装 `hardhat-network-hodl` 插件（用于 fork 主网）：
   ```bash
   npm install hardhat-network-hodl
   ```

2. **配置 `hardhat.config.js`**  
   添加 fork 网络配置（需替换为你的 Infura 或 Alchemy API 地址）：
   ```javascript
   require("hardhat-network-hodl");

   module.exports = {
     networks: {
       mainnet_fork: {
         url: "https://mainnet.infura.io/v3/YOUR_INFURA_API_KEY",
         chainId: 1, // 以太坊主网 chainId
         forking: {
           jsonRpcUrl: "https://mainnet.infura.io/v3/YOUR_INFURA_API_KEY",
           blockNumber: 16000000, // 指定 fork 的区块号（可选）
         },
       },
     },
   };
   ```

3. **运行测试**  
   使用 `mainnet_fork` 网络运行测试：
   ```bash
   npx hardhat test --network mainnet_fork
   ```

---

### **2. Foundry 中实现 Mainnet Fork**
#### 步骤：
1. **启动 Anvil（本地测试节点）**  
   使用 `anvil` 命令 fork 主网（需替换为你的节点 URL）：
   ```bash
   anvil --fork-url https://mainnet.infura.io/v3/YOUR_INFURA_API_KEY --fork-block-number 16000000
   ```
   这会启动一个本地节点，端口默认为 `8545`。

2. **编写测试合约**  
   使用 `forge` 编写测试用例，通过 `vm` 模块模拟主网环境：
   ```solidity
   // SPDX-License-Identifier: MIT
   pragma solidity ^0.8.13;

   import "forge-std/Test.sol";
   import "forge-std/console.sol";

   contract MyTest is Test {
       function setUp() public {
           // 在测试中模拟主网账户和余额
           vm.startPrank(address(0xAbcDef...)); // 替换为某个主网地址
           vm.deal(address(this), 100 ether); // 设置测试合约余额
       }

       function testExample() public {
           // 在这里编写测试逻辑
           uint256 balance = address(this).balance;
           assertTrue(balance == 100 ether);
       }
   }
   ```

3. **运行测试**  
   指定 RPC 端点运行测试：
   ```bash
   forge test --rpc-url http://localhost:8545
   ```

---

### **场景示例：测试 DeFi 合约的清算功能**
假设你要测试一个 DeFi 借贷协议的清算逻辑，需要在主网某个区块（如区块 16000000）的流动性池状态下运行测试。

#### **目标**：
1. Fork 主网区块 16000000。
2. 模拟用户抵押资产并触发清算。
3. 验证清算逻辑是否符合预期。

#### **实现步骤**：
- **Hardhat**：
  - 部署你的借贷合约到 fork 的主网环境中。
  - 调用抵押函数（如 `deposit()`），并模拟价格暴跌触发清算。
  - 使用 `ethers.js` 断言清算后的账户余额是否正确。

- **Foundry**：
  - 在测试合约中使用 `vm` 模块预设抵押资产和价格数据。
  - 调用清算函数并验证事件或账户状态。

#### **代码片段（Foundry）**：
```solidity
function testLiquidation() public {
    // 假设抵押的 ETH 价值暴跌至 0.1 ETH/USD
    uint256 liquidationThreshold = 0.1 ether;
    vm.prank(user);
    lendingPool.liquidate{value: liquidationThreshold}(user);
    
    // 验证用户抵押的资产被正确清算
    assertEq(lendingPool.collateralOf(user), 0);
}
```

---

### **注意事项**
1. **节点服务限制**：Infura 或 Alchemy 的免费 API 可能有速率限制，建议使用付费计划。
2. **区块状态**：Fork 的区块状态是静态的，测试中对链上状态的修改不会影响真实主网。
3. **Gas 费用**：本地测试无需真实 Gas，但需注意合约交互的 Gas 消耗。

通过这种方式，你可以安全地模拟主网环境下的复杂场景（如 51% 攻击、极端市场波动等），确保合约的健壮性。
