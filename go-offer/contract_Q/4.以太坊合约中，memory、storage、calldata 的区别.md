# 以太坊合约中 memory、storage、calldata 的区别

## 1. 核心概念总览

### 1.1 三种数据位置的对比表格

| 特性 | Storage | Memory | Calldata |
|------|---------|---------|-----------|
| **持久性** | 永久存储 | 临时存储 | 临时存储 |
| **可修改性** | 可读写 | 可读写 | 只读 |
| **Gas 成本** | 高 | 中 | 低 |
| **生命周期** | 合约生命周期 | 函数执行期间 | 函数执行期间 |
| **使用场景** | 状态变量 | 函数内临时变量 | 函数参数 |
| **数据位置** | 区块链状态 | EVM 内存 | 交易数据 |

## 2. Storage（存储）

### 2.1 基本特性
```solidity
contract StorageExample {
    // 状态变量 - 自动存储在 storage
    uint256 public count;                    // 槽 0
    address public owner;                    // 槽 1  
    mapping(address => uint256) public balances; // 槽 2（仅存储根哈希）
    
    struct User {
        string name;
        uint256 balance;
    }
    User[] public users;                     // 槽 3
    
    constructor() {
        owner = msg.sender;
        count = 0;
    }
    
    function storageOperations() public {
        // 局部变量默认指向 storage（当引用状态变量时）
        User storage user = users[0];        // storage 引用
        user.balance = 100;                  // 直接修改原数据
        
        // 创建新的 storage 条目
        users.push(User("Alice", 50));       // 写入 storage
    }
}
```

### 2.2 Storage 布局和 Gas 成本
```solidity
contract StorageLayout {
    // 存储槽分配示例
    uint256 public a;        // 槽 0
    uint128 public b;        // 槽 1（字节 0-15）
    uint128 public c;        // 槽 1（字节 16-31）- 自动打包
    
    struct Packed {
        uint64 x;            // 槽 2（字节 0-7）
        uint64 y;            // 槽 2（字节 8-15）
        uint64 z;            // 槽 2（字节 16-23）
        // 剩余 8 字节空闲
    }
    Packed public packedData;
    
    mapping(address => uint256) public userScores;
    
    function calculateGasCost() public {
        // 第一次写入 storage：~20,000 Gas
        a = 100;
        
        // 修改现有 storage：~5,000 Gas  
        a = 200;
        
        // 读取 storage：~200 Gas
        uint256 value = a;
        
        // 映射操作
        userScores[msg.sender] = 1000;       // ~20,000 Gas
    }
    
    function storagePointerExample() public {
        // storage 指针 - 引用现有存储位置
        Packed storage dataRef = packedData;
        dataRef.x = 10;                      // 直接修改 storage
        
        // 数组的 storage 引用
        uint256[] storage arrayRef = someStorageArray;
        arrayRef[0] = 100;                   // 修改原数组
    }
}
```

## 3. Memory（内存）

### 3.1 基本特性
```solidity
contract MemoryExample {
    uint256[] public storageArray = [1, 2, 3];
    
    function memoryOperations() public pure returns (uint256) {
        // 在内存中创建新数组
        uint256[] memory memoryArray = new uint256[](3);
        memoryArray[0] = 10;
        memoryArray[1] = 20;
        memoryArray[2] = 30;
        
        // 修改内存数组
        memoryArray[0] = 100;                // 只修改内存副本
        
        return memoryArray[0];               // 返回 100
    }
    
    function compareWithStorage() public {
        // 从 storage 复制到 memory
        uint256[] memory memoryCopy = storageArray;
        memoryCopy[0] = 999;                 // 只修改内存副本
        
        // storageArray[0] 仍然是 1，不是 999
        
        // storage 引用
        uint256[] storage storageRef = storageArray;
        storageRef[0] = 888;                 // 修改原 storage 数据
        
        // storageArray[0] 现在是 888
    }
    
    function complexMemoryUsage() public pure {
        // 内存布局管理
        uint256 freeMemoryPointer;
        
        assembly {
            freeMemoryPointer := mload(0x40) // 获取当前空闲内存指针
        }
        
        // 在内存中创建复杂结构
        bytes memory dynamicData = new bytes(64);
        for (uint256 i = 0; i < 64; i++) {
            dynamicData[i] = bytes1(uint8(i));
        }
        
        // 手动内存管理（高级用法）
        assembly {
            // 更新空闲内存指针
            mstore(0x40, add(freeMemoryPointer, 128))
        }
    }
}
```

### 3.2 内存的生命周期和 Gas
```solidity
contract MemoryLifecycle {
    function temporaryNature() public pure returns (uint256) {
        // 内存变量只在函数执行期间存在
        uint256[] memory tempArray = new uint256[](100);
        
        for (uint256 i = 0; i < tempArray.length; i++) {
            tempArray[i] = i * 2;
        }
        
        uint256 sum = 0;
        for (uint256 i = 0; i < tempArray.length; i++) {
            sum += tempArray[i];
        }
        
        // 函数结束时，tempArray 从内存中清除
        return sum;
    }
    
    function memoryGasCost() public pure {
        // 内存扩展的 Gas 成本
        uint256[] memory smallArray = new uint256[](1);  // 便宜
        uint256[] memory largeArray = new uint256[](1000); // 更贵
        
        // 内存写入成本相对较低
        for (uint256 i = 0; i < 100; i++) {
            largeArray[i] = i;  // 比 storage 写入便宜得多
        }
    }
}
```

## 4. Calldata（调用数据）

### 4.1 基本特性和使用
```solidity
contract CalldataExample {
    // 外部函数的参数应该使用 calldata
    function processData(bytes calldata data) external pure returns (bytes32) {
        // data 是只读的，来自交易调用数据
        // 不能修改 data
        
        return keccak256(data);
    }
    
    function processArrays(
        uint256[] calldata numbers,
        address[] calldata addresses,
        string calldata message
    ) external pure returns (uint256) {
        uint256 sum = 0;
        
        // 直接读取 calldata，无需复制到 memory
        for (uint256 i = 0; i < numbers.length; i++) {
            sum += numbers[i];
        }
        
        // 可以读取但不能修改
        // addresses[0] = address(0);  // ❌ 编译错误
        
        return sum;
    }
    
    // 与 memory 参数对比
    function processDataMemory(bytes memory data) public pure returns (bytes32) {
        // data 被复制到 memory，可以修改
        // 但消耗更多 Gas
        
        if (data.length > 0) {
            // 可以修改 memory 数据
            // 但这里我们不修改以保持一致性
        }
        
        return keccak256(data);
    }
}
```

### 4.2 Calldata 的高级操作
```solidity
contract AdvancedCalldata {
    // 手动解析 calldata
    function parseCalldata() external pure returns (bytes4, uint256, address) {
        bytes4 selector;
        uint256 value;
        address addr;
        
        assembly {
            // 前 4 字节是函数选择器
            selector := calldataload(0)
            
            // 接下来 32 字节是第一个参数 (uint256)
            value := calldataload(4)
            
            // 再接下来 32 字节是第二个参数 (address)
            addr := calldataload(36)
        }
        
        return (selector, value, addr);
    }
    
    // 处理动态类型的 calldata
    function processDynamicCalldata(
        string calldata text,
        uint256[] calldata numbers
    ) external pure returns (uint256) {
        // 动态类型在 calldata 中的布局：
        // - 函数选择器: 4 字节
        // - text 的偏移量: 32 字节
        // - numbers 的偏移量: 32 字节
        // - text 的实际数据
        // - numbers 的实际数据
        
        uint256 total = 0;
        for (uint256 i = 0; i < numbers.length; i++) {
            total += numbers[i];
        }
        
        return total + bytes(text).length;
    }
    
    // 高效的批量操作
    function batchTransfer(
        address[] calldata recipients,
        uint256[] calldata amounts
    ) external {
        require(recipients.length == amounts.length, "Length mismatch");
        
        // 直接使用 calldata 遍历，避免内存复制
        for (uint256 i = 0; i < recipients.length; i++) {
            _transfer(recipients[i], amounts[i]);
        }
    }
    
    function _transfer(address to, uint256 amount) internal {
        // 转账逻辑
    }
}
```

## 5. 实际应用场景对比

### 5.1 性能优化示例
```solidity
contract GasOptimization {
    struct UserData {
        string name;
        uint256 score;
        address referrer;
    }
    
    mapping(address => UserData) public users;
    
    // ❌ 非优化版本 - 使用 memory 参数
    function updateUserMemory(UserData memory userData) public {
        users[msg.sender] = userData;  // 需要从 calldata 复制到 memory
    }
    
    // ✅ 优化版本 - 使用单个 calldata 参数
    function updateUserCalldata(
        string calldata name,
        uint256 score,
        address referrer
    ) public {
        users[msg.sender] = UserData(name, score, referrer);
        // 直接读取 calldata，避免不必要的复制
    }
    
    // ✅ 更优化的版本 - 批量操作
    function batchUpdateUsers(
        address[] calldata userAddresses,
        string[] calldata names,
        uint256[] calldata scores
    ) external {
        require(
            userAddresses.length == names.length && 
            names.length == scores.length,
            "Array length mismatch"
        );
        
        for (uint256 i = 0; i < userAddresses.length; i++) {
            users[userAddresses[i]] = UserData(names[i], scores[i], address(0));
        }
    }
}
```

### 5.2 数据位置转换示例
```solidity
contract DataLocationConversion {
    uint256[] public storageArray = [1, 2, 3, 4, 5];
    
    // calldata → memory → storage
    function calldataToStorage(uint256[] calldata input) external {
        // calldata 必须先复制到 memory 才能存入 storage
        uint256[] memory memoryCopy = input;
        storageArray = memoryCopy;
    }
    
    // storage → memory
    function storageToMemory() public view returns (uint256[] memory) {
        // storage 复制到 memory
        uint256[] memory memoryCopy = storageArray;
        return memoryCopy;
    }
    
    // memory → storage
    function memoryToStorage(uint256[] memory input) public {
        // memory 可以直接赋值给 storage
        storageArray = input;
    }
    
    // storage 引用操作
    function modifyStorageDirectly() public {
        // 创建 storage 引用
        uint256[] storage arrayRef = storageArray;
        
        // 通过引用直接修改 storage
        for (uint256 i = 0; i < arrayRef.length; i++) {
            arrayRef[i] = arrayRef[i] * 2;
        }
    }
}
```

## 6. 函数参数和返回值的默认行为

### 6.1 参数的数据位置规则
```solidity
contract FunctionParameters {
    // 外部函数的参数默认是 calldata
    function externalFunction(uint256[] calldata data) external {
        // data 是 calldata
    }
    
    // 公共函数的参数默认是 memory
    function publicFunction(uint256[] memory data) public {
        // data 是 memory
    }
    
    // 内部和私有函数的参数默认是 memory
    function internalFunction(uint256[] memory data) internal {
        // data 是 memory
    }
    
    // 返回值总是 memory
    function returnArray() public view returns (uint256[] memory) {
        uint256[] memory result = new uint256[](10);
        return result;  // 返回 memory 数据
    }
    
    // 错误示例：不能返回 storage 引用
    // function invalidReturn() public view returns (uint256[] storage) {
    //     return storageArray;  // ❌ 编译错误
    // }
}
```

### 6.2 最佳实践总结
```solidity
contract BestPractices {
    struct Transaction {
        address from;
        address to;
        uint256 amount;
        bytes data;
    }
    
    Transaction[] public transactions;
    
    // ✅ 推荐：外部函数使用 calldata
    function addTransaction(
        address to,
        uint256 amount,
        bytes calldata data
    ) external {
        transactions.push(Transaction(msg.sender, to, amount, data));
    }
    
    // ✅ 推荐：批量操作使用 calldata
    function addMultipleTransactions(
        Transaction[] calldata newTransactions
    ) external {
        for (uint256 i = 0; i < newTransactions.length; i++) {
            transactions.push(newTransactions[i]);
        }
    }
    
    // ✅ 推荐：内部处理使用 memory
    function processTransactions() internal {
        Transaction[] memory pendingTransactions = _getPendingTransactions();
        
        for (uint256 i = 0; i < pendingTransactions.length; i++) {
            _processSingleTransaction(pendingTransactions[i]);
        }
    }
    
    function _getPendingTransactions() internal view returns (Transaction[] memory) {
        // 从 storage 复制到 memory 进行处理
        Transaction[] memory result = new Transaction[](transactions.length);
        for (uint256 i = 0; i < transactions.length; i++) {
            result[i] = transactions[i];
        }
        return result;
    }
    
    function _processSingleTransaction(Transaction memory transaction) internal {
        // 处理单个交易（memory 数据）
    }
}
```

## 7. 复杂类型的数据位置

### 7.1 结构体和数组
```solidity
contract ComplexTypes {
    struct User {
        string name;
        uint256[] scores;
        mapping(address => bool) friends;
    }
    
    mapping(address => User) public users;
    
    function handleComplexData(
        string calldata name,
        uint256[] calldata initialScores
    ) external {
        // calldata → memory
        uint256[] memory memoryScores = initialScores;
        
        // 创建新用户
        users[msg.sender].name = name;
        
        // 需要将 memory 数组复制到 storage
        for (uint256 i = 0; i < memoryScores.length; i++) {
            users[msg.sender].scores.push(memoryScores[i]);
        }
    }
    
    function getUsersData(address user) external view returns (
        string memory,
        uint256[] memory
    ) {
        // storage → memory
        string memory userName = users[user].name;
        
        // 动态数组需要手动复制
        uint256 scoreCount = users[user].scores.length;
        uint256[] memory userScores = new uint256[](scoreCount);
        
        for (uint256 i = 0; i < scoreCount; i++) {
            userScores[i] = users[user].scores[i];
        }
        
        return (userName, userScores);
    }
}
```

## 总结

### 关键选择原则：

1. **函数参数**：
   - 外部函数：优先使用 `calldata`（Gas 优化）
   - 内部函数：使用 `memory`

2. **局部变量**：
   - 需要引用原数据：使用 `storage` 引用
   - 需要临时处理：使用 `memory` 副本

3. **返回值**：
   - 总是使用 `memory`

4. **Gas 优化优先级**：
   ```
   calldata（读取） < memory（读写） < storage（读取） < storage（写入）
   ```

### 记忆要点：
- **storage** - 永久的，昂贵的，状态变量
- **memory** - 临时的，中等成本，函数内变量  
- **calldata** - 只读的，廉价的，函数参数

正确选择数据位置可以显著降低 Gas 成本并提高合约性能。
