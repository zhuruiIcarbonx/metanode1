# 与 Chainlink 预言机交互的智能合约设计

## 1. 基础架构设计

### 1.1 核心组件选择
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol";
import "@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol";
import "@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol";
import "@chainlink/contracts/src/v0.8/AutomationCompatible.sol";

contract ChainlinkIntegratedContract is VRFConsumerBaseV2, AutomationCompatible {
    // 价格喂价接口
    AggregatorV3Interface internal priceFeed;
    
    // VRF 配置
    VRFCoordinatorV2Interface internal COORDINATOR;
    uint64 internal subscriptionId;
    bytes32 internal keyHash;
    uint32 internal callbackGasLimit = 100000;
    uint16 internal requestConfirmations = 3;
    uint32 internal numWords = 1;
    
    // 自动化配置
    uint256 public lastUpkeepTime;
    uint256 public upkeepInterval;
    
    // 状态变量
    mapping(bytes32 => address) public vrfRequests;
    mapping(address => uint256) public userBalances;
    uint256 public currentPrice;
    uint256 public lastRandomValue;
    
    // 事件
    event PriceUpdated(uint256 price, uint256 timestamp);
    event RandomNumberRequested(bytes32 requestId, address requester);
    event RandomNumberFulfilled(bytes32 requestId, uint256 randomNumber);
    event UpkeepPerformed(uint256 timestamp);
    
    // 错误
    error InsufficientBalance();
    error PriceOutdated();
    error OnlyCoordinatorCanFulfill();
}
```

## 2. 多数据源价格喂价设计

### 2.1 聚合价格合约
```solidity
contract PriceOracle is ChainlinkIntegratedContract {
    // 多数据源配置
    struct PriceFeed {
        AggregatorV3Interface feed;
        uint8 decimals;
        string description;
        bool active;
        uint256 weight; // 权重用于加权平均
    }
    
    mapping(string => PriceFeed) public priceFeeds;
    string[] public feedNames;
    
    // 价格数据
    struct PriceData {
        uint256 price;
        uint256 timestamp;
        uint8 decimals;
    }
    
    mapping(string => PriceData) public latestPrices;
    
    // 配置
    uint256 public priceDeviationThreshold = 5; // 5% 偏差阈值
    uint256 public priceMaxAge = 60 minutes; // 价格最大有效期
    
    constructor(
        address vrfCoordinator,
        uint64 _subscriptionId,
        bytes32 _keyHash
    ) VRFConsumerBaseV2(vrfCoordinator) {
        COORDINATOR = VRFCoordinatorV2Interface(vrfCoordinator);
        subscriptionId = _subscriptionId;
        keyHash = _keyHash;
        upkeepInterval = 1 hours;
    }
    
    // 添加价格数据源
    function addPriceFeed(
        string memory name,
        address feedAddress,
        uint256 weight
    ) external onlyOwner {
        require(priceFeeds[name].feed == AggregatorV3Interface(address(0)), "Feed already exists");
        
        AggregatorV3Interface feed = AggregatorV3Interface(feedAddress);
        uint8 decimals = feed.decimals();
        string memory description = feed.description();
        
        priceFeeds[name] = PriceFeed({
            feed: feed,
            decimals: decimals,
            description: description,
            active: true,
            weight: weight
        });
        
        feedNames.push(name);
    }
    
    // 获取聚合价格
    function getAggregatedPrice(string memory base) public view returns (uint256) {
        uint256 totalWeight = 0;
        uint256 weightedPriceSum = 0;
        uint256 validFeedCount = 0;
        
        for (uint i = 0; i < feedNames.length; i++) {
            PriceFeed memory feedConfig = priceFeeds[feedNames[i]];
            
            if (!feedConfig.active) continue;
            
            try feedConfig.feed.latestRoundData() returns (
                uint80,
                int256 price,
                uint256,
                uint256 updatedAt,
                uint80
            ) {
                // 检查价格是否在有效期内
                if (block.timestamp - updatedAt > priceMaxAge) continue;
                
                uint256 normalizedPrice = uint256(price) * (10 ** (18 - feedConfig.decimals));
                weightedPriceSum += normalizedPrice * feedConfig.weight;
                totalWeight += feedConfig.weight;
                validFeedCount++;
                
            } catch {
                // 如果某个数据源失败，跳过
                continue;
            }
        }
        
        require(validFeedCount >= 2, "Insufficient valid price feeds");
        require(totalWeight > 0, "No valid weighted prices");
        
        return weightedPriceSum / totalWeight;
    }
    
    // 检查价格偏差
    function checkPriceDeviation(string memory feedName) public view returns (bool, uint256) {
        PriceFeed memory feedConfig = priceFeeds[feedName];
        require(feedConfig.active, "Feed not active");
        
        (, int256 price,, uint256 updatedAt,) = feedConfig.feed.latestRoundData();
        uint256 currentPrice = uint256(price) * (10 ** (18 - feedConfig.decimals));
        uint256 aggregatedPrice = getAggregatedPrice("ETH");
        
        uint256 deviation = (currentPrice > aggregatedPrice) ? 
            (currentPrice - aggregatedPrice) * 100 / aggregatedPrice :
            (aggregatedPrice - currentPrice) * 100 / aggregatedPrice;
            
        return (deviation <= priceDeviationThreshold, deviation);
    }
}
```

## 3. VRF 随机数集成

### 3.1 随机数生成与管理
```solidity
contract RandomNumberGenerator is PriceOracle {
    // VRF 请求管理
    struct RandomRequest {
        address requester;
        uint256 timestamp;
        bool fulfilled;
        uint256 randomNumber;
    }
    
    mapping(bytes32 => RandomRequest) public randomRequests;
    bytes32[] public pendingRequests;
    
    // 费用管理
    uint256 public vrfFee;
    mapping(address => uint256) public vrfCredits;
    
    // 请求随机数
    function requestRandomNumber() external returns (bytes32) {
        // 检查用户是否有足够的余额或信用
        require(
            userBalances[msg.sender] >= vrfFee || vrfCredits[msg.sender] >= vrfFee,
            "Insufficient balance for VRF fee"
        );
        
        // 扣除费用
        if (vrfCredits[msg.sender] >= vrfFee) {
            vrfCredits[msg.sender] -= vrfFee;
        } else {
            userBalances[msg.sender] -= vrfFee;
        }
        
        // 发起 VRF 请求
        bytes32 requestId = COORDINATOR.requestRandomWords(
            keyHash,
            subscriptionId,
            requestConfirmations,
            callbackGasLimit,
            numWords
        );
        
        randomRequests[requestId] = RandomRequest({
            requester: msg.sender,
            timestamp: block.timestamp,
            fulfilled: false,
            randomNumber: 0
        });
        
        pendingRequests.push(requestId);
        
        emit RandomNumberRequested(requestId, msg.sender);
        return requestId;
    }
    
    // VRF 回调函数
    function fulfillRandomWords(bytes32 requestId, uint256[] memory randomWords) internal override {
        require(randomRequests[requestId].requester != address(0), "Request not found");
        require(!randomRequests[requestId].fulfilled, "Request already fulfilled");
        
        randomRequests[requestId].randomNumber = randomWords[0];
        randomRequests[requestId].fulfilled = true;
        lastRandomValue = randomWords[0];
        
        // 从待处理列表中移除
        for (uint i = 0; i < pendingRequests.length; i++) {
            if (pendingRequests[i] == requestId) {
                pendingRequests[i] = pendingRequests[pendingRequests.length - 1];
                pendingRequests.pop();
                break;
            }
        }
        
        emit RandomNumberFulfilled(requestId, randomWords[0]);
    }
    
    // 获取随机数结果
    function getRandomResult(bytes32 requestId) external view returns (uint256, bool) {
        RandomRequest memory request = randomRequests[requestId];
        return (request.randomNumber, request.fulfilled);
    }
    
    // 清理过期的请求
    function cleanupExpiredRequests(uint256 maxAge) external {
        for (uint i = 0; i < pendingRequests.length; i++) {
            bytes32 requestId = pendingRequests[i];
            RandomRequest memory request = randomRequests[requestId];
            
            if (block.timestamp - request.timestamp > maxAge && !request.fulfilled) {
                // 标记为过期并退款
                delete randomRequests[requestId];
                vrfCredits[request.requester] += vrfFee;
                
                // 从数组中移除
                pendingRequests[i] = pendingRequests[pendingRequests.length - 1];
                pendingRequests.pop();
                i--; // 调整索引
            }
        }
    }
}
```

## 4. Chainlink Automation 集成

### 4.1 自动化维护任务
```solidity
contract AutomatedContract is RandomNumberGenerator {
    // 维护任务配置
    struct UpkeepConfig {
        bool priceUpdateEnabled;
        bool randomNumberEnabled;
        bool cleanupEnabled;
        uint256 priceUpdateInterval;
        uint256 randomNumberInterval;
        uint256 cleanupInterval;
    }
    
    UpkeepConfig public upkeepConfig;
    
    // 时间追踪
    uint256 public lastPriceUpdate;
    uint256 public lastRandomRequest;
    uint256 public lastCleanup;
    
    constructor() {
        upkeepConfig = UpkeepConfig({
            priceUpdateEnabled: true,
            randomNumberEnabled: false,
            cleanupEnabled: true,
            priceUpdateInterval: 1 hours,
            randomNumberInterval: 6 hours,
            cleanupInterval: 24 hours
        });
    }
    
    // 检查是否需要执行维护
    function checkUpkeep(
        bytes calldata /* checkData */
    ) external view override returns (bool upkeepNeeded, bytes memory performData) {
        upkeepNeeded = false;
        bytes memory data = "";
        
        // 检查价格更新
        if (upkeepConfig.priceUpdateEnabled && 
            block.timestamp - lastPriceUpdate >= upkeepConfig.priceUpdateInterval) {
            upkeepNeeded = true;
            data = abi.encode("PRICE_UPDATE");
        }
        
        // 检查随机数请求
        if (upkeepConfig.randomNumberEnabled && 
            block.timestamp - lastRandomRequest >= upkeepConfig.randomNumberInterval) {
            upkeepNeeded = true;
            data = abi.encode("RANDOM_REQUEST");
        }
        
        // 检查清理任务
        if (upkeepConfig.cleanupEnabled && 
            block.timestamp - lastCleanup >= upkeepConfig.cleanupInterval) {
            upkeepNeeded = true;
            data = abi.encode("CLEANUP");
        }
        
        return (upkeepNeeded, data);
    }
    
    // 执行维护任务
    function performUpkeep(bytes calldata performData) external override {
        string memory task = abi.decode(performData, (string));
        
        if (keccak256(abi.encodePacked(task)) == keccak256(abi.encodePacked("PRICE_UPDATE"))) {
            _updateAllPrices();
            lastPriceUpdate = block.timestamp;
        } 
        else if (keccak256(abi.encodePacked(task)) == keccak256(abi.encodePacked("RANDOM_REQUEST"))) {
            _requestScheduledRandom();
            lastRandomRequest = block.timestamp;
        }
        else if (keccak256(abi.encodePacked(task)) == keccak256(abi.encodePacked("CLEANUP"))) {
            _performCleanup();
            lastCleanup = block.timestamp;
        }
        
        lastUpkeepTime = block.timestamp;
        emit UpkeepPerformed(block.timestamp);
    }
    
    // 更新所有价格
    function _updateAllPrices() internal {
        for (uint i = 0; i < feedNames.length; i++) {
            string memory feedName = feedNames[i];
            PriceFeed memory feedConfig = priceFeeds[feedName];
            
            if (!feedConfig.active) continue;
            
            try feedConfig.feed.latestRoundData() returns (
                uint80,
                int256 price,
                uint256,
                uint256 updatedAt,
                uint80
            ) {
                latestPrices[feedName] = PriceData({
                    price: uint256(price),
                    timestamp: updatedAt,
                    decimals: feedConfig.decimals
                });
            } catch {
                // 记录错误但继续处理其他数据源
                continue;
            }
        }
        
        // 更新聚合价格
        currentPrice = getAggregatedPrice("ETH");
        emit PriceUpdated(currentPrice, block.timestamp);
    }
    
    // 计划随机数请求
    function _requestScheduledRandom() internal {
        if (pendingRequests.length < 5) { // 限制并发请求数量
            requestRandomNumber();
        }
    }
    
    // 执行清理任务
    function _performCleanup() internal {
        cleanupExpiredRequests(1 hours);
    }
}
```

## 5. 完整应用示例：预测市场

### 5.1 预测市场合约
```solidity
contract PredictionMarket is AutomatedContract {
    enum MarketStatus { Active, Resolved, Cancelled }
    
    struct Market {
        string question;
        uint256 endTime;
        uint256 totalPool;
        MarketStatus status;
        uint256 winningOutcome;
        uint256[] outcomePools;
        mapping(address => uint256[]) userBets;
    }
    
    Market[] public markets;
    uint256 public feePercentage = 2; // 2% 手续费
    
    // 事件
    event MarketCreated(uint256 marketId, string question, uint256 endTime);
    event BetPlaced(uint256 marketId, address better, uint256 outcome, uint256 amount);
    event MarketResolved(uint256 marketId, uint256 winningOutcome);
    
    // 创建市场
    function createMarket(
        string memory question,
        uint256 duration,
        uint256 outcomes
    ) external returns (uint256) {
        require(outcomes >= 2, "At least 2 outcomes required");
        
        uint256 marketId = markets.length;
        Market storage newMarket = markets.push();
        newMarket.question = question;
        newMarket.endTime = block.timestamp + duration;
        newMarket.status = MarketStatus.Active;
        newMarket.outcomePools = new uint256[](outcomes);
        
        emit MarketCreated(marketId, question, newMarket.endTime);
        return marketId;
    }
    
    // 下注
    function placeBet(uint256 marketId, uint256 outcome, uint256 amount) external {
        Market storage market = markets[marketId];
        require(market.status == MarketStatus.Active, "Market not active");
        require(block.timestamp < market.endTime, "Market ended");
        require(outcome < market.outcomePools.length, "Invalid outcome");
        
        // 使用 Chainlink 价格检查下注金额价值
        uint256 usdValue = (amount * currentPrice) / 1e18;
        require(usdValue >= 1e18, "Minimum bet is $1"); // 最小下注 $1
        
        userBalances[msg.sender] -= amount;
        market.totalPool += amount;
        market.outcomePools[outcome] += amount;
        market.userBets[msg.sender].push(outcome);
        
        emit BetPlaced(marketId, msg.sender, outcome, amount);
    }
    
    // 使用 Chainlink VRF 解析市场
    function resolveMarket(uint256 marketId, bytes32 vrfRequestId) external {
        Market storage market = markets[marketId];
        require(market.status == MarketStatus.Active, "Market not active");
        require(block.timestamp >= market.endTime, "Market not ended");
        require(randomRequests[vrfRequestId].fulfilled, "VRF not fulfilled");
        
        uint256 randomNumber = randomRequests[vrfRequestId].randomNumber;
        market.winningOutcome = randomNumber % market.outcomePools.length;
        market.status = MarketStatus.Resolved;
        
        emit MarketResolved(marketId, market.winningOutcome);
    }
    
    // 领取奖金
    function claimWinnings(uint256 marketId) external {
        Market storage market = markets[marketId];
        require(market.status == MarketStatus.Resolved, "Market not resolved");
        
        uint256 totalBet = 0;
        uint256 winningBets = 0;
        
        // 计算用户在该市场的总下注和获胜下注
        for (uint i = 0; i < market.userBets[msg.sender].length; i++) {
            uint256 outcome = market.userBets[msg.sender][i];
            totalBet += 1; // 简化：假设每注1个代币
            
            if (outcome == market.winningOutcome) {
                winningBets += 1;
            }
        }
        
        require(winningBets > 0, "No winning bets");
        
        // 计算奖金
        uint256 userShare = (winningBets * market.outcomePools[market.winningOutcome]) / totalBet;
        uint256 fee = (userShare * feePercentage) / 100;
        uint256 payout = userShare - fee;
        
        userBalances[msg.sender] += payout;
        
        // 清理用户下注记录
        delete market.userBets[msg.sender];
    }
}
```

## 6. 部署和配置脚本

### 6.1 Hardhat 部署脚本
```javascript
// scripts/deploy.js
const { ethers } = require("hardhat");

async function main() {
  // Chainlink 地址（主网）
  const VRF_COORDINATOR = "0x271682DEB8C4E0901D1a1550aD2e64D568E69909";
  const LINK_TOKEN = "0x514910771AF9Ca656af840dff83E8264EcF986CA";
  const ETH_USD_FEED = "0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419";
  
  // 配置参数
  const SUBSCRIPTION_ID = 1234; // 需要在 Chainlink 上创建
  const KEY_HASH = "0x8af398995b04c28e9951adb9721ef74c74f93e6a478f39e7e0777be13527e7ef";
  
  console.log("部署 Chainlink 集成合约...");
  
  const ChainlinkIntegrated = await ethers.getContractFactory("PredictionMarket");
  const contract = await ChainlinkIntegrated.deploy(
    VRF_COORDINATOR,
    SUBSCRIPTION_ID,
    KEY_HASH
  );
  
  await contract.deployed();
  
  console.log("合约部署地址:", contract.address);
  
  // 配置价格喂价
  console.log("配置价格数据源...");
  await contract.addPriceFeed("ETH-USD", ETH_USD_FEED, 100);
  
  // 配置维护任务
  console.log("配置自动化任务...");
  
  console.log("部署完成!");
}

main().catch((error) => {
  console.error(error);
  process.exitCode = 1;
});
```

### 6.2 测试脚本
```javascript
// test/chainlink-integration.test.js
const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("Chainlink 集成测试", function () {
  let predictionMarket;
  let owner, user1, user2;
  
  beforeEach(async function () {
    [owner, user1, user2] = await ethers.getSigners();
    
    // 使用 Hardhat 的本地 Chainlink 模拟
    const PredictionMarket = await ethers.getContractFactory("PredictionMarket");
    predictionMarket = await PredictionMarket.deploy(
      "0x...", // 本地模拟的 VRF Coordinator
      1,       // 订阅 ID
      "0x..."  // Key Hash
    );
    
    await predictionMarket.deployed();
  });
  
  it("应该正确创建市场", async function () {
    await predictionMarket.createMarket("ETH 价格会超过 $3000 吗？", 7 * 24 * 60 * 60, 2);
    
    const market = await predictionMarket.markets(0);
    expect(market.question).to.equal("ETH 价格会超过 $3000 吗？");
  });
  
  it("应该处理价格更新", async function () {
    // 模拟价格更新
    await predictionMarket.performUpkeep(ethers.utils.defaultAbiCoder.encode(["string"], ["PRICE_UPDATE"]));
    
    const currentPrice = await predictionMarket.currentPrice();
    expect(currentPrice).to.be.gt(0);
  });
});
```

## 7. 安全考虑和最佳实践

### 7.1 安全措施
```solidity
// 安全扩展
contract SecureChainlinkContract is PredictionMarket {
    // 重入保护
    bool private reentrancyLock;
    modifier nonReentrant() {
        require(!reentrancyLock, "Reentrancy detected");
        reentrancyLock = true;
        _;
        reentrancyLock = false;
    }
    
    // 权限控制
    mapping(address => bool) public administrators;
    
    modifier onlyAdmin() {
        require(administrators[msg.sender] || msg.sender == owner, "Not admin");
        _;
    }
    
    // 紧急停止
    bool public emergencyStop;
    
    modifier whenNotStopped() {
        require(!emergencyStop, "Contract is stopped");
        _;
    }
    
    // 价格有效性检查
    modifier validPrice(uint256 price, uint256 timestamp) {
        require(price > 0, "Invalid price");
        require(block.timestamp - timestamp <= priceMaxAge, "Price too old");
        _;
    }
    
    // 设置管理员
    function setAdministrator(address admin, bool status) external onlyOwner {
        administrators[admin] = status;
    }
    
    // 紧急停止
    function emergencyStopContract(bool stop) external onlyAdmin {
        emergencyStop = stop;
    }
    
    // 安全的价格获取
    function getSecurePrice(string memory feedName) 
        external 
        view 
        returns (uint256, uint256) 
    {
        PriceFeed memory feedConfig = priceFeeds[feedName];
        require(feedConfig.active, "Feed not active");
        
        (, int256 price,, uint256 updatedAt,) = feedConfig.feed.latestRoundData();
        require(price > 0, "Invalid price from feed");
        require(block.timestamp - updatedAt <= priceMaxAge, "Price too old");
        
        uint256 normalizedPrice = uint256(price) * (10 ** (18 - feedConfig.decimals));
        return (normalizedPrice, updatedAt);
    }
}
```

## 总结

设计 Chainlink 集成合约的关键要点：

1. **模块化设计**：分离价格喂价、VRF、Automation 功能
2. **多数据源**：使用多个价格源提高数据可靠性
3. **错误处理**：完善的 try-catch 和回退机制
4. **Gas 优化**：合理设置回调 Gas 限制和确认数
5. **安全措施**：重入保护、权限控制、紧急停止
6. **自动化**：利用 Chainlink Automation 减少手动维护
7. **升级能力**：考虑使用代理模式支持合约升级

这种设计能够创建健壮的、与 Chainlink 深度集成的 DeFi 应用，确保数据可靠性、随机数安全性和自动化运维。
